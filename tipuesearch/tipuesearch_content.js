var tipuesearch = {"pages":[{"title":" filterSD ","text":"filterSD Notes A work in progress to create a modern Fortran version of the filterSD optimization method. Original Fortran 77 Documentation FilterSD is a package of Fortran 77 subroutines for solving nonlinear programming problems and linearly constrained problems in continuous optimization. Please see the README.pdf file for instructions on compiling the source code. This package does not require any Third Party software. README.pdf The user needs to choose whether to use a sparse matrix or dense matrix data structure. To solve an NLP using a sparse matrix data structure, the subroutines in the following files are required filterSD.f, checkd.f, glcpd.f, l1sold.f, shared.f, schurQR.f, sparseA.f, util.f together with a user supplied driver program. The file schurQR.f implements a Schur complement scheme for sparse matrix updates. This replaces an a previous file sparseL.f implementing Fletcher-Matthews updates, which is also included in the distribution. These files are interchangeable. To solve an NLP using a dense matrix data structure, the subroutines in the following files are required filterSD.f, checkd.f, glcpd.f, l1sold.f, shared.f, denseL.f, denseA.f, util.f together with a user supplied driver program. To solve an LCP using a sparse matrix data structure, the subroutines in the following files are required glcpd.f, checkg.f, shared.f, schurQR.f, sparseA.f, util.f together with a user supplied driver program. To solve an LCP using a dense matrix data structure, the subroutines in the following files are required glcpd.f, checkg.f, shared.f, denseL.f, denseA.f, util.f together with a user supplied driver program. Information on how to set up the driver program is contained in the files filterSD.pdf and glcpd.pdf . Examples of driver programs are provided in the files hs106.f , hs106d.f , hs72.f and hs72d.f . To solve a QP or LP, replace glcpd.f by qlcpd.f in the above. Usage of qlcpd.f is described at the head of the file and is similar to that for glcpd.f . To facilitate access to CUTEr NLP test problems, a driver program driver.f and associated subroutines in the file user.f is provided. Documentation The latest API documentation can be found here . This was generated from the source code using FORD . Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"sparseA.f90 – filterSD","text":"Contents Functions aiscpr daiscpr aiscpri daiscpri aiscpri1 ailen aij Subroutines saipy msaipy isaipy isaipy1 iscatter iunscatter setaij cscale modify restore extend_la extend_a Source Code sparseA.f90 Source Code !Christen this file    sparseA.f !  Copyright (C) 1996 Roger Fletcher !  Current version dated 9 December 2010 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT !  ****************************************** !  Specification of A in sparse matrix format !  ****************************************** !  The matrix A contains gradients of the linear terms in the objective !  function (column 0) and the general constraints (columns 1:m). !  No explicit reference to simple bound constraints is required in A. !  The information is set in the parameters a(*) (double precision real) and !  la(*) (integer). !  In this sparse format, these vectors have dimension  a(1:maxa)  and !   la(0:maxla-1),  where maxa is at least nnza (the number of nonzero elements !  in A), and maxla is at least  nnza+m+3.  la(0) and the last m+2 elementss !  in la are pointers. !  The vectors a(.) and la(.) must be set as follows: !  a(j) and la(j) for j=1,nnza are set to the values and row indices (resp.) !  of all the nonzero elements of A. Entries for each column are grouped !  together in increasing column order. Within each column group, it is !  not necessary to have the row indices in increasing order. !  la(0) is a pointer which points to the start of the pointer information in !  la. la(0) must be set to nnza+1 (or a larger value if it is desired to !  allow for future increases to nnza). !  The last m+2 elements of la(.) contain pointers to the first elements in !  each of the column groupings. Thus la(la(0)+i)) for i=0,m is set to the !  location in a(.) containing the first nonzero element for column i of A. !  Also la(la(0)+m+1)) is set to nnza+1 (the first unused location in a(.)). !  Copyright, University of Dundee (R.Fletcher), June 1996 !  Current version dated 31/01/07 subroutine saipy ( s , a , la , i , y , n ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), y ( * ) !  saxpy with column i of A if ( s == 0.D0 ) return jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = la ( j ) y ( ir ) = y ( ir ) + s * a ( j ) end do 1 format ( A , 15 I2 ) 2 format ( A , 5E15 . 7 ) 3 format ( A / ( 20 I4 )) 4 format ( A / ( 5E15 . 7 )) return end subroutine msaipy ( s , a , la , i , y , n ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), y ( * ) !  saxpy with modulus of column i of A jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = la ( j ) y ( ir ) = y ( ir ) + s * abs ( a ( j )) end do return end !     subroutine daipy(s,a,la,i,y,n) !     DOUBLE PRECISION a(*),y(*),d !     dimension la(0:*) !     if (s==0.D0) return !     d=dble(s) !     jp=la(0)+i !     do j=la(jp),la(jp+1)-1 !       ir=la(j) !       y(ir)=y(ir)+d*dble(a(j)) !     end do !     return !     end subroutine isaipy ( s , a , la , i , y , n , lr , li ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), y ( * ), lr ( * ), li ( * ) !  indirectly addressed saxpy with column i of A if ( s == 0.D0 ) return jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = li ( la ( j )) y ( ir ) = y ( ir ) + s * a ( j ) end do return end ! the old isaipy was what might be called isaipy2 subroutine isaipy1 ( s , a , la , i , y , n , lr , li , m1 ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), y ( * ), lr ( * ), li ( * ) !  indirectly addressed saxpy with column i of A_1 if ( s == 0.D0 ) return jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = li ( la ( j )) if ( ir <= m1 ) y ( ir ) = y ( ir ) + s * a ( j ) end do return end !     subroutine ssaipy(s,a,la,i,y,n) !     implicit double precision (a-h,o-z) !     dimension a(*),la(0:*),y(*) !  saxpy with squares of column i of A !     if (s==0.D0) return !     jp=la(0)+i !     do j=la(jp),la(jp+1)-1 !       ir=la(j) !       y(ir)=y(ir)+s*(a(j))**2 !     end do !     return !     end function aiscpr ( n , a , la , i , x , b ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), x ( * ) !  scalar product with column i of A aiscpr = b jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = la ( j ) aiscpr = aiscpr + x ( ir ) * a ( j ) end do return end function daiscpr ( n , a , la , i , x , b ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), x ( * ) DOUBLE PRECISION daiscpr daiscpr = dble ( b ) jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = la ( j ) daiscpr = daiscpr + dble ( x ( ir )) * dble ( a ( j )) end do return end function aiscpri ( n , a , la , i , x , b , lr , li ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), x ( * ), lr ( * ), li ( * ) !  indirectly addressed scalar product with column i of A aiscpri = b jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = li ( la ( j )) aiscpri = aiscpri + x ( ir ) * a ( j ) end do return end function daiscpri ( n , a , la , i , x , b , lr , li ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), x ( * ), lr ( * ), li ( * ) DOUBLE PRECISION daiscpri daiscpri = dble ( b ) jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = li ( la ( j )) daiscpri = daiscpri + dble ( x ( ir )) * dble ( a ( j )) end do return end ! the old aiscpri was what might be called aiscpri2 function aiscpri1 ( n , a , la , i , x , b , lr , li , m1 ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), x ( * ), lr ( * ), li ( * ) !  indirectly addressed scalar product with column i of A_1 aiscpri1 = b jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ir = li ( la ( j )) if ( ir <= m1 ) aiscpri1 = aiscpri1 + x ( ir ) * a ( j ) end do return end function ailen ( n , a , la , i ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ) !  L2 length of column i of A ailen = 0.D0 jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 ailen = ailen + a ( j ) ** 2 end do ailen = sqrt ( ailen ) return end subroutine iscatter ( a , la , i , li , an , n ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), li ( * ), an ( * ) !  indirect scatter into previously zeroed vector an jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 an ( li ( la ( j ))) = a ( j ) end do return end subroutine iunscatter ( a , la , i , li , an , n ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), li ( * ), an ( * ) !  undo effect of iscatter jp = la ( 0 ) + i do j = la ( jp ), la ( jp + 1 ) - 1 an ( li ( la ( j ))) = 0.D0 end do return end function aij ( i , j , a , la ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ) !  get element A(i,j) jp = la ( 0 ) + j do ij = la ( jp ), la ( jp + 1 ) - 1 ir = la ( ij ) if ( ir == i ) then aij = a ( ij ) return end if end do aij = 0.D0 return end subroutine setaij ( aij , i , j , a , la ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ) !  set element A(i,j) jp = la ( 0 ) + j do jj = la ( jp + 1 ) - 1 , la ( jp ), - 1 ir = la ( jj ) if ( ir == i ) then a ( jj ) = aij return end if end do if ( aij == 0.D0 ) return print * , 'malfunction: no slot for A(i,j)' stop end subroutine cscale ( n , m , a , la , x , bl , bu , s , menu , ifail ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), x ( * ), bl ( * ), bu ( * ), s ( * ) !     Constraint scaling procedure for use prior to calling bqpd when using !     sparseA.f !     Parameters are set as for bqpd, except for s, menu and ifail !     The user must set the parameter menu to control how the !     x-variables are scaled (or equivalently how constraints i = 1:n !     are scaled), as follows !     menu = 1 indicates that a unit scaling applies to the x-variables !     menu = 2 the user provides estimates s(i)>0 of the magnitude of !              x(i) for i = 1:n. In this case the elements  x(i), bl(i), bu(i) !              are divided by s(i) for i = 1:n. !     In all cases, cscale goes on to scale the general constraints, in !     such a way that the normal vector of each nontrivial constraint in !     the scaled problem has an l_2 norm of unity. This scaling is also !     applied to the right hand sides  bl(i), bu(i) for i = n+1:n+m. !     The scaled data overwrites the original data. !     cscale also scales the constant vector of the quadratic function, !     which is found in a(1:n). However if a non-unit x-variable scaling !     is used, it is necessary for the user to scale the Hessian matrix !     G appropriately. This can be done by passing the x-variable scale !     factors s(i) i = 1:n into the subroutine gdotx using the !     parameter ws, and multiplying G(i,j) by s(i)*s(j) (possibly !     implicitly). !     cscale sets ifail = 1 to indicate that some s(i)< = 0, !             and ifail = 2 to indicate an incorrect setting of menu. !       Otherwise ifail = 0. integer pjp ifail = 2 if ( menu < 1 . or . menu > 2 ) return pjp = la ( 0 ) !     z=1.D0/log(2.D0) if ( menu == 1 ) then do j = 1 , n s ( j ) = 1.D0 end do else ifail = 1 do j = 1 , n if ( s ( j ) <= 0.D0 ) return end do !       if (menu==2) then !         do j=1,n !           s(j)=2.D0**nint(log(s(j))*z) !         end do !       end if do j = 1 , n if ( s ( j ) /= 1.D0 ) then x ( j ) = x ( j ) / s ( j ) bl ( j ) = bl ( j ) / s ( j ) bu ( j ) = bu ( j ) / s ( j ) end if end do do j = 1 , la ( pjp + 1 ) - 1 a ( j ) = a ( j ) * s ( la ( j )) end do end if do i = 1 , m t = 0.D0 do j = la ( pjp + i ), la ( pjp + i + 1 ) - 1 a ( j ) = s ( la ( j )) * a ( j ) t = t + a ( j ) ** 2 end do t = sqrt ( t ) if ( t == 0.D0 ) then s ( n + i ) = 1.D0 else !         t=2.D0**nint(log(t)*z) s ( n + i ) = t do j = la ( pjp + i ), la ( pjp + i + 1 ) - 1 a ( j ) = a ( j ) / t end do bl ( n + i ) = bl ( n + i ) / t bu ( n + i ) = bu ( n + i ) / t end if end do ifail = 0 return end subroutine modify ( n , m , sigma , s , a , la , maxa , iws ) implicit double precision ( a - h , o - z ) dimension s ( * ), a ( * ), la ( 0 : * ), iws ( * ) !  Modifies the sparse data structure to add an extra variable and duplicate !  the general constraints, to enable scaled L-infinity QPs to be solved. !  Scale factors given in s(1:m) and the coefficient of the objective function in sigma !  For unscaled problems set s=ones and sigma=1. !  Needs m+1 locations of integer workspace in iws(*) n1 = n + 1 n1m = n1 + m m1 = m + 1 la0 = la ( 0 ) nextra = la ( la0 + m1 ) - la ( la0 + 1 ) + m1 + m ij = la ( la0 + m1 ) + nextra !     print 1,'la0,nextra,ij',la0,nextra,ij if ( ij - 1 > maxa ) then print * , 'not enough space:  reset maxa to at least ' , ij - 1 stop end if do i = 1 , m1 iws ( i ) = la ( la0 + i ) end do la0 = ij la ( la0 + m1 + m ) = ij !  set lower bounds do i = m , 1 , - 1 ij = ij - 1 !       a(ij)=-1.D0 a ( ij ) =- s ( i ) la ( ij ) = n1 do j = iws ( i + 1 ) - 1 , iws ( i ), - 1 ij = ij - 1 a ( ij ) =- a ( j ) la ( ij ) = la ( j ) end do la ( la0 + m + i ) = ij end do !  set upper bounds do i = m , 1 , - 1 ij = ij - 1 !       a(ij)=-1.D0 a ( ij ) =- s ( i ) la ( ij ) = n1 do j = iws ( i + 1 ) - 1 , iws ( i ), - 1 ij = ij - 1 a ( ij ) = a ( j ) la ( ij ) = la ( j ) end do la ( la0 + i ) = ij end do ij = ij - 1 la ( ij ) = n1 a ( ij ) = sigma la ( la0 ) = 1 la ( 0 ) = la0 !     print 3,'pointers =',(la(i),i=la0,la0+m1+m) !     print 4,'a =',(a(i),i=1,la(la0+m1+m)-1) !     print 3,'la =',(la(i),i=1,la(la0+m1+m)-1) 1 format ( A , 15 I4 ) 2 format ( A , 5E15 . 7 ) 3 format ( A / ( 20 I4 )) 4 format ( A / ( 5E15 . 7 )) return end subroutine restore ( n , m , a , la ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ) !  restores the changes made by subroutine modify la0 = la ( 0 ) do i = 1 , m do j = la ( la0 + i ), la ( la0 + i + 1 ) - 2 la ( j - i ) = la ( j ) a ( j - i ) = a ( j ) end do la ( la0 + i ) = la ( la0 + i ) - i end do la ( la0 + m + 1 ) = la ( la0 + m + 1 ) - m - 1 !     print 3,'pointers =',(la(i),i=la0,la0+m+1) !     print 4,'a =',(a(i),i=1,la(la0+m+1)-1) !     print 3,'la =',(la(i),i=1,la(la0+m+1)-1) 3 format ( A / ( 20 I4 )) 4 format ( A / ( 5E15 . 7 )) return end subroutine extend_la ( n , m , la , lax ) implicit double precision ( a - h , o - z ) dimension la ( 0 : * ), lax ( 0 : * ) !  Modifies the sparse data structure to add an extra variable and duplicate !  the general constraints, to enable scaled L-infinity QPs to be solved. !  The gradient vector is assumed to have a single non-zero entry (n+1). n1 = n + 1 la0 = la ( 0 ) lax0 = 2 * ( la ( la0 + m + 1 ) - la ( la0 + 1 ) + m + 1 ) lax ( 0 ) = lax0 lax ( 1 ) = n1 lax ( lax0 ) = 1 ijx = 2 jp = lax0 + 1 do k = 1 , 2 do j = 1 , m lax ( jp ) = ijx do ij = la ( la0 + j ), la ( la0 + j + 1 ) - 1 lax ( ijx ) = la ( ij ) ijx = ijx + 1 end do lax ( ijx ) = n1 ijx = ijx + 1 jp = jp + 1 end do end do lax ( jp ) = ijx !     print 3,'lax pointers =',(lax(i),i=lax0,lax0+m+m+1) !     print 3,'lax =',(lax(i),i=1,lax(lax0+m+m+1)-1) 3 format ( A / ( 20 I4 )) return end subroutine extend_a ( n , m , a , la , ax , lax , s , sigma ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), ax ( * ), lax ( 0 : * ), s ( * ) !  Extends the sparse data values to enable scaled L-infinity QPs to be solved. !  Scale factors given in s(1:m) and the coefficient of the objective function in sigma !  For unscaled problems set s=ones and sigma=1. n1 = n + 1 la0 = la ( 0 ) ax ( 1 ) = sigma ijx = 2 !  set lower bounds do j = 1 , m do ij = la ( la0 + j ), la ( la0 + j + 1 ) - 1 ax ( ijx ) =- a ( ij ) ijx = ijx + 1 end do ax ( ijx ) =- s ( j ) ijx = ijx + 1 end do !  set upper bounds do j = 1 , m do ij = la ( la0 + j ), la ( la0 + j + 1 ) - 1 ax ( ijx ) = a ( ij ) ijx = ijx + 1 end do ax ( ijx ) =- s ( j ) ijx = ijx + 1 end do !     print 4,'ax =',(ax(i),i=1,lax(lax(0)+m+m+1)-1) 4 format ( A / ( 5E15 . 7 )) return end","tags":"","loc":"sourcefile/sparsea.f90.html"},{"title":"shared.f90 – filterSD","text":"Contents Block Data Units defaults Subroutines optest form_Ats zprod signst warm_start residuals store_rg trid formR formT insort checkT Source Code shared.f90 Source Code !  this file contains subordinate routines shared by glcpd.f, qlcpd.f and !  ql1lcpd.f block data defaults implicit double precision ( a - h , o - z ) common / epsc / eps , tol , emin common / repc / sgnf , nrep , npiv , nres common / refactorc / mc , mxmc common / wsc / kk , ll , kkk , lll , mxws , mxlws data eps , tol , emin , sgnf , nrep , npiv , nres , mxmc , kk , ll & / 111 1.D-19 , 1.D-12 , 0.D0 , 1.D-8 , 2 , 3 , 2 , 500 , 0 , 0 / end subroutine optest ( jmin , jmax , r , e , ls , rp , pj ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension r ( * ), e ( * ), ls ( * ) rp = 0.D0 do 1 j = jmin , jmax i = abs ( ls ( j )) if ( e ( i ) == 0.D0 ) print * , 'e(i)==0.D0: i =' , i ri = r ( i ) / e ( i ) if ( ri >= rp ) goto 1 !       if ((i/2)*2==i) then !         ic=i-1 !  this change is needed when nm is odd !         ic=i+1 !       else !         ic=i+1 !         ic=i-1 !       end if !       do jj=jmin,jmax !         if (ls(jj)==ic) goto 2 !       end do !        goto 1 !   2   continue rp = ri pj = j 1 continue return end subroutine form_Ats ( jmin , jmax , n , plus , a , la , an , w , ls , tol ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), an ( * ), w ( * ), ls ( * ) logical plus !  form At.s and denominators if ( plus ) then do j = jmin , jmax i = abs ( ls ( j )) if ( i > n ) then wi = aiscpr ( n , a , la , i - n , an , 0.D0 ) else wi = an ( i ) end if if ( wi /= 0.D0 ) then if ( abs ( wi ) <= tol ) then wi = 0.D0 else if ( ls ( j ) >= 0 ) then wi =- wi end if end if w ( i ) = wi end do else do j = jmin , jmax i = abs ( ls ( j )) if ( i > n ) then wi = aiscpr ( n , a , la , i - n , an , 0.D0 ) else wi = an ( i ) end if if ( wi /= 0.D0 ) then if ( abs ( wi ) <= tol ) then wi = 0.D0 else if ( ls ( j ) < 0 ) then wi =- wi end if end if w ( i ) = wi end do end if return end subroutine zprod ( k , n , a , la , an , r , w , ls , aa , ll ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), an ( * ), r ( * ), w ( * ), ls ( * ), aa ( * ), ll ( * ) common / noutc / nout do j = 1 , n - k w ( abs ( ls ( j ))) = 0.D0 end do do j = n - k + 1 , n w ( ls ( j )) =- r ( ls ( j )) end do call tfbsub ( n , a , la , 0 , w , an , aa , ll , ep ,. false .) return end subroutine signst ( n , r , w , ls ) implicit double precision ( a - h , o - z ) dimension r ( * ), w ( * ), ls ( * ) !  transfer with sign change as necessary do j = 1 , n i = abs ( ls ( j )) if ( ls ( j ) >= 0 ) then r ( i ) = w ( i ) else r ( i ) =- w ( i ) end if end do return end subroutine warm_start ( n , nm , a , la , x , bl , bu , b , ls , aa , ll , an , vstep ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), b ( * ), ls ( * ), & aa ( * ), ll ( * ), an ( * ) DOUBLE PRECISION daiscpr common / epsc / eps , tol , emin common / noutc / nout common / iprintc / iprint do j = 1 , n i = abs ( ls ( j )) if ( i <= n ) then b ( i ) = 0.D0 else if ( ls ( j ) >= 0 ) then b ( i ) = daiscpr ( n , a , la , i - n , x , - bl ( i )) else b ( i ) = daiscpr ( n , a , la , i - n , x , - bu ( i )) end if end if end do !     print 3,'ls =',(ls(i),i=1,n) 3 format ( A / ( 15 I5 )) !     write(nout,1000)'x =',(x(i),i=1,n) !     write(nout,1000)'b =',(b(i),i=1,nm) !     write(nout,1000)'r =',(b(abs(ls(j))),j=1,n) call tfbsub ( n , a , la , 0 , b , an , aa , ll , ep ,. false .) !     write(nout,1000)'d =',(an(i),i=1,n) call linf ( n , an , vstep , i ) if ( iprint >= 1 ) & write ( nout , * ) 'infinity norm of vertical step =' , vstep do i = 1 , n x ( i ) = x ( i ) - an ( i ) end do do j = 1 , n i = abs ( ls ( j )) if ( i <= n ) then if ( x ( i ) >= bu ( i ) - tol ) then x ( i ) = bu ( i ) ls ( j ) =- i else ls ( j ) = i if ( x ( i ) <= bl ( i ) + tol ) x ( i ) = bl ( i ) end if end if end do !     write(nout,*)'x =',(x(i),i=1,n) 1000 format ( a / ( e16 . 5 , 4e16 . 5 )) !1001 format(a/(i4,1x,e11.5,4(i4,1x,e11.5))) return end subroutine residuals ( n , jmin , jmax , a , la , x , bl , bu , r , ls , f , g , ninf ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), r ( * ), ls ( * ), g ( * ) common / epsc / eps , tol , emin DOUBLE PRECISION daiscpr , z f = 0.D0 ninf = 0 do i = 1 , n g ( i ) = 0.D0 end do do j = jmin , jmax i = abs ( ls ( j )) if ( i > n ) then z = daiscpr ( n , a , la , i - n , x , 0.D0 ) else z = dble ( x ( i )) end if ri = z - dble ( bl ( i )) ro = dble ( bu ( i )) - z if ( ri <= ro ) then ls ( j ) = i else ri = ro ls ( j ) =- i end if if ( abs ( ri ) <= tol ) then ri = 0.D0 else if ( ri < 0.D0 ) then f = f - ri ninf = ninf + 1 if ( i > n ) then call saipy ( - sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , g , n ) else g ( i ) = g ( i ) - sign ( 1.D0 , dble ( ls ( j ))) end if end if r ( i ) = ri end do return end subroutine store_rg ( k , ig , G , r , ls ) implicit double precision ( a - h , o - z ) dimension G ( k , * ), r ( * ), ls ( * ) do j = 1 , k G ( j , ig ) = r ( ls ( j )) end do return end subroutine trid ( d , e , n ) implicit double precision ( a - h , o - z ) dimension d ( * ), e ( * ) !  QL method for eigenvalues of a tridiagonal matrix.  d(i) i=1,..,n !  is diagonal and e(i) i=1,..,n-1 is subdiagonal (storage for dummy e(n) !  must be available). Eigenvalues returned in d !  This routine is adapted from the EISPAK subroutine imtq11. if ( n == 1 ) return e ( n ) = 0.D0 do 15 l = 1 , n iter = 0 1 continue do 12 m = l , n - 1 dd = abs ( d ( m )) + abs ( d ( m + 1 )) if ( abs ( e ( m )) + dd == dd ) goto 2 12 continue m = n 2 continue if ( m == l . or . iter == 30 ) goto 15 iter = iter + 1 g = ( d ( l + 1 ) - d ( l )) * 5.D-1 / e ( l ) r = sqrt ( g ** 2 + 1.D0 ) g = d ( m ) - d ( l ) + e ( l ) / ( g + sign ( r , g )) s = 1.D0 c = 1.D0 p = 0.D0 do 14 i = m - 1 , l , - 1 f = s * e ( i ) b = c * e ( i ) if ( abs ( f ) >= abs ( g )) then c = g / f r = sqrt ( c ** 2 + 1.D0 ) e ( i + 1 ) = f * r s = 1.D0 / r c = c * s else s = f / g r = sqrt ( s ** 2 + 1.D0 ) e ( i + 1 ) = g * r c = 1.D0 / r s = s * c end if g = d ( i + 1 ) - p r = ( d ( i ) - g ) * s + 2. * c * b p = s * r d ( i + 1 ) = g + p g = c * r - b 14 continue d ( l ) = d ( l ) - p e ( l ) = g e ( m ) = 0.D0 goto 1 15 continue return end subroutine formR ( nv , k , ig , maxg , a , b , c , d , e , G , R ) implicit double precision ( a - h , o - z ) dimension a ( * ), b ( * ), c ( * ), d ( * ), e ( * ), G ( k , * ), R ( * ) !     print *,'G and ig',ig !     do i=1,k !       print 5,(G(i,j),j=1,6) !     end do !     print 4,'a =',(a(i),i=1,6) !     print 4,'b =',(b(i),i=1,6) !     print 4,'c =',(c(i),i=1,6) 10 ii = ig - nv if ( ii < 0 ) ii = ii + maxg do i = 1 , nv ii = ii + 1 if ( ii > maxg ) ii = 1 e ( i ) = a ( ii ) nvi = nv - i + 1 nvi1 = nvi + 1 d ( 1 ) = b ( ii ) d ( 2 ) = c ( ii ) jj = ii + 1 if ( jj > maxg ) jj = 1 do j = 3 , nvi1 jj = jj + 1 if ( jj > maxg ) jj = 1 d ( j ) = scpr ( 0.D0 , G ( 1 , jj ), G ( 1 , ii ), k ) end do ij = i do j = 1 , i - 1 call mysaxpy ( - R ( ij ), R ( ij ), d , nvi1 ) ij = ij + maxg - j end do if ( d ( 1 ) <= 0.D0 ) then !         print *,'R is singular' nv = i - 1 goto 10 end if t = sqrt ( d ( 1 )) R ( ij ) = t do j = 1 , nvi R ( ij + j ) = d ( j + 1 ) / t end do !       print 4,'row of R =',(R(ij+j),j=0,nvi) end do !     print 4,'R matrix',(R(j),j=1,nv+1) !     ii=maxg !     do i=1,nv-1 !       print 5,(0.D0,j=1,i),(R(ii+j),j=1,nv-i+1) !       ii=ii+maxg-i !     end do return 2 format ( A , 5E13 . 5 ) 4 format ( A / ( 6E13 . 5 )) 5 format (( 6E13 . 5 )) end subroutine formT ( n , nmax , R , d , e ) implicit double precision ( a - h , o - z ) dimension R ( * ), d ( * ), e ( * ) !  forms the tridiagonal matrix  T = [R | Qt.gp].S.R&#94;(-1) in d and e t = e ( 1 ) * R ( 2 ) / R ( 1 ) d ( 1 ) = e ( 1 ) - t ir = 1 irp = nmax + 1 do i = 2 , n im = i - 1 e ( im ) =- e ( im ) * R ( irp ) / R ( ir ) ir = irp irp = irp + nmax - im dii = t t = e ( i ) * R ( ir + 1 ) / R ( ir ) d ( i ) = dii + e ( i ) - t end do return end subroutine insort ( nv , v ) implicit double precision ( a - h , o - z ) dimension v ( * ) !  insertion sort into ascending order do i = 2 , nv t = v ( i ) do j = i - 1 , 1 , - 1 if ( v ( j ) > t ) then v ( j + 1 ) = v ( j ) else v ( j + 1 ) = t goto 10 end if end do v ( 1 ) = t 10 continue end do return end subroutine checkT ( n , nmax , R , a , d ) implicit double precision ( a - h , o - z ) dimension R ( * ), a ( * ), d ( * ) dimension T ( 10 , 10 ) if ( n > 9 ) print * , 'Increase dimension of T' if ( n > 9 ) stop do j = 1 , n + 1 T ( 1 , j ) = R ( j ) end do ii = nmax do i = 1 , n - 1 do j = 1 , i T ( i + 1 , j ) = 0.D0 end do do j = 1 , n - i + 1 T ( i + 1 , j + i ) = R ( ii + j ) end do ii = ii + nmax - i end do !     print 4,'R matrix' !     do i=1,n !       print 5,(T(i,j),j=1,n+1) !     end do !     print 2,'a =',(a(i),i=1,n) do i = 1 , n call mysaxpy ( - 1.D0 , T ( 1 , i + 1 ), T ( 1 , i ), n ) do j = 1 , n T ( j , i ) = T ( j , i ) * a ( i ) end do end do !     print 4,'R*J matrix' !     do i=1,n !       print 5,(T(i,j),j=1,n) !     end do print 4 , 'T matrix' do i = 1 , n do j = 1 , n d ( j ) = T ( i , j ) end do call rtsol ( n , nn , nmax , R , d ) print 5 ,( d ( j ), j = 1 , n ) end do return 2 format ( A , 6E15 . 7 ) 4 format ( A / ( 5E15 . 7 )) 5 format (( 5E15 . 7 )) end","tags":"","loc":"sourcefile/shared.f90.html"},{"title":"l1sold.f90 – filterSD","text":"Contents Subroutines l1sold optest1 check1 Source Code l1sold.f90 Source Code !Christen this file l1sold.f !ut here >>>>>>>>>>>>>>>>>> !  Copyright (C) 2010 Roger Fletcher subroutine l1sold ( n , m , k , kmax , maxg , a , la , x , bl , bu , f , g , r , w , e , ls , & alp , lp , mlp , peq , ws , lws , cws , v , nv , rgtol , ifail , iprint , nout ) implicit double precision ( a - h , r - z ), integer ( i - q ) !  This routine is a post-processor for qlcpd and glcpd. In the case that the !  constraint set is infeasible (ifail=3), l1sold finds a best l1 solution of !  the general constraints, subject to the simple bounds being satisfied. !  Parameters are a subset of those for glcpd and must be passed through !  unchanged. For qlcpd a dummy parameter cws must be included. !  A modified form of Wolfe's method is used to resolve degeneracy. !  If the solution is degenerate, there may be inactive constraints with !  zero residual and multiplier 1. Such constraints are marked on exit by !  setting their residual value (in r(*)) to -eps, (see common/epsc for eps) parameter ( ainfty = 1.D100 ) dimension a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), g ( * ), r ( * ), w ( * ), e ( * ), ls ( * ), & alp ( * ), lp ( * ), ws ( * ), lws ( * ), v ( * ) character cws ( * ) character ( len = 32 ) spaces common / lcpdc / na , na1 , nb , nb1 , krg , krg1 , kr , kr1 , & ka , ka1 , kb , kb1 , kc , kc1 , kd , kd1 , ke , ke1 , lu1 , ll1 common / epsc / eps , tol , emin common / infoc / vstep , iter , npv , nfn , ngr common / repc / sgnf , nrep , npiv , nres common / wsc / kk , ll , kkk , lll , mxws , mxlws common / refactorc / nup , nfreq common / alphac / alpha , rp , pj , qqj , qqj1 logical plus 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) 5 format (( 6E15 . 7 )) !     if (iprint==3) print 4,'a =',(a(i),i=1,110) spaces = '         ' n1 = n + 1 nm = n + m lp ( 1 ) = nm lev = 1 npv = 0 !  collect simple bound equations peq = 0 do j = peq + 1 , n - k i = abs ( ls ( j )) if ( i <= n . and . bl ( i ) == bu ( i )) then peq = peq + 1 call iexch ( ls ( j ), ls ( peq )) end if end do gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f !     print 4,'gradient =',(g(i),i=1,n) goto 20 !  start of major iteration 10 continue if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f !  calculate multipliers !     print 4,'gradient =',(g(i),i=1,n) do i = 1 , nm w ( i ) = 0.D0 end do call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) call signst ( n , r , w , ls ) 20 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) !       write(nout,1000)'steepest edge coefficients', !    *    (e(abs(ls(j))),j=1,n) write ( nout , 1 ) '# of bound equations and free variables = ' , peq , k end if !     if (iprint==3) print 4,'gradient =',(g(i),i=1,n) !     if (iprint==3) write(nout,1001)'residual vector and indices', !    *    (ls(j),r(abs(ls(j))),j=n1,lp(1)) !     call check1(n,lp(1),nm,k,kmax,g,a,la,x,bl,bu,r,ls,lp,ws(nb1),f, !    *  ws,lws,cws,1,p,rp) 21 continue !  l1 optimality test call optest1 ( peq , k , n , bl , bu , r , e , ls , rp , pj ) 22 continue if ( rp <= gtol ) then !  allow for changes to norm(g) gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm end if if ( rp <= gtol ) then do j = peq + 1 , n - k i = abs ( ls ( j )) if ( i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do do i = 1 , n x ( i ) = max ( min ( x ( i ), bu ( i )), bl ( i )) end do do j = n1 , nm i = abs ( ls ( j )) if ( r ( i ) == 0.D0 . and . i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do !       write(nout,1)'# of simple bound equations = ',peq do j = peq + 1 , n - k i = abs ( ls ( j )) if ( bl ( i ) == bu ( i )) then peq = peq + 1 call iexch ( ls ( j ), ls ( peq )) end if end do !       write(nout,1001)'costs vector and indices', !    *    (ls(j),r(abs(ls(j))),j=1,n) !       write(nout,1)'# of active equations and free variables = ',peq,k if ( iprint >= 2 ) then write ( nout , * ) 'OPTIMAL l1 solution' if ( iprint >= 3 ) then !           write(nout,1000)'x variables',(x(i),i=1,n) write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , nm ) end if end if ifail = 0 return end if p = abs ( ls ( pj )) if ( iprint >= 2 ) write ( nout , * ) 'CHOOSE p,pj =' , ls ( pj ), pj , r ( p ) !  compute +/- Steepest Edge search direction s in an(.) call tfbsub ( n , a , la , p , ws ( na1 ), ws ( na1 ), ws ( lu1 ), lws ( ll1 ), & e ( p ),. true .) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( ls ( pj ) < 0 ) rp =- rp if ( rp * r ( p ) <= 0.D0 ) then print 2 , '3rp,r(p),rp-r(p)' , rp , r ( p ), rp - r ( p ) r ( p ) = 0.D0 goto 98 end if if ( pj > n - k ) then rp =- abs ( r ( p )) plus = ls ( pj ) >= 0. eqv . r ( p ) < 0.D0 else if ( r ( p ) > 0.D0 ) then rp = 1.D0 - r ( p ) plus = ls ( pj ) < 0 else rp = r ( p ) plus = ls ( pj ) >= 0 end if snorm = e ( p ) !     print 4,'s (or -s if .not.plus) =',(ws(i),i=na1,na+n) !  form At.s and denominators call form_Ats ( n1 , lp ( 1 ), n , plus , a , la , ws ( na1 ), w , ls , snorm * tol ) !  return from degeneracy code 30 continue if ( iprint >= 3 ) then !       write(nout,1000)'x variables',(x(i),i=1,n) write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , lp ( 1 )) write ( nout , 1000 ) 'denominators' ,( w ( abs ( ls ( j ))), j = n1 , lp ( 1 )) end if !     print 2,'slope for r(169) =',aiscpr(n,a,la,169-n,ws(na1),0.D0) !     print 2,'slope for r(217) =',aiscpr(n,a,la,217-n,ws(na1),0.D0) !     print *,'plus =',plus 40 continue !  level 1 ratio tests amax = ainfty qj = 0 do 41 j = n - k + 1 , n i = ls ( j ) si = ws ( na + i ) t = abs ( si ) if ( t <= tol ) goto 41 if ( si > 0.D0 . eqv . plus ) then z = bu ( i ) - x ( i ) if ( abs ( z ) < tol ) then z = 0.D0 x ( i ) = bu ( i ) else z = z / t end if else z = x ( i ) - bl ( i ) if ( abs ( z ) < tol ) then z = 0.D0 x ( i ) = bl ( i ) else z = z / t end if end if if ( z > amax ) goto 41 amax = z qj = j 41 continue if ( pj <= n - k . and . r ( p ) < 0.D0 . and . bu ( p ) - bl ( p ) < amax ) then amax = bu ( p ) - bl ( p ) qj = pj end if alpha = amax do 44 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi == 0.D0 ) goto 44 ri = r ( i ) if ( ri ==- eps ) then if ( bl ( i ) == bu ( i ) . and . wi < 0.D0 ) then alpha = 0.D0 q = i qj = j goto 45 end if goto 44 else if ( ri < 0.D0 ) then if ( wi > 0.D0 ) goto 44 z = ( ri - tol ) / wi else if ( wi > 0.D0 ) then z = ( ri + tol ) / wi else z = ( bl ( i ) - bu ( i ) + ri - tol ) / wi end if if ( z >= alpha ) goto 44 alpha = z qj = j 44 continue q = abs ( ls ( qj )) if ( qj > n ) then if ( r ( q ) < 0.D0 . eqv . w ( q ) < 0.D0 ) then alpha = r ( q ) / w ( q ) else alpha = ( bl ( q ) - bu ( q ) + r ( q )) / w ( q ) end if end if 45 continue if ( iprint >= 2 ) then write ( nout , 2 ) 'r(q),w(q) =' , r ( q ), w ( q ) write ( nout , * ) 'alpha =' , alpha , '   q =' , q end if if ( alpha == 0.D0 . and . pj <= n - k ) then if ( iprint >= 2 ) & write ( nout , * ) 'degeneracy block at level 1' if ( w ( q ) < 0.D0 . and . r ( q ) /=- eps ) then w ( q ) =- w ( q ) ls ( qj ) =- ls ( qj ) end if alp ( 1 ) = f plev = n do j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( r ( i ) ==- eps ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) r ( i ) =- 1.D0 else if ( r ( i ) == 0.D0 ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) r ( i ) = 1.D0 end if end do lp ( 2 ) = plev lev = 2 !       write(nout,1001)'costs vector and indices', !    *    (ls(j),r(abs(ls(j))),j=1,n) !       write(nout,1)'# of bound equations and free variables = ',peq,k if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,''     level = 2'', ''    f ='',E16.8)' ) npv , f goto 86 end if if ( alpha > 0.D0 ) then ff = f f = f + alpha * rp if ( f >= ff ) then if ( pj > n - k . or . r ( p ) < 0.D0 ) then r ( p ) = 0.D0 else r ( p ) = 1.D0 end if goto 20 end if if ( plus ) then call mysaxpy ( alpha , ws ( na1 ), x , n ) else call mysaxpy ( - alpha , ws ( na1 ), x , n ) end if !  update r for inactive c/s do 61 j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( w ( i ) == 0.D0 ) goto 61 ri = r ( i ) - alpha * w ( i ) if ( abs ( ri ) <= tol ) ri = 0.D0 if ( r ( i ) < 0.D0 . and . ri >= 0.D0 ) then !  remove contribution to gradient call saipy ( sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , g , n ) call newg end if if ( w ( i ) < 0.D0 ) then ro = ( bu ( i ) - bl ( i )) - ri if ( abs ( ro ) <= tol ) ro = 0.D0 if ( ro < ri ) then ri = ro !             w(i)=-w(i) ls ( j ) =- ls ( j ) end if end if if ( ri == 0.D0 . and . i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if r ( i ) = ri 61 continue end if 70 continue if ( qj /= pj ) then !  pivot interchange if ( iprint >= 2 ) write ( nout , * ) 'replace' , p , ' by' , q call pivot ( p , q , n , nm , a , la , e , ws ( lu1 ), lws ( ll1 ), ifail , npv ) if ( ifail >= 1 ) then if ( iprint >= 1 ) write ( nout , * ) 'near singularity in pivot (1)' goto 98 end if if ( pj > n - k ) then r ( p ) = x ( p ) - bl ( p ) rpu = bu ( p ) - x ( p ) if ( rpu < r ( p )) then r ( p ) = rpu ls ( pj ) =- p else ls ( pj ) = p end if if ( r ( p ) <= tol ) r ( p ) = 0.D0 else if ( r ( p ) > 0.D0 ) then call saipy ( - sign ( 1.D0 , dble ( ls ( pj ))), a , la , p - n , g , n ) call newg r ( p ) =- alpha else rpu = bu ( p ) - bl ( p ) - alpha if ( abs ( rpu ) <= tol ) rpu = 0.D0 if ( alpha <= rpu ) then r ( p ) = alpha else r ( p ) = rpu ls ( pj ) =- ls ( pj ) end if end if if ( pj > n - k ) then k = k - 1 call iexch ( ls ( pj ), ls ( n - k )) pj = n - k end if call iexch ( ls ( pj ), ls ( qj )) if ( q <= n . and . bl ( q ) == bu ( q )) then peq = peq + 1 call iexch ( ls ( pj ), ls ( peq )) end if goto 10 end if !  opposite bound comes active !     r(p)=-rp if ( pj <= n - k ) then ls ( pj ) =- ls ( pj ) goto 10 end if !  free variable reaches its bound if ( r ( p ) < 0.D0 ) ls ( pj ) =- p k = k - 1 call iexch ( ls ( pj ), ls ( n - k )) goto 10 !  recursive code for resolving degeneracy (Wolfe's method) 80 continue !  calculate multipliers call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) call signst ( n , r , w , ls ) !  reset multiplier loop 82 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) !       write(nout,1000)'steepest edge coefficients', !    *    (e(abs(ls(j))),j=1,n) write ( nout , 1 ) '# of bound equations and free variables = ' , peq , k end if 84 continue !     call check1(n,lp(1),nm,k,kmax,g,a,la,x,bl,bu,r,ls,lp,ws(nb1),f, !    *  ws,lws,cws,lev,p,rp) 85 continue call optest1 ( peq , k , n , bl , bu , r , e , ls , rp , pj ) if ( rp <= gtol . or . pj > n - k ) then if ( iprint >= 2 ) write ( nout , * ) 'return to level 1' do j = n1 , lp ( 2 ) i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) then r ( i ) =- eps else r ( i ) = 0.D0 end if end do lev = 1 f = alp ( 1 ) goto 22 end if p = abs ( ls ( pj )) if ( iprint >= 2 ) write ( nout , * ) 'CHOOSE p,pj =' , p , pj !  compute +/- Steepest Edge (SE) search direction s in an(.) call tfbsub ( n , a , la , p , ws ( na1 ), ws ( na1 ), ws ( lu1 ), lws ( ll1 ), & e ( p ),. true .) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( ls ( pj ) < 0 ) rp =- rp if ( rp * r ( p ) <= 0.D0 ) then print 2 , '4rp,r(p),rp-r(p)' , rp , r ( p ), rp - r ( p ) do j = n1 , lp ( 2 ) i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) then r ( i ) =- eps else r ( i ) = 0.D0 end if end do f = alp ( 1 ) goto 98 end if if ( r ( p ) > 0.D0 ) then rp = 1.D0 - r ( p ) plus = ls ( pj ) < 0 else rp = r ( p ) plus = ls ( pj ) >= 0 end if snorm = e ( p ) !     print 4,'s (or -s if .not.plus) =',(ws(i),i=na1,na+n) !  form At.s and denominators call form_Ats ( n1 , lp ( lev ), n , plus , a , la , ws ( na1 ), w , ls , snorm * tol ) !     print 2,'slope for r(169) =',aiscpr(n,a,la,169-n,ws(na1),0.D0) !     print 2,'slope for r(217) =',aiscpr(n,a,la,217-n,ws(na1),0.D0) !     print *,'plus =',plus 86 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , lp ( lev )) write ( nout , 1000 ) 'denominators' ,( w ( abs ( ls ( j ))), j = n1 , lp ( lev )) end if 88 continue !  ratio test at higher levels alpha = ainfty qj = 0 do 90 j = n1 , lp ( lev ) i = abs ( ls ( j )) wi = w ( i ) if ( wi == 0.D0 ) goto 90 ri = r ( i ) if ( ri ==- eps ) then if ( bl ( i ) == bu ( i ) . and . wi < 0.D0 ) then alpha = 0.D0 q = i qj = j goto 91 end if goto 90 else if ( ri < 0.D0 ) then if ( wi > 0.D0 ) goto 90 z = ( ri - tol ) / wi else if ( wi > 0.D0 ) then z = ( ri + tol ) / wi else goto 90 !         if (bl(i)<bu(i)) goto 90 !         z=(ri-2.D0-tol)/wi end if if ( z >= alpha ) goto 90 alpha = z qj = j 90 continue if ( qj == 0 ) then do j = n1 , lp ( lev ) i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) then r ( i ) =- eps else r ( i ) = 0.D0 end if end do call form_Ats ( lp ( lev ) + 1 , lp ( lev - 1 ), n , plus , a , la , ws ( na1 ), & w , ls , snorm * tol ) lev = lev - 1 f = alp ( lev ) if ( iprint >= 2 ) write ( nout , * ) 'UNBOUNDED:   p =' , p , & '   return to level' , lev if ( lev > 1 ) goto 86 if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) write ( nout , 1 ) '# of bound equations and free variables = ' , peq , k end if goto 30 end if q = abs ( ls ( qj )) alpha = r ( q ) / w ( q ) !     if (alpha<0.D0) then !       r(q)=r(q)-2.D0 !       w(q)=-w(q) !       ls(qj)=-ls(qj) !     end if !     print *,'alpha =',alpha 91 continue if ( iprint >= 2 ) then write ( nout , * ) 'alpha =' , alpha , '   p =' , p , '   q =' , q write ( nout , 2 ) 'r(p),r(q),w(q) =' , r ( p ), r ( q ), w ( q ) end if if ( alpha == 0.D0 ) then if ( iprint >= 2 ) write ( nout , 1 ) & 'degeneracy block at level' , lev if ( lev + 2 > mlp ) then ifail = 5 return end if if ( w ( q ) < 0.D0 . and . r ( q ) /=- eps ) then w ( q ) =- w ( q ) ls ( qj ) =- ls ( qj ) end if !       r(q)=0.D0 !       alp(lev)=f plev = n do j = n1 , lp ( lev ) i = abs ( ls ( j )) if ( r ( i ) ==- eps ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) r ( i ) =- 1.D0 else if ( r ( i ) == 0.D0 ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) r ( i ) = 1.D0 end if end do lev = lev + 1 lp ( lev ) = plev if ( iprint >= 2 ) write ( nout , * ) 'degeneracy: increase level to ' , lev if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,A,''level ='',I2, ''    f ='',E16.8)' ) npv , spaces (: 3 * lev - 1 ), lev , f goto 86 end if !  update r and f if ( alpha > 0.D0 ) then !       ff=f !       f=f+alpha*rp !       if (f>=ff) then !         if (r(p)>0.D0) then !           r(p)=1.D0 !         else !           r(p)=0.D0 !         end if !          goto 85 !       end if do 92 j = n1 , lp ( lev ) i = abs ( ls ( j )) if ( w ( i ) == 0.D0 ) goto 92 ri = r ( i ) - alpha * w ( i ) if ( abs ( ri ) <= tol ) ri = 0.D0 if ( r ( i ) < 0.D0 . and . ri >= 0.D0 ) then !  remove contribution to gradient call saipy ( sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , g , n ) call newg end if !         if (w(i)<0.D0 .and. bl(i)==bu(i)) then !           ro=2.D0-ri !           if (abs(ro)<=tol)ro=0.D0 !           if (ro<ri) then !             ri=ro !             w(i)=-w(i) !             ls(j)=-ls(j) !           end if !         end if r ( i ) = ri 92 continue end if if ( iprint >= 2 ) write ( nout , * ) 'replace' , p , ' by' , q call pivot ( p , q , n , nm , a , la , e , ws ( lu1 ), lws ( ll1 ), ifail , npv ) if ( ifail >= 1 ) then if ( ifail >= 2 ) return !       call iexch(ls(pj),ls(qj)) if ( iprint >= 1 ) write ( nout , * ) 'near singularity in pivot (4)' goto 98 end if if ( r ( p ) > 0.D0 ) then !  add contribution to g from c/s p call saipy ( - sign ( 1.D0 , dble ( ls ( pj ))), a , la , p - n , g , n ) call newg r ( p ) =- alpha else rpu = 2.D0 - alpha if ( alpha <= rpu . or . bl ( p ) < bu ( p )) then r ( p ) = alpha else r ( p ) = rpu ls ( pj ) =- ls ( pj ) end if end if if ( abs ( r ( p )) <= tol ) r ( p ) = 0.D0 !  exchange a constraint call iexch ( ls ( pj ), ls ( qj )) if ( q <= n . and . bl ( q ) == bu ( q )) then peq = peq + 1 call iexch ( ls ( pj ), ls ( peq )) end if if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,A,''level ='',I2, ''    f ='',E16.8)' ) npv , spaces (: 3 * lev - 1 ), lev , f goto 80 !  restart sequence 98 continue return 1000 format ( a / ( e16 . 5 , 4e16 . 5 )) 1001 format ( a / ( i4 , 1 x , e12 . 5 , 4 ( i4 , 1 x , e12 . 5 ))) !1000 format(a/(e18.8,3e19.8)) !1001 format(a/(i3,1x,e14.8,3(i4,1x,e14.8))) end subroutine optest1 ( peq , k , n , bl , bu , r , e , ls , rp , pj ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension bl ( * ), bu ( * ), r ( * ), e ( * ), ls ( * ) rp = 0.D0 do 1 j = peq + 1 , n - k i = abs ( ls ( j )) ri =- r ( i ) / e ( i ) if ( i <= n ) then if ( ri <= rp ) goto 1 else if ( ri < 0.D0 ) then ri = ( r ( i ) - 1.D0 ) / e ( i ) if ( ri <= rp ) goto 1 else if ( ri > rp ) then if ( bl ( i ) == bu ( i )) then ri = ( - r ( i ) - 1.D0 ) / e ( i ) if ( ri <= rp ) goto 1 r ( i ) =- r ( i ) ls ( j ) =- ls ( j ) end if else goto 1 end if rp = ri pj = j 1 continue !  additional test for free variables do j = n - k + 1 , n i = abs ( ls ( j )) ri = abs ( r ( i )) / e ( i ) if ( ri >= rp ) then rp = ri pj = j end if end do return end subroutine check1 ( n , nm , nmi , k , kmax , g , a , la , x , bl , bu , r , ls , lp , an , f , & ws , lws , cws , lev , p , alp2 ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension g ( * ), a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), r ( * ), ls ( * ), lp ( * ), & an ( * ), ws ( * ), lws ( * ) character cws ( * ) common / noutc / nout common / epsc / eps , tol , emin !     print *,'ENTER check1' e = 0.D0 if ( lev == 1 ) then do j = n + 1 , nm i = abs ( ls ( j )) if ( i <= n ) then s = x ( i ) else s = aiscpr ( n , a , la , i - n , x , 0.D0 ) end if if ( ls ( j ) > 0 ) then !           print *,'i,s,r(i),bl(i)',i,s,r(i),bl(i) s = r ( i ) - s + bl ( i ) else s = r ( i ) + s - bu ( i ) end if if ( abs ( s ) <= tol * max ( 1.D0 , abs ( r ( i )))) s = 0.D0 if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do else do j = n + 1 , lp ( 2 ) i = abs ( ls ( j )) if ( i <= n ) then s = x ( i ) else s = aiscpr ( n , a , la , i - n , x , 0.D0 ) end if !         print 2,'s,bl(i),bu(i) =',s,bl(i),bu(i) if ( ls ( j ) > 0 ) then s =- s + bl ( i ) else s = s - bu ( i ) end if if ( abs ( s ) <= tol ) s = 0.D0 if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do end if if ( e > tol ) write ( nout , * ) 'inactive c/s residual error = ' , e , ie !     if (e>tol) stop if ( e > 1.D-6 ) print 2 , 'r(ie)' , r ( ie ) if ( e > 1.D-6 ) stop if ( lev == 1 ) then ff = 0.D0 do j = n + 1 , nm i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) ff = ff - r ( i ) end do e = abs ( ff - f ) if ( e > tol * max ( 1.D0 , abs ( f ))) write ( nout , * ) 'function error = ' , e , & '   f(x) =' , ff if ( e > tol * max ( 1.D0 , abs ( f ))) stop end if !       print 4,'g =',(g(i),i=1,n) !       print 4,'an =',(an(i),i=1,n) !       err=0.D0 !       do i=1,n !         err=err+abs(g(i)-an(i)) !       end do !       print 2,'check err =',err do i = 1 , n an ( i ) = 0.D0 end do do j = n + 1 , nm i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) then if ( i > n ) then call saipy ( - sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , an , n ) else an ( i ) = an ( i ) - sign ( 1.D0 , dble ( ls ( j ))) end if end if end do gnm = sqrt ( scpr ( 0.D0 , an , an , n )) e = 0.D0 do j = 1 , n !       write(nout,*)'an =',(an(i),i=1,n) i = abs ( ls ( j )) s = sign ( 1.D0 , dble ( ls ( j ))) if ( i <= n ) then an ( i ) = an ( i ) - s * r ( i ) if ( j > n - k ) then s = max ( 0.D0 , bl ( i ) - x ( i ), x ( i ) - bu ( i )) else if ( ls ( j ) > 0 ) then s = x ( i ) - bl ( i ) else s = bu ( i ) - x ( i ) end if else call saipy ( - s * r ( i ), a , la , i - n , an , n ) if ( ls ( j ) > 0 ) then s = aiscpr ( n , a , la , i - n , x , - bl ( i )) else s =- aiscpr ( n , a , la , i - n , x , - bu ( i )) end if end if if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do if ( e > tol ) write ( nout , * ) 'active c/s residual error = ' , e , ie !     if (e>tol) stop !     if (e>1.D-4) print 4,'x =',(x(i),i=1,n) if ( e > 1.D-4 ) stop e = 0.D0 do j = 1 , n if ( abs ( an ( j )) > e ) then e = abs ( an ( j )) ie = ls ( j ) je = j end if end do if ( e > gnm * tol ) write ( nout , * ) 'KT condition error = ' , e , je , ie , gnm !     if (e>gnm*tol) write(nout,4)'KT cond_n errors = ',(an(i),i=1,n) !     if (e>gnm*tol) stop if ( e > 1.D-4 ) stop 1 format ( A , 10 I5 ) 2 format ( A , 5E15 . 7 ) 4 format ( A / ( 5E15 . 6 )) return end","tags":"","loc":"sourcefile/l1sold.f90.html"},{"title":"filterSD.f90 – filterSD","text":"Contents Block Data Units nlp_defaults Subroutines filterSD filter_SD testfil addfil funct grad Source Code filterSD.f90 Source Code subroutine filterSD ( n , m , x , al , f , fmin , cstype , bl , bu , ws , lws , v , nv , & maxa , maxla , maxu , maxiu , kmax , maxg , rho , htol , rgtol , maxit , iprint , & nout , ifail ) implicit double precision ( a - h , o - z ) dimension x ( * ), al ( * ), bl ( * ), bu ( * ), ws ( * ), lws ( * ), v ( * ) character cstype ( * ) !  Copyright (C) 2010 Roger Fletcher !  Current version dated 5 October 2011 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT !  Solves an NLP problem of the form: find a local solution x to ! !          minimize    f(x) !                            [  x   ] !          subject to  bl <= [      ] <= bu !                            [ c(x) ] ! !  where f(x) is a given function of n variables x and c(x) is a vector of m !  given constraint functions. f(x) is minimized subject to lower and upper !  bounds bl and bu on x and c(x). f(x) and c(x) are defined by a user supplied !  subroutine 'functions'. The user is also required to supply a subroutine !  'gradients' which calculates gradients of f(x) and c(x) with respect to x. ! !  If linearized constraints and the trust region are incompatible, the code !  enters 'phase 1' in which an 'l1 feasibility problem' is solved. If this !  is unsuccessful in resolving the situation then the code exits with !  ifail=3 and returns a 'locally infeasible point' in x. ! !  Parameter List  (variables in a line starting with C must be set on entry) !  ============== !  n     number of variables !  m     number of general constraints !  x(n+m)  x(1:n) stores the vector of variables. Initially an estimate of the !            solution must be set, replaced by the solution (if it exists) !            on exit. The rest of x is workspace !  al(n+m) stores Lagrange multipliers at the solution on exit. A positive !            multiplier indicates that the lower bound is active, and a !            negative multiplier indicates that the upper bound is active. !            Inactive constraints have a zero multiplier. !  f     returns the value of f(x) when x is a feasible solution !  fmin  set a strict lower bound on f(x) for feasible x (used to identify !          an unbounded NLP) !  cstype(m) character workspace: if ifail=3, cstype indicates constraints !              that are infeasible in the L1 solution. cstype(i)='A' if the !              lower bound on c/s i is infeasible, 'Z' if the upper bound is !              infeasible, else 'N' if feasible. !  bl(n+m) lower bounds on x and c(x) (use numbers no less than -ainfty !            (see below) and where possible supply realistic bounds on x) !  bu(n+m) upper bounds on x and c(x) (use numbers no greater than ainfty) !  ws(*)   double precision workspace !  lws(*)  integer workspace !  v(maxg) stores nv Ritz values (estimates of eigenvalues of reduced Hessian) !            supply the setting from a previous run of filterSD, or set !            nv=1 and v(1)=1.D0 in absence of other information !  nv      number of values set in v !  maxa    maximum number of entries in the Jacobian a(*) set by gradients !  maxla   number of entries required for sparse matrix indices and pointers !            la(0:*) to be set up in lws(*) (maxla>=maxa+m+3). !            Set maxla=1 if using dense matrix format !  maxu    length of workspace user(*) passed through to user subroutines !            'functions' and 'gradients' !  maxiu   length of workspace iuser(*) passed through to user subroutines !  kmax    maximum dimension of null space allowed for (kmax<=n) !  maxg    maximum number of reduced gradient vectors stored by the !            limited memory method (typically 6 or 7) !  rho     initial trust region radius (typically 1.D1) !  htol    tolerance allowed in sum h of constraint feasibilities (e.g. 1.D-6) !  rgtol   tolerance allowed in reduced gradient l2 norm (typically 1.D-4) !  maxit   maximum number of major iterations allowed !  iprint  verbosity of printing (0=none, 1=one line per iteration, !            2=additional text information given) !  nout    output channel for printing !  ifail   returns failure indication as follows !              0 = successful run !              1 = unbounded NLP (f <= fmin at an htol-feasible point) !              2 = bounds on x are inconsistent !              3 = local minimum of feasibility problem and h > htol !                  (nonlinear constraints are locally inconsistent) !              4 = initial point x has h > ubd (reset ubd or x and re-enter) !              5 = maxit major iterations have been carried out !              6 = termination with rho <= htol !              7 = not enough workspace in ws or lws (see message) !              8 = insufficient space for filter (increase mxf and re-enter) !             >9 = unexpected fail in LCP solver (10 has been added to ifail) !  User Routines !  ============= !  The user must supply two subroutines to calculate f(x), c(x) and their !  first derivatives as follows ! !     subroutine functions(n,m,x,f,c,user,iuser) !     implicit double precision (a-h,o-z) !     dimension x(*),c(*),user(*),iuser(*) !     ... !     Statements to calculate f(x) and the m-vector c(x). The user is !     responsible for ensuring that any failures such as IEEE errors !     (overflow, NaN's etc.) are trapped and not returned to filterSD. !     The same holds for gradients. !     ... !     return !     end ! !     subroutine gradients(n,m,x,a,user,iuser) !     implicit double precision(a-h,o-z) !     dimension x(*),a(*),user(*),iuser(*) !     ... !     Statements to calculate gradients of f(x) and c(x) and set in a(*). !     The column vector grad(f) must be followed by the column vectors !     grad(c_i), i=1,2,...,m, in the one dimensional array a(*). Either a !     dense or sparse data structure may be used. If using the sparse data !     structure, only stucturally non-zero entries are set. Pointers etc. for !     the data structure are set once and for all in lws as described below. !     The user may assume that a call of 'gradients' immediately follows one !      of 'functions' with the same vector x.) !     ... !     return !     end ! !  The user must also supply a driver routine which calls filterSD. This must !  set parameters and common blocks of filterSD as appropriate. !  Space for x,al,bl,bu,ws,lws,v and cstype must be assigned. !  If using the sparse data structure for setting gradients, indices and !  pointers la(0:maxla-1) must be set in the driver in lws, immediately !  following any user workspace in lws(1:maxiu). No changes in this !  data structure are allowed during the operation of filterSD. !  More details of the format of a(*) and la(*) are given in the file sparseA.f !  For dense format just set maxla=1 and set lws(maxiu+1) to the !  'stride' (>=n) used in setting the columns of grad(f) and grad(c_i). !  For efficiency, constant entries in the gradients may be set in the driver. !  However two copies of the gradients are kept by filterSD . These reside in !  ws(maxu+1:maxu+maxa) and ws(maxu+maxa+1:maxu+2*maxa). Any constant entries !  must be set in both copies. !  Common blocks !  ============= !      common/wsc/kk,ll,kkk,lll,mxws,mxlws !  The user must specify the length of the workspace arrays ws(*) and lws(*) !  in mxws and mxlws respectively. It may not be easy to specify a-priori how !  large these arrays should be. Set a suitable large estimate, and filterSD !  will prompt if larger values are required. As a guide, ws(*) contains !  first user workspace, then workspace for filterSD, then workspace for glcpd, !  and finally workspace for denseL.f or schurQR.f. lws(*) contains user !  workspace, then maxla+n+m+mlp locations for filterSD and additional locations !  for denseL.f or schurQR.f. !     common/defaultc/ainfty,ubd,mlp,mxf !  Default values of some control parameters are set here. ainfty is used to !  represent infinity. ubd provides an upper bound on the allowed constraint !  violation. mlp is the maximum length of arrays used in degeneracy control. !  mxf is the maximum length of filter arrays. Default values are 1.D20, 1.D4, !  50,  50 respectively. !     common/ngrc/mxgr !  The user can limit the time spent in each call of the LCP solver by setting !  an upper limit on the number of gradient calls in mxgr (default=1000000) !     common/mxm1c/mxm1 !  When using denseL.f, mxm1 must be set to the maximum number of general !  constraints allowed in the active set. mxm1=min(m+1,n) is always sufficient !     common/epsc/eps,tol,emin !     common/repc/sgnf,nrep,npiv,nres !  These common blocks provide default parameters that control glcpd !     common/statsc/dnorm,h,hJt,hJ,ipeq,k,itn,nft,ngt !  This common block returns information about the outcome of filterSD. !  dnorm=final step length, h=final c/s violation, hJt=ditto for 'N' c/s, !  hJ=ditto for 'A' and 'Z' c/s, ipeq=number of active equations, k=number of !  free variables, itn=number of iterations, nft=total number of function !  calls, ngt=total number of gradient calls common / wsc / kk , ll , kkk , lll , mxws , mxlws common / defaultc / ainfty , ubd , mlp , mxf common / functc / fxd , alc , m_ , iph , last1 , next1 , nx , nx1 , & nal , nal1 , naal , naal1 , nxd , nxd1 , ncx , ncx1 , ncxd , ncxd1 , nla1 m_ = m nm = n + m !  set real storage map for ws !  first maxu locations are user storage for functions and gradients !  vectors required by funct: two slots of length maxa for a(*) last1 = maxu + 1 next1 = last1 + maxa !  slot of length n for x nx1 = next1 + maxa nx = nx1 - 1 !  slot of length m for lambda nal = nx + n nal1 = nal + 1 !  slot of length n for Ak.al, or for storing x naal = nal + m naal1 = naal + 1 !  slot of length n for x at x+d nxd = naal + n nxd1 = nxd + 1 !  slot of length m for c at x ncx = nxd + n ncx1 = ncx + 1 !  slot of length m for c at x+d ncxd = ncx + m ncxd1 = ncxd + 1 !  local storage for filter_SD !  slot of length n for d id1 = ncxd1 + m !  slot of length n+m for dl idl1 = id1 + n !  slot of length n+m for du idu1 = idl1 + nm !  slot of length n for g ig1 = idu1 + nm !  slot of length n+m for e ie1 = ig1 + n !  slot of length mlp for alp ialp1 = ie1 + nm !  slot of length mxf for filh ifilh1 = ialp1 + mlp !  slot of length mxf for filf ifilf1 = ifilh1 + mxf !  total length of ws so far kk = ifilf1 + mxf - 1 !  set integer storage map for lws !  first maxiu locations are user storage for functions and gradients !  storage of length maxla for la(0:*) nla1 = maxiu + 1 !  local storage for filter_SD !  slot of length n+m for ls ils1 = nla1 + maxla ils = ils1 - 1 !  slot of length mlp for lp ilp1 = ils1 + nm !  total length of lws so far ll = ilp1 + mlp - 1 do i = 1 , n if ( bl ( i ) > bu ( i )) then if ( iprint > 1 ) write ( nout , * ) 'simple bounds infeasible' ifail = 2 return end if ws ( nx + i ) = min ( max ( bl ( i ), x ( i )), bu ( i )) end do !  note x and al are just used as workspace: the true values are those in ws call filter_SD ( n , f , fmin , cstype , bl , bu , ws , lws , v , nv , & maxa , kmax , maxg , & ws ( id1 ), ws ( idl1 ), ws ( idu1 ), ws ( ig1 ), x , al , ws ( ie1 ), lws ( ils1 ), & ws ( ialp1 ), lws ( ilp1 ), ws ( ifilh1 ), ws ( ifilf1 ), rho , htol , rgtol , & maxit , iprint , nout , ifail ) if ( ifail >= 7 ) return !  scatter ws(nx.. and ws(nal.. and bound multipliers into x and al do i = 1 , n al ( i ) = 0.D0 end do do i = 1 , m al ( n + i ) = ws ( nal + i ) end do do j = 1 , n i = abs ( lws ( ils + j )) if ( i <= n ) then if ( ws ( nx + i ) == bl ( i )) then al ( i ) = x ( i ) else if ( ws ( nx + i ) == bu ( i )) then al ( i ) =- x ( i ) end if end if end do do i = 1 , n x ( i ) = ws ( nx + i ) end do return 1 format ( A , 15 I5 ) end subroutine filter_SD ( n , f , fmin , cstype , bl , bu , ws , lws , v , nv , & maxa , kmax , maxg , & d , dl , du , g , r , w , e , ls , alp , lp , filh , filf , rho , htol , rgtol , & maxit , iprint , nout , ifail ) implicit double precision ( a - h , o - z ) dimension bl ( * ), bu ( * ), ws ( * ), lws ( * ), v ( * ), & d ( * ), dl ( * ), du ( * ), g ( * ), r ( * ), w ( * ), e ( * ), ls ( * ), alp ( * ), lp ( * ), & filh ( * ), filf ( * ) character cstype ( * ) parameter ( sigma = 1.D-1 , infty = 100000000 ) common / defaultc / ainfty , ubd , mlp , mxf common / epsc / eps , tol , emin common / repc / sgnf , nrep , npiv , nres common / functc / fxd , alc , m , iph , last1 , next1 , nx , nx1 , & nal , nal1 , naal , naal1 , nxd , nxd1 , ncx , ncx1 , ncxd , ncxd1 , nla1 common / infoc / rgnorm , vstep , iter , npv , nfn , ngr common / ngrc / mxgr common / statsc / dnorm , h , hJt , hJ , ipeq , k , itn , nft , ngt 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) !   4 format(A/(6E13.5)) 4 format ( A / ( 5E15 . 7 )) 5 format (( 6E15 . 7 )) 6 format ( A , 2E15 . 7 , I2 ) 1000 format ( I4 , 1 X , E14 . 6 , E16 . 8 , '  < reset J          ' , 11 X , E12 . 4 ) 1001 format ( I4 , 1 X , E14 . 6 , E16 . 8 , '  < LCP' , E13 . 5 , 2E12 . 4 ) 1002 format ( I4 , 1 X , E14 . 6 , E16 . 8 , '  < project' ) 2000 format ( I4 , E14 . 6 , E16 . 8 , '  << feasible LP    ' , 13 X , E12 . 4 ) 2001 format ( I4 , E14 . 6 , E16 . 8 , '  << LCP' , E13 . 5 , 2E12 . 4 ) 2002 format ( I4 , E14 . 6 , E16 . 8 , '  << project' ) n1 = n + 1 nm = n + m mode = 0 nrep = 0 iph = 2 nfil = 0 itn = 0 nft = 0 ngt = 0 !  evaluate f,c and a call functions ( n , m , ws ( nx1 ), f , ws ( ncx1 ), ws , lws ) call gradients ( n , m , ws ( nx1 ), ws ( last1 ), ws , lws ) !  evaluate h h = 0.D0 do i = 1 , m ci = ws ( ncx + i ) h = h + max ( 0.D0 , bl ( n + i ) - ci , ci - bu ( n + i )) end do if ( h > ubd ) then if ( iprint > 1 ) write ( nout , 2 ) 'h>ubd: h =' , h ifail = 4 return end if if ( iprint >= 1 ) & write ( nout , * ) ' itn     h/hJt          f/hJ      ' , & '           rgnorm       dnorm        rho' 10 continue if ( rho < htol ) then if ( iprint > 1 ) write ( nout , 2 ) 'rho less than htol: rho =' , rho ifail = 6 return end if !     print 4,'x =',(ws(nx+i),i=1,n) !     print 4,'c =',(ws(ncx+i),i=1,m) !  set up LP subproblem do i = 1 , n dl ( i ) = max ( - rho , bl ( i ) - ws ( nx + i )) du ( i ) = min ( rho , bu ( i ) - ws ( nx + i )) d ( i ) = 0.D0 end do if ( abs ( iph ) == 1 ) then do j = 1 , n i = abs ( ls ( j )) - n if ( i > 0 ) then if ( cstype ( i ) == 'A' ) then ls ( j ) = n + i else if ( cstype ( i ) == 'Z' ) then ls ( j ) =- n - i end if end if end do end if do i = 1 , m ci = ws ( ncx + i ) dl ( n + i ) = bl ( n + i ) - ci du ( n + i ) = bu ( n + i ) - ci ws ( nal + i ) = 0.D0 cstype ( i ) = 'N' end do iph_ = iph iph = 0 k = 0 !     print *,'solve LP subproblem',itn iii = 0 !     if (itn==14)iii=1 call glcpd ( n , m , k , kmax , maxg , ws ( last1 ), lws ( nla1 ), d , dl , du , phi , & - ainfty , g , r , w , e , ls , alp , lp , mlp , ipeq , ws , lws , cstype , v , nv , rgtol , & mode , ifail , infty , iii , 0 ) !     print 4,'d =',(d(i),i=1,n) !     print 4,'r =',(r(i),i=1,nm) !     print 3,'ls =',(ls(i),i=1,nm) !     print 1,'ipeq,k,ifail',ipeq,k,ifail mode = 2 iph = iph_ if ( ifail == 0 . or . ifail == 4 ) then if ( iprint >= 1 ) write ( nout , 2000 ) itn , h , f , rho if ( abs ( iph ) == 1 ) nfil = nfil1 - 1 iph = 2 goto 50 else if ( ifail /= 3 ) then !       print 1,'itn =',itn if ( iprint > 1 ) write ( nout , * ) 'unexpected fail in LP subproblem' goto 99 end if 15 continue if ( h <= htol ) then if ( iprint > 1 ) write ( nout , * ) 'htol-feasible but LP is infeasible' ifail = 0 return end if !  infeasibility: enter feasibility restoration !     print *,'LP is infeasible: solve l1 subproblem',itn iii = 0 !     if (itn==9)iii=2 call l1sold ( n , m , k , kmax , maxg , ws ( last1 ), lws ( nla1 ), d , dl , du , phi , & g , r , w , e , ls , alp , lp , mlp , ipeq , ws , lws , cstype , v , nv , rgtol , ifail , iii , 0 ) !     print 4,'d1 =',(d(i),i=1,n) !     print 4,'r =',(r(i),i=1,nm) !     print 3,'ls =',(ls(i),i=1,nm) if ( ifail /= 0 ) then if ( print > 1 ) print * , 'unexpected fail in l1 subproblem' goto 99 end if if ( abs ( iph ) == 2 ) then call addfil ( h , f , filh , filf , 1 , nfil , mxf , ifail ) if ( ifail > 0 ) return nfil1 = nfil + 1 end if !  relax infeasible c/s hJ = 0.D0 hJt = 0.D0 do j = 1 , n i = abs ( ls ( j )) if ( i > n ) hJt = hJt + max ( 0.D0 , dl ( i ), - du ( i )) end do do j = n1 , nm i = abs ( ls ( j )) if ( i > n ) then if ( r ( i ) < 0.D0 ) then hJ = hJ + max ( 0.D0 , dl ( i ), - du ( i )) if ( ls ( j ) >= 0 ) then du ( i ) = dl ( i ) dl ( i ) =- ainfty cstype ( i - n ) = 'A' else dl ( i ) = du ( i ) du ( i ) = ainfty cstype ( i - n ) = 'Z' end if else hJt = hJt + max ( 0.D0 , dl ( i ), - du ( i )) end if end if end do !     print *,'phase 1 filter entries followed by (hJt,hJ)' !     do i=nfil1,nfil !       print 5,filh(i),filf(i) !     end do !     print 5,hJt,hJ !     print *,'cstype = ',(cstype(i),i=1,m) !     print 2,'hJt,hJ',hJt,hJ if ( iprint >= 1 ) write ( nout , 1000 ) itn , hJt , hJ , rho !     if (hJt>tol) then !       call addfil(hJt,hJ,filh,filf,nfil1,nfil,mxf,ifail) !       if (ifail>0) return call testfil ( hJt , hJ , filh , filf , nfil1 , nfil , ifail ) if ( ifail == 1 ) then if ( iprint > 1 ) write ( nout , * ) 'l1 solution not acceptable' dnorm = 0.D0 do i = 1 , n dnorm = max ( dnorm , abs ( d ( i ))) end do rho = 5.D-1 * dnorm goto 10 end if !     end if !  collect multipliers from l1 subproblem do j = 1 , n i = abs ( ls ( j )) if ( i > n ) then if ( ls ( j ) > 0 ) then ws ( nal + i - n ) = r ( i ) else ws ( nal + i - n ) =- r ( i ) end if end if ws ( naal + j ) = 0.D0 end do !     print 4,'al =',(ws(i),i=nal1,nal+m) do i = 1 , m call saipy ( ws ( nal + i ), ws ( last1 ), lws ( nla1 ), i , ws ( naal1 ), n ) end do 20 continue if ( itn == maxit ) then if ( iprint > 1 ) write ( nout , * ) 'itn>=maxit' ifail = 5 return end if iph = 1 !     mode=2 k = 0 !  solve LCP subproblem !     print 4,'x =',(ws(i),i=nx1,nx+n) !     print 4,'c =',(ws(i),i=ncx1,ncx+m) !     print 4,'al =',(ws(i),i=nal1,nal+m) do i = 1 , n dl ( i ) = max ( - rho , bl ( i ) - ws ( nx + i )) du ( i ) = min ( rho , bu ( i ) - ws ( nx + i )) d ( i ) = 0.D0 end do alc = scpr ( 0.D0 , ws ( nal1 ), ws ( ncx1 ), m ) !     print *,'solve phase 1 LCP subproblem',itn iii = 0 !     if (itn==11)iii=2 call glcpd ( n , m , k , kmax , maxg , ws ( last1 ), lws ( nla1 ), d , dl , du , phi , & fmin , g , r , w , e , ls , alp , lp , mlp , ipeq , ws , lws , cstype , v , nv , rgtol , & mode , ifail , mxgr , iii , 0 ) nft = nft + nfn ngt = ngt + ngr !     print 1,'nfn,ngr',nfn,ngr !     print 4,'d =',(d(i),i=1,n) !     print 4,'r =',(r(i),i=1,nm) !     print 3,'ls =',(ls(i),i=1,nm) !     print 1,'ipeq,k,ifail =',ipeq,k,ifail itn = itn + 1 dnorm = 0.D0 do i = 1 , n dnorm = max ( dnorm , abs ( d ( i ))) end do !     print 2,'dnorm,rho',dnorm,rho if ( ifail == 3 ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 1 LCP problem is infeasible' if ( dnorm <= htol ) goto 10 rho = 5.D-1 * dnorm goto 10 else if ( ifail == 1 ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 1 LCP subproblem is unbounded' goto 99 else if ( ifail > 5 ) then if ( iprint > 1 ) & write ( nout , * ) 'malfunction in phase 1 LCP subproblem' goto 99 end if hxdJt = 0.D0 hxdJ = 0.D0 do i = 1 , m ci = ws ( ncxd + i ) if ( cstype ( i ) == 'N' ) then hxdJt = hxdJt + max ( 0.D0 , bl ( n + i ) - ci , ci - bu ( n + i )) else hxdJ = hxdJ + max ( 0.D0 , bl ( n + i ) - ci , ci - bu ( n + i )) end if end do if ( iprint >= 1 ) write ( nout , 1001 ) itn , hxdJt , hxdJ , rgnorm , dnorm , rho !     print 4,'x+d =',(ws(nxd+i),i=1,n) !     print 4,'c at x+d =',(ws(ncxd+i),i=1,m) if ( hxdJt <= htol . and . dnorm <= htol ) goto 40 !     print *,'phase 1 filter entries followed by (hJt,hJ)' !     do i=nfil1,nfil !       print 5,filh(i),filf(i) !     end do !     print 5,hJt,hJ hxd = hxdJt + hxdJ if ( hxd >= ubd ) then if ( iprint > 1 ) write ( nout , * ) 'upper bound on h exceeded (1)' rho = max ( 1.D-1 , 5.D-1 * h / hxd ) * dnorm goto 10 end if dq = hJ - phi df = hJ - hxdJ !     print 2,'dq,df',dq,df !  filter test for LCP solution call testfil ( hxdJt , hxdJ , filh , filf , nfil1 , nfil , ifail ) if ( ifail == 0 ) call testfil ( hxdJt , hxdJ ,[ hJt ],[ hJ ], 1 , 1 , ifail ) !     print 6,'hxdJt,hxdJ,ifail',hxdJt,hxdJ,ifail if ( ifail == 1 . or . ( dq >= tol . and . df < sigma * dq )) then if ( hxdJt == 0.D0 . or . dq < tol ) then if ( iprint > 1 ) write ( nout , * ) 'hxdJt==0.D0 .or. dq<tol' rho = max ( 1.D-1 , min ( 5.D-1 * h / hxd , 5.D-1 )) * dnorm goto 10 end if !  projection step nv = 1 v ( 1 ) = 1.D0 iph =- 1 do i = 1 , n ws ( naal + i ) = ws ( nx + i ) end do 30 continue hxJt = hxdJt hxJ = hxdJ do i = 1 , n ws ( nx + i ) = ws ( nxd + i ) dl ( i ) = max ( - rho , bl ( i ) - ws ( nx + i )) du ( i ) = min ( rho , bu ( i ) - ws ( nx + i )) !         dl(i)=bl(i)-ws(nx+i) !         du(i)=bu(i)-ws(nx+i) d ( i ) = 0.D0 end do do i = 1 , m ci = ws ( ncxd + i ) if ( cstype ( i ) == 'A' ) then dl ( n + i ) =- ainfty du ( n + i ) = bl ( n + i ) - ci else if ( cstype ( i ) == 'Z' ) then dl ( n + i ) = bu ( n + i ) - ci du ( n + i ) = ainfty else dl ( n + i ) = bl ( n + i ) - ci du ( n + i ) = bu ( n + i ) - ci end if end do !       mode=2 k = 0 !  solve projection subproblem !       print *,'solve phase 1 projection subproblem',itn iii = 0 !       if (itn==68)iii=1 call glcpd ( n , m , k , kmax , maxg , ws ( next1 ), lws ( nla1 ), d , dl , du , phi , 0.D0 , & g , r , w , e , ls , alp , lp , mlp , ipeq , ws , lws , cstype , v , nv , rgtol , & mode , ifail , mxgr , iii , 0 ) !       print 4,'d =',(d(i),i=1,n) !       print 4,'r =',(r(i),i=1,nm) !       print 3,'ls =',(ls(i),i=1,nm) !       print 1,'ipeq,k,ifail =',ipeq,k,ifail if ( ifail == 3 ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 1 projection problem is infeasible' do i = 1 , n ws ( nx + i ) = ws ( naal + i ) end do rho = max ( 1.D-1 , min ( 5.D-1 * h / hxd , 5.D-1 )) * dnorm goto 10 else if ( ifail > 5 ) then if ( iprint > 1 ) & write ( nout , * ) 'malfunction in phase 1 projection subproblem' goto 99 end if do i = 1 , n ws ( nxd + i ) = ws ( nx + i ) + d ( i ) end do call functions ( n , m , ws ( nxd1 ), fxd , ws ( ncxd1 ), ws , lws ) call gradients ( n , m , ws ( nxd1 ), ws ( next1 ), ws , lws ) hxdJt = 0.D0 hxdJ = 0.D0 do i = 1 , m if ( cstype ( i ) == 'N' ) then hxdJt = hxdJt + max ( 0.D0 , bl ( n + i ) - ws ( ncxd + i ), ws ( ncxd + i ) - bu ( n + i )) else hxdJ = hxdJ + max ( 0.D0 , bl ( n + i ) - ws ( ncxd + i ), ws ( ncxd + i ) - bu ( n + i )) end if end do if ( iprint >= 1 ) write ( nout , 1002 ) itn , hxdJt , hxdJ !       print 4,'c at x+d =',(ws(ncxd+i),i=1,m) !  filter test for projection solution hxd = hxdJt + hxdJ if ( hxd >= ubd ) then if ( iprint > 1 ) write ( nout , * ) 'upper bound on h exceeded (2)' rho = max ( 1.D-1 , 5.D-1 * h / hxd ) * dnorm goto 10 end if df = hJ - hxdJ !       print 2,'dq,df',dq,df call testfil ( hxdJt , hxdJ , filh , filf , nfil1 , nfil , ifail ) if ( ifail == 0 ) call testfil ( hxdJt , hxdJ ,[ hJt ],[ hJ ], 1 , 1 , ifail ) !       if (ifail==1) print 2,'hxdJt/hxJt =',hxdJt/hxJt !       print 6,'project: hxdJt,hxdJ,ifail',hxdJt,hxdJ,ifail if ( ifail == 1 . or . df < sigma * dq ) then if ( hxdJt <= 8.D-1 * hxJt ) then df = hJ - ( hxJt * hxdJ - hxdJt * hxJ ) / ( hxJt - hxdJt ) if ( df >= sigma * dq ) goto 30 end if do i = 1 , n ws ( nx + i ) = ws ( naal + i ) end do rho = max ( 1.D-1 , min ( 5.D-1 * h / hxd , 5.D-1 )) * dnorm if ( iprint > 1 ) write ( nout , * ) 'phase 1 projection step fails' goto 10 end if !       print *,'accept projection step (1)' do i = 1 , n ws ( nx + i ) = ws ( naal + i ) end do end if 40 continue !  accept LCP (iph=1) or projection (iph=-1) solution if ( dq < tol ) then call addfil ( hJt , hJ , filh , filf , nfil1 , nfil , mxf , ifail ) if ( ifail > 0 ) return end if do i = 1 , n ws ( nx + i ) = ws ( nxd + i ) ws ( naal + i ) = 0.D0 end do do i = 1 , m ws ( ncx + i ) = ws ( ncxd + i ) end do call iexch ( last1 , next1 ) h = hxdJt + hxdJ f = fxd if ( dnorm == rho ) rho = 2.D0 * rho if ( h <= htol ) goto 10 !  check for situations where the l1 partition needs recalculating ... !  if there are any active relaxed c/s do j = 1 , n i = abs ( ls ( j )) - n !       if (i>0 .and. cstype(i)/='N') print 1,'active relaxed c/s',i if ( i > 0 . and . cstype ( i ) /= 'N' ) goto 10 end do !  or any infeasible relaxed c/s do i = 1 , m !       if ((cstype(i)=='A' .and. ws(ncx+i)>=bl(n+i)) .or. !    *    (cstype(i)=='Z' .and. ws(ncx+i)<=bu(n+i))) !    *    print 1,'infeasible relaxed c/s',i if (( cstype ( i ) == 'A' . and . ws ( ncx + i ) >= bl ( n + i )) . or . & ( cstype ( i ) == 'Z' . and . ws ( ncx + i ) <= bu ( n + i ))) goto 10 end do hJt = hxdJt hJ = hxdJ if ( iph ==- 1 ) goto 10 if ( hxdJt <= htol . and . dnorm <= htol ) then if ( iprint > 1 ) write ( nout , * ) 'locally infeasible problem' !       print 2,'hxdJt<=htol .and. dnorm<=htol' ifail = 3 return end if !  collect LCP multipliers do i = 1 , m ws ( nal + i ) = 0.D0 end do do j = 1 , n i = abs ( ls ( j )) if ( i > n ) then if ( ls ( j ) > 0 ) then ws ( nal + i - n ) = r ( i ) else ws ( nal + i - n ) =- r ( i ) end if end if end do !     print 4,'al =',(ws(i),i=nal1,nal+m) do i = 1 , m ci = ws ( ncx + i ) if ( cstype ( i ) == 'A' ) then dl ( n + i ) =- ainfty du ( n + i ) = bl ( n + i ) - ci else if ( cstype ( i ) == 'Z' ) then dl ( n + i ) = bu ( n + i ) - ci du ( n + i ) = ainfty else dl ( n + i ) = bl ( n + i ) - ci du ( n + i ) = bu ( n + i ) - ci end if call saipy ( ws ( nal + i ), ws ( last1 ), lws ( nla1 ), i , ws ( naal1 ), n ) end do goto 20 50 continue !  Phase 2 code !  collect multipliers from LP subproblem do j = 1 , n i = abs ( ls ( j )) if ( i > n ) then if ( ls ( j ) > 0 ) then ws ( nal + i - n ) = r ( i ) else ws ( nal + i - n ) =- r ( i ) end if end if ws ( naal + j ) = 0.D0 end do do i = 1 , m call saipy ( ws ( nal + i ), ws ( last1 ), lws ( nla1 ), i , ws ( naal1 ), n ) end do 60 continue if ( itn == maxit ) then if ( iprint > 1 ) write ( nout , * ) 'itn>=maxit' ifail = 5 return end if !     print 2,'h,f =',h,f iph = 2 k = 0 !     mode=2 !  solve LCP subproblem !     print 4,'x =',(ws(i),i=nx1,nx+n) !     print 4,'al =',(ws(i),i=nal1,nal+m) !     print 4,'c =',(ws(i),i=ncx1,ncx+m) do i = 1 , n dl ( i ) = max ( - rho , bl ( i ) - ws ( nx + i )) du ( i ) = min ( rho , bu ( i ) - ws ( nx + i )) d ( i ) = 0.D0 end do alc = scpr ( 0.D0 , ws ( nal1 ), ws ( ncx1 ), m ) !     print *,'solve phase 2 LCP subproblem',itn iii = 0 !     if (itn==164)iii=1 call glcpd ( n , m , k , kmax , maxg , ws ( last1 ), lws ( nla1 ), d , dl , du , phi , fmin , & g , r , w , e , ls , alp , lp , mlp , ipeq , ws , lws , cstype , v , nv , rgtol , & mode , ifail , mxgr , iii , 0 ) nft = nft + nfn ngt = ngt + ngr !     print 1,'nfn,ngr',nfn,ngr !     print 4,'d =',(d(i),i=1,n) !     print 4,'r =',(r(i),i=1,nm) !     print 3,'ls =',(ls(i),i=1,nm) !     print 1,'ipeq,k,ifail =',ipeq,k,ifail itn = itn + 1 dnorm = 0.D0 do i = 1 , n dnorm = max ( dnorm , abs ( d ( i ))) end do !     print 2,'dnorm,rho',dnorm,rho if ( ifail == 3 ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 2 LCP problem is infeasible' !       mode=2 goto 15 !       if (dnorm<=htol) goto 10 !       rho=5.D-1*dnorm !        goto 10 else if ( ifail == 1 ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 2 LCP subproblem is unbounded' goto 99 else if ( ifail > 5 ) then if ( iprint > 1 ) & write ( nout , * ) 'malfunction in phase 2 LCP subproblem' goto 99 end if hxd = 0.D0 do i = 1 , m ci = ws ( ncxd + i ) hxd = hxd + max ( 0.D0 , bl ( n + i ) - ci , ci - bu ( n + i )) end do if ( iprint >= 1 ) write ( nout , 2001 ) itn , hxd , fxd , rgnorm , dnorm , rho !     print 4,'c at x+d =',(ws(ncxd+i),i=1,m) if ( hxd <= htol . and . ( fxd <= fmin . or . dnorm <= htol )) goto 80 !     print *,'phase 2 filter entries followed by (h,f)' !     do i=1,nfil !       print 5,filh(i),filf(i) !     end do !     print 5,h,f !  filter test for LCP solution if ( hxd >= ubd ) then if ( iprint > 1 ) write ( nout , * ) 'upper bound on h exceeded (3)' rho = max ( 1.D-1 , 5.D-1 * h / hxd ) * dnorm goto 10 end if dq = f - phi df = f - fxd !     print 2,'dq,df',dq,df call testfil ( hxd , fxd , filh , filf , 1 , nfil , ifail ) if ( ifail == 0 ) call testfil ( hxd , fxd ,[ h ],[ f ], 1 , 1 , ifail ) !     print 6,'hxd,fxd,ifail',hxd,fxd,ifail if ( ifail == 1 . or . ( dq >= tol . and . df < sigma * dq )) then if ( hxd == 0.D0 . or . dq < tol ) then rho = 5.D-1 * dnorm if ( iprint > 1 ) write ( nout , * ) 'hxd==0.D0 .or. dq<tol' rho = max ( 1.D-1 , min ( 5.D-1 * h / hxd , 5.D-1 )) * dnorm goto 10 end if !  projection step nv = 1 v ( 1 ) = 1.D0 iph =- 2 do i = 1 , n ws ( naal + i ) = ws ( nx + i ) end do 70 continue hx = hxd fx = fxd do i = 1 , n ws ( nx + i ) = ws ( nxd + i ) dl ( i ) = max ( - rho , bl ( i ) - ws ( nx + i )) du ( i ) = min ( rho , bu ( i ) - ws ( nx + i )) !         dl(i)=bl(i)-ws(nx+i) !         du(i)=bu(i)-ws(nx+i) d ( i ) = 0.D0 end do do i = 1 , m ci = ws ( ncxd + i ) dl ( n + i ) = bl ( n + i ) - ci du ( n + i ) = bu ( n + i ) - ci end do !       mode=2 k = 0 !       print 4,'x =',(ws(nx+i),i=1,n) !       print 4,'v =',(v(i),i=1,nv) !  solve projection subproblem !       print *,'solve phase 2 projection subproblem' iii = 0 !       if (itn==9)iii=3 call glcpd ( n , m , k , kmax , maxg , ws ( next1 ), lws ( nla1 ), d , dl , du , phi , 0.D0 , & g , r , w , e , ls , alp , lp , mlp , ipeq , ws , lws , cstype , v , nv , rgtol , & mode , ifail , mxgr , iii , 0 ) !       print 4,'d =',(d(i),i=1,n) !       print 4,'r =',(r(i),i=1,nm) !       print 3,'ls =',(ls(i),i=1,nm) !       print 1,'ipeq,k,ifail =',ipeq,k,ifail if ( ifail == 3 ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 2 projection problem is infeasible' do i = 1 , n ws ( nx + i ) = ws ( naal + i ) end do rho = 5.D-1 * dnorm goto 10 else if ( ifail > 5 ) then if ( iprint > 1 ) & write ( nout , * ) 'malfunction in phase 2 projection subproblem' goto 99 end if do i = 1 , n ws ( nxd + i ) = ws ( nx + i ) + d ( i ) end do !       print 4,'xd =',(ws(nxd+i),i=1,n) call functions ( n , m , ws ( nxd1 ), fxd , ws ( ncxd1 ), ws , lws ) call gradients ( n , m , ws ( nxd1 ), ws ( next1 ), ws , lws ) hxd = 0.D0 do i = 1 , m ci = ws ( ncxd + i ) hxd = hxd + max ( 0.D0 , bl ( n + i ) - ci , ci - bu ( n + i )) end do if ( iprint >= 1 ) write ( nout , 2002 ) itn , hxd , fxd !       print 4,'x+d =',(ws(nxd+i),i=1,n) !       print 4,'c at x+d =',(ws(ncxd+i),i=1,m) !  filter test for projection solution if ( hxd >= ubd ) then if ( iprint > 1 ) write ( nout , * ) 'upper bound on h exceeded (4)' rho = max ( 1.D-1 , 5.D-1 * h / hxd ) * dnorm goto 10 end if df = f - fxd call testfil ( hxd , fxd , filh , filf , 1 , nfil , ifail ) if ( ifail == 0 ) call testfil ( hxd , fxd ,[ h ],[ f ], 1 , 1 , ifail ) !       if (ifail==1) print 2,'hxd/hx =',hxd/hx !       print 6,'hxd,fxd,ifail',hxd,fxd,ifail if ( ifail == 1 . or . df < sigma * dq ) then if ( hxd <= 8.D-1 * hx ) then df = f - ( hx * fxd - hxd * fx ) / ( hx - hxd ) if ( df >= sigma * dq ) goto 70 end if do i = 1 , n ws ( nx + i ) = ws ( naal + i ) end do rho = 5.D-1 * dnorm if ( iprint > 1 ) write ( nout , * ) 'phase 2 projection step fails' goto 10 end if !       print *,'accept phase 2 projection step' do i = 1 , n ws ( nx + i ) = ws ( naal + i ) end do end if 80 continue !  accept LCP (iph=2) or projection (iph=-2) solution if ( dq < tol ) then call addfil ( h , f , filh , filf , 1 , nfil , mxf , ifail ) if ( ifail > 0 ) return end if h = hxd f = fxd if ( dnorm == rho ) rho = 2.D0 * rho do i = 1 , n ws ( nx + i ) = ws ( nxd + i ) ws ( naal + i ) = 0.D0 end do do i = 1 , m ws ( ncx + i ) = ws ( ncxd + i ) end do call iexch ( last1 , next1 ) if ( iph ==- 2 ) goto 10 if ( h <= htol ) then if ( f <= fmin ) then if ( iprint > 1 ) & write ( nout , * ) 'phase 2 LCP unbounded' ifail = 1 return else if ( dnorm <= htol ) then if ( iprint > 1 ) write ( nout , * ) 'local NLP solution found' !         print 2,'h<=htol .and. dnorm<=htol' ifail = 0 return end if end if !  collect LCP multipliers do i = 1 , m ws ( nal + i ) = 0.D0 end do do j = 1 , n i = abs ( ls ( j )) if ( i > n ) then if ( ls ( j ) > 0 ) then ws ( nal + i - n ) = r ( i ) else ws ( nal + i - n ) =- r ( i ) end if end if end do !     print 4,'al =',(ws(i),i=nal1,nal+m) do i = 1 , m ci = ws ( ncx + i ) dl ( n + i ) = bl ( n + i ) - ci du ( n + i ) = bu ( n + i ) - ci call saipy ( ws ( nal + i ), ws ( last1 ), lws ( nla1 ), i , ws ( naal1 ), n ) end do !     iph=2 goto 60 99 continue if ( ifail == 7 ) return ifail = ifail + 10 return end block data nlp_defaults implicit double precision ( a - h , o - z ) common / defaultc / ainfty , ubd , mlp , mxf common / ngrc / mxgr data ainfty , ubd , mlp , mxf , mxgr & / 1.D20 , 1.D4 , 50 , 50 , 1000000 / end subroutine testfil ( h , f , filh , filf , nfil1 , nfil , ifail ) implicit double precision ( a - h , o - z ) dimension filh ( * ), filf ( * ) parameter ( beta = 9999 9.D-5 , gamma = 1.D-5 ) ifail = 0 !     if (h==0.D0) return hd = h / beta fp = f + gamma * h do i = nfil1 , nfil if ( hd >= filh ( i ) . and . fp > filf ( i )) then !       if (hd>filh(i) .and. fp>filf(i)) then ifail = 1 return end if end do return end subroutine addfil ( h , f , filh , filf , nfil1 , nfil , mxf , ifail ) implicit double precision ( a - h , o - z ) dimension filh ( * ), filf ( * ) do i = nfil , nfil1 , - 1 if ( h <= filh ( i ) . and . f <= filf ( i )) then filh ( i ) = filh ( nfil ) filf ( i ) = filf ( nfil ) nfil = nfil - 1 end if end do if ( nfil >= mxf ) then ifail = 8 return end if nfil = nfil + 1 filh ( nfil ) = h filf ( nfil ) = f ifail = 0 return end subroutine funct ( n , d , phi , ws , lws , cstype ) implicit double precision ( a - h , o - z ) dimension d ( * ), ws ( * ), lws ( * ) character cstype ( * ) common / defaultc / ainfty , ubd , mlp , mxf common / functc / fxd , alc , m , iph , last1 , next1 , nx , nx1 , & nal , nal1 , naal , naal1 , nxd , nxd1 , ncx , ncx1 , ncxd , ncxd1 , nla1 2 format ( A , 6E15 . 7 ) 4 format ( A / ( 5E15 . 7 )) if ( iph < 0 ) then !  projection subproblem phi = 5.D-1 * scpr ( 0.D0 , d , d , n ) return else if ( iph == 0 ) then !  LP subproblem phi = aiscpr ( n , ws ( last1 ), lws ( nla1 ), 0 , d , 0.D0 ) return end if do i = 1 , n ws ( nxd + i ) = ws ( nx + i ) + d ( i ) end do !     print 4,'$x =',(ws(nx+i),i=1,n) !     print 4,'$d =',(d(i),i=1,n) !     print 4,'$x+d =',(ws(nxd+i),i=1,n) call functions ( n , m , ws ( nxd1 ), fxd , ws ( ncxd1 ), ws , lws ) !     print 2,'$fxd =',fxd !     print 4,'$al =',(ws(nal+i),i=1,m) !     print 4,'$A.al =',(ws(naal+i),i=1,n) !     print 4,'$cxd =',(ws(ncxd+i),i=1,m) !     print *,'$cstype =',(cstype(i),i=1,m) if ( iph == 2 ) then phi = scpr ( - scpr ( - fxd - alc , ws ( nal1 ), ws ( ncxd1 ), m ), ws ( naal1 ), d , n ) else phi = scpr ( - scpr ( - alc , ws ( nal1 ), ws ( ncxd1 ), m ), ws ( naal1 ), d , n ) do i = 1 , m if ( cstype ( i ) == 'A' ) then phi = phi - ws ( ncxd + i ) else if ( cstype ( i ) == 'Z' ) then phi = phi + ws ( ncxd + i ) end if end do end if !     print 2,'$fxd,cxd,phi =',fxd,ws(ncxd1),phi !     print 2,'$phi =',phi return end subroutine grad ( n , d , g , ws , lws , cstype ) implicit double precision ( a - h , o - z ) dimension d ( * ), g ( * ), ws ( * ), lws ( * ) character cstype ( * ) common / defaultc / ainfty , ubd , mlp , mxf common / functc / fxd , alc , m , iph , last1 , next1 , nx , nx1 , & nal , nal1 , naal , naal1 , nxd , nxd1 , ncx , ncx1 , ncxd , ncxd1 , nla1 common / maxac / maxa if ( iph < 0 ) then do i = 1 , n g ( i ) = d ( i ) end do return else if ( iph == 0 ) then do i = 1 , n g ( i ) = 0.D0 end do call saipy ( 1.D0 , ws ( last1 ), lws ( nla1 ), 0 , g , n ) return end if !     print 4,'£x+d =',(ws(nxd+i),i=1,n) call gradients ( n , m , ws ( nxd1 ), ws ( next1 ), ws , lws ) !     print 4,'£a =',(ws(next1+i),i=0,maxa-1) !     print 4,'£al =',(ws(nal+i),i=1,m) do i = 1 , n g ( i ) = ws ( naal + i ) end do !     print 4,'£Ak.al =',(g(i),i=1,n) do i = 1 , m call saipy ( - ws ( nal + i ), ws ( next1 ), lws ( nla1 ), i , g , n ) end do if ( iph == 2 ) then call saipy ( 1.D0 , ws ( next1 ), lws ( nla1 ), 0 , g , n ) else do i = 1 , m if ( cstype ( i ) == 'A' ) then call saipy ( - 1.D0 , ws ( next1 ), lws ( nla1 ), i , g , n ) else if ( cstype ( i ) == 'Z' ) then call saipy ( 1.D0 , ws ( next1 ), lws ( nla1 ), i , g , n ) end if end do end if !     print 4,'£g =',(g(i),i=1,n) 1 format ( A , 15 I5 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) return end","tags":"","loc":"sourcefile/filtersd.f90.html"},{"title":"checkd.f90 – filterSD","text":"Contents Subroutines checkd Source Code checkd.f90 Source Code !Christen this file checkd.f !  Copyright (C) 2010 Roger Fletcher !  Current version 20 January 2011 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT subroutine checkd ( n , m , x , al , ws , lws , maxa , maxla , maxu , maxiu , & mxws , mxlws , tol ) implicit double precision ( a - h , o - z ) !  first derivative checking subroutine for use with filterSD code !  Parameters !  ********** !  n    set number of variables !  m    set number of constraints !  x    set any vector of variables in x(i), i=1,n !  al   set a vector of differencing increments in al(i), i=1,n !        (al(i) is the difference interval for x(i) and must be nonzero, !        say 0.01 times the typical magnitude of x(i)) !  ws   double precision workspace (the amount required for filterSD.f should !       be plenty) !  lws  integer workspace (use the amount required for filterSD.f) !  maxa set as maxa parameter for filterSD !  maxla set as maxla parameter for filterSD !  maxu  set as maxu parameter for filterSD !  maxiu  set as maxiu parameter for filterSD !  mxws  set the length of ws as provided in the driver !  mxlws  set the length of lws as provided in the driver !  tol  tolerace (>0) for reporting inconsistencies in derivatives (eg 1.D-12) !  Usage !  ***** !  The user must write subroutines 'functions' and 'gradients' as for filterSD !  Write a driver program for your problem,  but replace the call of filterSD !  by a call of checkd (having set differencing increments in al). !    The program will report any inconsistencies in the derivatives. !  If the difference quotient estimate lies between the derivatives !  at x and x+h (h is the perturbation stored in in al) then the !  derivative is assumed to be correct. Small errors in this !  comparison may be ignored. If no errors are reported then the !  call of filter.. may be restored. dimension x ( * ), al ( * ), ws ( * ), lws ( * ) print * , 'entering checkd' m1 = m + 1 !  set real storage map for ws !  first maxu locations are user storage for functions and gradients !  vectors required by checkd: two slots of length maxa for a(*) last1 = maxu + 1 next1 = last1 + maxa !  slot of length m+1 for f,c at x ncx0 = next1 + maxa ncx1 = ncx0 + 1 !  slot of length m+1 for f,c at x + h.e_i ncxd0 = ncx0 + m1 ncxd1 = ncxd0 + 1 !  total length of ws used is kk = ncxd0 + m if ( kk > mxws ) then print 1 , 'ws not large enough: kk, mxws =' , kk , mxws stop end if !  set integer storage map for lws !  first maxiu locations are user storage for functions and gradients !  storage of length maxla for la(0:*) nla1 = maxiu + 1 !  total storage needed is ll = nla1 + maxla - 1 if ( ll > mxlws ) then print 1 , 'lws not large enough: ll, mxlws =' , ll , mxlws stop end if call functions ( n , m , x , ws ( ncx0 ), ws ( ncx1 ), ws , lws ) call gradients ( n , m , x , ws ( last1 ), ws , lws ) !     print 4,'ws_0',(ws(j),j=last1,last1+7) do i = 1 , n xi = x ( i ) x ( i ) = x ( i ) + al ( i ) call functions ( n , m , x , ws ( ncxd0 ), ws ( ncxd1 ), ws , lws ) call gradients ( n , m , x , ws ( next1 ), ws , lws ) do 10 j = 0 , m dfi = ( ws ( ncxd0 + j ) - ws ( ncx0 + j )) / al ( i ) a_ij = aij ( i , j , ws ( last1 ), lws ( nla1 )) ah_ij = aij ( i , j , ws ( next1 ), lws ( nla1 )) if (( dfi >= a_ij - tol . and . dfi <= ah_ij + tol ) . or . & ( dfi >= ah_ij - tol . and . dfi <= a_ij + tol )) goto 10 print 1 , 'derivative inconsistency in constraint/variable' , j , i print * , 'deriv at x, diff quotient, deriv at x+h =' , & a_ij , dfi , ah_ij print * , 'c at x+h, c at x' , ws ( ncxd0 + j ), ws ( ncx0 + j ) !         print 1,'la(0) =',la(0) !         print 1,'c/s j pointer =',la(la(0)+j) !         print 3,'c/s j indices',(la(k),k=la(la(0)+j),la(la(0)+j+1)-1) !         print 4,'c/s j entries',(a(k),k=la(la(0)+j),la(la(0)+j+1)-1) return 10 continue x ( i ) = xi end do print * , 'exiting checkd' 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 20 I4 )) 4 format ( A / ( 6E15 . 7 )) return end","tags":"","loc":"sourcefile/checkd.f90.html"},{"title":"util.f90 – filterSD","text":"Contents Functions scpr xlen Subroutines rsol rtsol Qprod Qtprod brots frots angle rot mysaxpy saxpys saxpyx saxpyz saxpyi linf r_shift ishift rexch vexch iexch Source Code util.f90 Source Code !Christen this file util.f !  Copyright (C) 1996 Roger Fletcher !  Current version dated 26 May 2011 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT !*********************** dense matrix utilities ************************ subroutine rsol ( n , nn , nmax , R , b ) implicit double precision ( a - h , o - z ) dimension R ( * ), b ( * ) !  solves Rx=b where R is nxn upper triangular. Solution overwrites b. !  R is a single suffix array: the first nmax elements contain the first row !  of R in positions 1:n, the next nmax-1 elements contain the second row of R, !  and so on. nn indexes the element R(n,n) (where nn=n*(3-n)/2+(n-1)*nmax) n1 = nmax + 1 ii = nn b ( n ) = b ( n ) / R ( nn ) do i = n - 1 , 1 , - 1 ii = ii - n1 + i b ( i ) =- scpr ( - b ( i ), R ( ii + 1 ), b ( i + 1 ), n - i ) / R ( ii ) end do return end subroutine rtsol ( n , nn , nmax , R , b ) implicit double precision ( a - h , o - z ) dimension R ( * ), b ( * ) !  solves Rt.x=b with same conventions as above !  nn is not required on entry but is set on exit n2 = nmax + 2 nn = 1 b ( 1 ) = b ( 1 ) / R ( 1 ) do i = 2 , n i1 = i - 1 call mysaxpy ( - b ( i1 ), R ( nn + 1 ), b ( i ), n - i1 ) nn = nn + n2 - i b ( i ) = b ( i ) / R ( nn ) end do return end subroutine Qprod ( n , nmax , Q , x , b ) implicit double precision ( a - h , o - z ) dimension Q ( * ), x ( * ), b ( * ) !  forms b=M.x where Q is nxn, stored by columns, with stride nmax do i = 1 , n b ( i ) = 0.D0 end do i1 = 1 do i = 1 , n call mysaxpy ( x ( i ), Q ( i1 ), b , n ) i1 = i1 + nmax end do return end subroutine Qtprod ( n , nmax , Q , x , b ) implicit double precision ( a - h , o - z ) dimension Q ( * ), x ( * ), b ( * ) !  forms b=M'.x where Q is nxn, stored by columns, with stride nmax i1 = 1 do i = 1 , n b ( i ) = scpr ( 0.D0 , Q ( i1 ), x , n ) i1 = i1 + nmax end do return end subroutine brots ( n , nmax , k , kk , R , v ) implicit double precision ( a - h , o - z ) dimension R ( * ), v ( * ) ipip = kk do i = k - 1 , 1 , - 1 ip = i + 1 ipi = ipip - nmax + i ii = ipi - 1 call angle ( v ( i ), v ( ip ), cos , sin ) call rot ( n - i , R ( ipi ), R ( ipip ), cos , sin ) v ( ip ) = sin * R ( ii ) R ( ii ) = cos * R ( ii ) ipip = ii end do return end subroutine frots ( nr , nc , nmax , R , v ) implicit double precision ( a - h , o - z ) dimension R ( * ), v ( * ) ! nr is either nc or nc+1 ii = 1 do i = 1 , nc ip = i + 1 ipi = ii + 1 ipip = ipi + nmax - i call angle ( R ( ii ), v ( ip ), cos , sin ) call rot ( nr - i , R ( ipi ), R ( ipip ), cos , sin ) ii = ipip end do return end subroutine angle ( a , b , cos , sin ) implicit double precision ( a - h , o - z ) z = sqrt ( a ** 2 + b ** 2 ) if ( z == 0.D0 ) then cos = 1.D0 sin = 0.D0 return end if cos = a / z sin = b / z a = z b = 0.D0 return end subroutine rot ( n , a , b , cos , sin ) implicit double precision ( a - h , o - z ) dimension a ( * ), b ( * ) if ( sin == 0.D0 ) then if ( cos > 0.D0 ) then do i = 1 , n b ( i ) =- b ( i ) end do else do i = 1 , n a ( i ) =- a ( i ) end do end if else if ( cos == 0.D0 ) then if ( sin >= 0.D0 ) then do i = 1 , n z = a ( i ) a ( i ) = b ( i ) b ( i ) = z end do else do i = 1 , n z = a ( i ) a ( i ) =- b ( i ) b ( i ) =- z end do end if else do i = 1 , n z = a ( i ) a ( i ) = cos * z + sin * b ( i ) b ( i ) = sin * z - cos * b ( i ) end do end if return end subroutine mysaxpy ( a , x , y , n ) implicit double precision ( a - h , o - z ) dimension x ( * ), y ( * ) if ( a == 0.D0 ) return do i = 1 , n y ( i ) = y ( i ) + a * x ( i ) end do return end subroutine saxpys ( a , x , is , y , n ) implicit double precision ( a - h , o - z ) !  saxpy with stride dimension x ( * ), y ( * ) if ( a == 0.D0 ) return ix = 1 do i = 1 , n y ( i ) = y ( i ) + a * x ( ix ) ix = ix + is end do return end subroutine saxpyx ( a , x , y , n ) implicit double precision ( a - h , o - z ) !  saxpy with result in x dimension x ( * ), y ( * ) if ( a == 0.D0 ) then do i = 1 , n x ( i ) = y ( i ) end do else do i = 1 , n x ( i ) = y ( i ) + a * x ( i ) end do end if return end subroutine saxpyz ( a , x , y , z , n ) implicit double precision ( a - h , o - z ) !  saxpy with result in z dimension x ( * ), y ( * ), z ( * ) if ( a == 0.D0 ) then do i = 1 , n z ( i ) = y ( i ) end do else do i = 1 , n z ( i ) = y ( i ) + a * x ( i ) end do end if return end subroutine saxpyi ( a , x , y , n ) implicit double precision ( a - h , o - z ) !  saxpy with interchange of x and y dimension x ( * ), y ( * ) if ( a == 0.D0 ) then do i = 1 , n call rexch ( x ( i ), y ( i )) end do else do i = 1 , n z = y ( i ) y ( i ) = x ( i ) + a * y ( i ) x ( i ) = z end do end if return end function scpr ( a , x , y , n ) implicit double precision ( a - h , o - z ) dimension x ( * ), y ( * ) scpr = a do i = 1 , n scpr = scpr + x ( i ) * y ( i ) end do return end !     function xlen(a,x,n) !     implicit double precision (a-h,o-z) !     dimension x(*) !  finds the l_2 length of [a:x] where a is either 0.D0 or 1.D0 !  if overflow occurs the function is calculated in a less efficient way. !  Users who cannot trap overflow should either use this method of calculation, !  or use the alternative routine \"xlen\" below which is not quite so well !  protected against overflow. !     external  ieee_handler, abort !     integer   ieee_flags, ieeer, ieee_handler !     external  ieee_flags !     character out*16 !     out = '' !     ieeer = ieee_flags ( 'clearall','all','',out ) !     ieeer=ieee_handler('clear','overflow',abort) !  this call of ieee_handler assumes that !         ieeer=ieee_handler('set','overflow',abort) !  has been set in the driver. If not this call of ieee_handler and that below !  should be removed !     xlen=a !     do i=1,n !       xlen=xlen+x(i)**2 !     end do !     xlen=sqrt(xlen) !     ieeer=ieee_flags ( 'get','exception','',out ) !     if (out=='overflow') then !       call linf(n,x,xmx,i) !       xmx=max(xmx,1.D0) %this is needed if normalization is always used !       xlen=(a/xmx)**2 !       do i=1,n !         xlen=xlen+(x(i)/xmx)**2 !       end do !       xlen=xmx*sqrt(xlen) !       ieeer=ieee_flags ( 'clear','overflow','',out ) !     end if !     ieeer=ieee_handler('set','overflow',abort) !     return !     end function xlen ( a , x , n ) implicit double precision ( a - h , o - z ) dimension x ( * ) xlen = a do i = 1 , n xlen = xlen + x ( i ) ** 2 end do xlen = sqrt ( xlen ) return end subroutine linf ( n , x , z , iz ) implicit double precision ( a - h , o - z ) dimension x ( * ) z = 0.D0 do i = 1 , n a = abs ( x ( i )) if ( a > z ) then z = a iz = i end if end do return end subroutine r_shift ( r , n , k ) implicit double precision ( a - h , o - z ) dimension r ( * ) if ( k > 0 ) then do i = 1 , n r ( i ) = r ( i + k ) end do else if ( k < 0 ) then do i = n , 1 , - 1 r ( i ) = r ( i + k ) end do end if return end subroutine ishift ( l , n , k ) implicit double precision ( a - h , o - z ) dimension l ( * ) if ( k > 0 ) then do i = 1 , n l ( i ) = l ( i + k ) end do else if ( k < 0 ) then do i = n , 1 , - 1 l ( i ) = l ( i + k ) end do end if return end subroutine rexch ( a , b ) double precision a , b , z z = a a = b b = z return end subroutine vexch ( a , b , n ) double precision a , b , z dimension a ( * ), b ( * ) do i = 1 , n z = a ( i ) a ( i ) = b ( i ) b ( i ) = z end do return end subroutine iexch ( i , j ) k = i i = j j = k return end","tags":"","loc":"sourcefile/util.f90.html"},{"title":"checkg.f90 – filterSD","text":"Contents Subroutines checkg Source Code checkg.f90 Source Code subroutine checkg ( n , x , h , a , b , user , iuser , cuser , tol ) implicit double precision ( a - h , o - z ) dimension x ( * ), h ( * ), a ( * ), b ( * ), user ( * ), iuser ( * ) character cuser ( * ) !  Copyright (C) 2010 Roger Fletcher !  Current version 11 January 2011 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT !  gradient checking subroutine for use with the glcpd code !  Parameters !  ********** !  n    set the number of variables !  x(n) set any vector of variables in x(i), i=1,n !  h(n) set a vector of differencing increments in h(i), i=1,n !        (h(i) is the difference interval for x(i) and must be nonzero, !        say 0.01 times the typical magnitude of x(i)) !  a(n)  double precision real workspce !  b(n)  double precision real workspce !  user(*)  double precision real user storage, passed through to funct and grad !  iuser(*) integer user storage, passed through to funct and grad !  cuser(*) character user storage, passed through to funct and grad !  tol  tolerace (>0) for reporting inconsistencies in derivatives (eg 1.D-12) !  Usage !  ***** !  The user must write subroutines 'funct' and 'grad' as for glcpd !  Write a driver program for your problem,  but replace the call of glcpd !  by a call of checkg (having set differencing increments in h). !     The program will report any inconsistencies in the gradients. !  If the difference quotient estimate lies between the gradient component !  at x and x+[0,...,0,h(i),0,...,0]' then the derivative is assumed to be !  correct. Small errors in this comparison may be ignored. If no errors are !  reported then the call of glcpd may be restored. print * , 'entering checkg' call funct ( n , x , fx , user , iuser , cuser ) call grad ( n , x , a , user , iuser , cuser ) do i = 1 , n xi = x ( i ) x ( i ) = x ( i ) + h ( i ) call funct ( n , x , fxh , user , iuser , cuser ) call grad ( n , x , b , user , iuser , cuser ) dfi = ( fxh - fx ) / h ( i ) if (( dfi >= a ( i ) - tol . and . dfi . le . b ( i ) + tol ) . or . & ( dfi >= b ( i ) - tol . and . dfi . le . a ( i ) + tol )) goto 10 print 1 , 'derivative inconsistency in variable' , i print 2 , 'deriv at x, diff quotient, deriv at x+h =' , & a ( i ), dfi , b ( i ) stop 10 continue x ( i ) = xi end do print * , 'exiting checkg' 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 4 format ( A / ( 6E15 . 7 )) return end","tags":"","loc":"sourcefile/checkg.f90.html"},{"title":"schurQR.f90 – filterSD","text":"Contents Functions aiscpri2 Subroutines start_up refactor pivot fbsub ztg tfbsub newg check_L aqsol aqsol0 eptsol eptsol0 order factor re_order re_factor updateSE updateQR newslot erase trim_ EBspace checkperms checkout Source Code schurQR.f90 Source Code !Christen this file schurQR.f !ut here >>>>>>>>>>>>>>>>>>> !  Copyright  (C) 2011 Roger Fletcher !  Current version dated 17 January 2012 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT !***************** sparse matrix routines for manipulating L ******************* !        ********************************************************** !        Basis matrix routines for LCP solvers with sparse matrices !        ********************************************************** !  These routines form and update L-Implicit-U factors LPB=U of a matrix B !  whose columns are the normal vectors of the active constraints. In this !  method only the unit lower triangular matrix L and the diagonal of U (in !  addition to the row permutation P) is stored. B is represented in block form !    | I  A_2 |    where the last m1 columns (A_2 and A_1) come from the !    | 0  A_1 |    general constraint normals (columns of the matrix A in bqpd) !  and the remaining unit columns come from simple bounds. The matrix A must be !  specified in sparse format and the user is referred to the file  sparseA.f. !  The data structure used for L is that of a profile or skyline scheme, in !  which the nontrivial rows of L are stored as dense row spikes. The use of !  a Tarjan+spk1 ordering algorithm to control the length of these spikes has !  proved quite effective. !  In schurQR.f, the factors are updated by the Schur complement method with !  QR factors. This is based on the block factorization ! !            | B  V | = | L  0 | | U  V | !            | E  0 |   | S  I | | 0  C | ! !  where V are columns of the constraint normals [I A] that have been added to !  the active set, and E has unit rows in which the unit element marks !  columns of B that have been removed from B. C=-E.inv(B).V is the !  Schur complement matrix, which is independent of how L and U are defined, !  and its QR factors are stored. The current dimension of C is stored in the !  parameter ms of   common/refactorc/mc,mxmc   and the user must set a !  maximum permitted value of mc in mxmc (mxmc <= n). The current basis matrix !  is refactored if mc would exceed mxmc, or if issues of numerical stability !  arise. Typically mxmc=25 is suitable. !  Workspace !  ********* !  The user needs to supply storage for the row spikes in the LIU data !  structure of L, Also storage for matrices in the Schur complement scheme !  is required. The amount of storage required is unknown a-priori. !  Storage for schurQR.f is situated at the end of the workspace arrays ws !  and lws in bqpd. Allow as much space for ws as you can afford: the routine !  will report if there is not enough. So far 10&#94;6 locations has proved !  adequate for problems of up to 5000 variables. !  The user is also allowed to reserve storage in ws and lws, for use in the !  user-supplied routine gdotx. This storage is situated at the start of the !  arrays ws and lws. The user specifies the amount required by !  setting the parameters kk and ll in the common block !     common/wsc/kk,ll,kkk,lll,mxws,mxlws !  Storage required by the LCP solver is also required: the amount is set by !  the LCP solver in kkk and lll. The user MUST set mxws and mxlws to be !  the total amount of real and integer workspace for the arrays ws and lws. !  Other information !  ***************** !  The methodology behind the L-Implicit-U factors and the row spike storage !  scheme for L is described in the references !    Fletcher R., Dense Factors of Sparse Matrices, in \"Approximation Theory !    and Optimization. Tributes to M.J.D. Powell\", (M.D. Buhmann and A. Iserles, !    eds), Cambridge University Press (1997), pp. 145-166. !  and !    Fletcher R., Block Triangular Orderings and Factors for Sparse Matrices !    in LP, in \"Numerical analysis 1997\" (D.F. Griffiths, D.J. Higham and !    G.A. Watson, eds.), Pitman Research Notes in Mathematics 380, (1998), !    Longman, Harlow, pp. 91-110. !  The file contains routines for solving systems with B or its transpose !  which might be of use in association with bqpd. These routines are !  documented below. !  Steepest edge coefficients e(i) are also updated in these routines subroutine start_up ( n , nm , nmi , a , la , nk , e , ls , aa , ll , mode , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( 0 : * ), e ( * ), ls ( * ), aa ( * ), ll ( * ) common / noutc / nout common / wsc / kk , ll_ , kkk , lll , mxws , mxlws common / epsc / eps , tol , emin common / schurc / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , neb , neb1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 , & nq , nq1 , nr , nr1 , ny , ny1 , nz , nz1 , lv , lv1 , le , le1 common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / mc , mxmc mxmc = min ( n , mxmc ) !  set storage map for sparse factors ns = n ns1 = ns + 1 nt = ns + n nt1 = nt + 1 nu = nt + n nu1 = nu + 1 nx = nu + n nx1 = nx + 1 nq = nx + n nq1 = nq + 1 nr = nq + mxmc ** 2 nr1 = nr + 1 ny = nr + mxmc * ( mxmc + 1 ) / 2 ny1 = ny + 1 nz = ny + mxmc + 1 nz1 = nz + 1 np = nz + mxmc + 1 np1 = np + 1 nprof = mxws - kk - kkk - np !     print *,'nprof =',nprof if ( nprof <= 0 ) then write ( nout , * ) 'not enough real workspace in ws' write ( nout , * ) 'you give mxws as' , mxws write ( nout , * ) 'mxws must be much greater than' , mxws - nprof ifail = 7 return end if lc = n lc1 = lc + 1 li = lc + n li1 = li + 1 lm = li + nmi lm1 = lm + 1 lp = lm + n lp1 = lp + 1 lq = lp + n lq1 = lq + 1 lr = lq + n lr1 = lr + 1 ls_ = lr + n ls1 = ls_ + 1 lt = ls_ + n lt1 = lt + 1 lv = lt + n lv1 = lv + 1 le = lv + mxmc + 1 le1 = le + 1 lleft = mxlws - ll_ - lll - le - mxmc - 1 if ( lleft < 0 ) then write ( nout , * ) 'not enough integer workspace in lws' write ( nout , * ) 'you give mxlws as' , mxlws write ( nout , * ) 'minimum value for mxlws is' , mxlws - lleft ifail = 7 return end if m = nm - n mp =- 1 mq =- 1 !     write(nout,*)'ls',(ls(ij),ij=1,nk) if ( mode == 3 ) then if ( nk < n ) then !  reset ls from e do j = 1 , nk i =- ls ( j ) if ( i > 0 ) e ( i ) =- e ( i ) end do j = 0 nk = nmi do i = 1 , nmi if ( e ( i ) /= 0.D0 ) then j = j + 1 if ( e ( i ) > 0.D0 ) then ls ( j ) = i else ls ( j ) =- i e ( i ) =- e ( i ) end if else ls ( nk ) = i nk = nk - 1 end if end do if ( j /= n ) then write ( nout , * ) 'malfunction in reset sequence in start_up' stop end if end if !  reset lr, lc, li, m1 and m2 from ls do i = li + n + 1 , li + nm ll ( i ) = 0 end do m1 = n m2 = 0 do j = 1 , n i = abs ( ls ( j )) if ( i > n ) then ll ( lc + m1 ) = i ll ( li + i ) = m1 m1 = m1 - 1 else m2 = m2 + 1 lii = ll ( li + i ) lrm2 = ll ( m2 ) call iexch ( ll ( lii ), ll ( m2 )) call iexch ( ll ( li + i ), ll ( li + lrm2 )) end if end do m1 = n - m1 call re_order ( n , nm , a , la ( 1 ), la ( la ( 0 )), ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , ifail ) if ( ifail >= 1 ) then !         write(nout,*)'failure in re_order (1)' if ( ifail == 7 ) return mode = 2 goto 1 end if call re_factor ( n , nm , a , la , ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , aa , ifail ) if ( ifail == 7 ) return call check_L ( n , aa , ll ( lp1 ), ifail ) if ( ifail == 1 ) then mode = 2 goto 1 end if call EBspace ( n , ll ( lp1 ), ll ( lq1 ), ll ( ls1 ), ll , aa ( np1 ), & neb , nprof , ifail ) if ( ifail > 0 ) return neb = np + neb neb1 = neb + 1 mc = 0 do i = 1 , m2 ll ( lm + i ) = ll ( i ) end do do i = m2 + 1 , n ll ( lm + i ) = ll ( lc + i ) end do return end if 1 continue if ( emin == 0.D0 ) then !  set a lower bound on e(i): setting emin=0.D0 will force emin to be recalculated: do this only if mode<3 emin = 1.D0 do i = 1 , nmi - n emin = max ( emin , ailen ( n , a , la , i )) end do emin = 1.D0 / emin end if do i = 1 , n ll ( i ) = i ll ( li + i ) = i e ( i ) = 1.D0 end do do i = n + 1 , nm ll ( li + i ) = 0 e ( i ) = 0.D0 end do nu_ = 0 if ( mode /= 0 ) then !  shift designated bounds to end and order the resulting rows and columns do j = 1 , nk i = abs ( ls ( j )) if ( i <= n ) then nn = n - nu_ nu_ = nu_ + 1 call iexch ( ls ( nu_ ), ls ( j )) ii = ll ( li + i ) ll ( ii ) = ll ( nn ) ll ( li + ll ( ii )) = ii ll ( nn ) = i ll ( li + i ) = nn end if end do call order ( n , nu_ , nk , la , ll , ls , ll ( li1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), & aa ( np1 ), nprof , ifail ) if ( ifail > 0 ) return end if call factor ( n , nm , nu_ , nk , a , la , e , ls , aa ( ns1 ), aa ( nt1 ), aa ( nu1 ), & aa ( nx1 ), ll , ll ( lc1 ), ll ( li1 ), ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), & ll ( ls1 ), aa ( np1 ), nprof , aa , ifail ) call EBspace ( n , ll ( lp1 ), ll ( lq1 ), ll ( ls1 ), ll , aa ( np1 ), & neb , nprof , ifail ) if ( ifail > 0 ) return neb = np + neb neb1 = neb + 1 mc = 0 do i = 1 , m2 ll ( lm + i ) = ll ( i ) end do do i = m2 + 1 , n ll ( lm + i ) = ll ( lc + i ) end do if ( ifail > 0 ) return 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) !     write(nout,*)'steepest edge coefficients',(e(ij),ij=1,nm) !     emax=0.D0 !     do i=1,nm !       if (e(i)>0.D0) then !         call eptsol(n,a,la,i,a,aa(nq1),aa(nr1),aa(neb1),aa(ny1), !    *    aa(ns1),aa(nu1),aa(nx1),aa,aa(np1), !    *    ll,ll(lc1),ll(li1),ll(lv1),ll(le1),ll(lp1),ll(lq1),ei) !         emax=max(emax,abs(ei-e(i))) !       end if !     end do !     if (emax>=tol) !    *  write(nout,*)'error in steepest edge coefficients =',emax return end subroutine refactor ( n , nm , a , la , aa , ll , ifail ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), aa ( * ), ll ( * ) common / schurc / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , neb , neb1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 , & nq , nq1 , nr , nr1 , ny , ny1 , nz , nz1 , lv , lv1 , le , le1 common / factorc / m1 , m2 , mp , mq , lastr , irow common / noutc / nout !     write(nout,*)'refactor' ifail = 1 return end subroutine pivot ( p , q , n , nm , a , la , e , aa , ll , ifail , npv ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( 0 : * ), e ( * ), aa ( * ), ll ( * ) common / noutc / nout common / iprintc / iprint common / schurc / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , neb , neb1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 , & nq , nq1 , nr , nr1 , ny , ny1 , nz , nz1 , lv , lv1 , le , le1 common / factorc / m1 , m2 , mp , mq , lastr , irow common / mxm1c / mxm1 common / refactorc / mc , mxmc common / epsc / eps , tol , emin common / pqc / pc , qr , lmp !     write(nout,*)'pivot: p,q =',p,q call updateSE ( p , q , n , nm , a , la , e , aa ( nq1 ), aa ( nr1 ), aa ( neb1 ), & aa ( ny1 ), aa ( nz1 ), aa ( ns1 ), aa ( nt1 ), aa ( nu1 ), aa ( nx1 ), aa , aa ( np1 ), ll , & ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 ), ll ( lm1 ), ll ( lv1 ), ll ( le1 ), ifail ) if ( ifail == 1 ) return if ( mc == mxmc . and . pc == 0 . and . qr == 0 ) then !  reset permutations and refactorize L mc1 = mc + 1 ll ( le + mc1 ) = p ll ( lv + mc1 ) = q !       print 3,'le =',(ll(le+i),i=1,mc1) !       print 3,'lv =',(ll(lv+i),i=1,mc1) do i = 1 , mc1 p = ll ( le + i ) q = ll ( lv + i ) ip = ll ( li + p ) if ( p > n ) then m2 = m2 + 1 qq = ll ( lc + m2 ) ll ( lc + ip ) = qq ll ( li + qq ) = ip ll ( li + p ) = 0 else ll ( ip ) = ll ( m2 ) ll ( li + ll ( ip )) = ip ll ( m2 ) = p ll ( li + p ) = m2 end if if ( q > n ) then ll ( lc + m2 ) = q ll ( li + q ) = m2 m2 = m2 - 1 else iq = ll ( li + q ) ll ( iq ) = ll ( m2 ) ll ( li + ll ( iq )) = iq ll ( m2 ) = q ll ( li + q ) = m2 end if end do !       print 3,'lr =',(ll(i),i=1,n) !       print 3,'lc =',(ll(lc+i),i=m2+1,n) !       print 3,'li =',(ll(li+i),i=1,nm) m1 = n - m2 !       call checkperms(n,ll,ll(lc1),ll(li1)) !       mp=-1 !       mq=-1 call re_order ( n , nm , a , la ( 1 ), la ( la ( 0 )), ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , ifail ) if ( ifail >= 1 ) then !         print *,'no traversal in re_order (3)' ifail = 11 return stop end if call re_factor ( n , nm , a , la , ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , aa , ifail ) if ( ifail == 7 ) return call EBspace ( n , ll ( lp1 ), ll ( lq1 ), ll ( ls1 ), ll , aa ( np1 ), & neb , nprof , ifail ) if ( ifail > 0 ) return neb = np + neb neb1 = neb + 1 mc = 0 do i = 1 , m2 ll ( lm + i ) = ll ( i ) end do do i = m2 + 1 , n ll ( lm + i ) = ll ( lc + i ) end do else call updateQR ( p , q , n , a , la , aa ( nq1 ), aa ( nr1 ), aa ( neb1 ), aa ( nx1 ), & aa ( ny1 ), aa ( nz1 ), ll , ll ( lc1 ), ll ( li1 ), ll ( lv1 ), ll ( le1 ), ll ( lm1 ), & ifail ) if ( ifail > 0 ) return end if npv = npv + 1 mp =- 1 mq =- 1 !     call check_L(n,aa,ll(lp1),ifail) !     print 4,'e =',(e(i),i=1,nm) !     print 3,'lm =',(ll(lm+i),i=1,n) return !  check Steepest Edge coefficients emax = 0.D0 do j = 1 , n i = ll ( lm + j ) call eptsol ( n , a , la , i , a , aa ( nq1 ), aa ( nr1 ), aa ( neb1 ), aa ( ny1 ), & aa ( ns1 ), aa ( nu1 ), aa ( nx1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lv1 ), ll ( le1 ), ll ( lp1 ), ll ( lq1 ), ei ) emax = max ( emax , abs ( ei - e ( i ))) !       if (abs(ei-e(i))>tol) then !         print *,'error in steepest edge coefficient =',i,ei,e(i) !         print 4,'s =',(aa(ns+i),i=1,n) !         if (abs(ei-e(i))>1.D-6) stop !       end if end do if ( emax > tol ) then print 2 , 'max error in steepest edge coefficients =' , emax !       if (emax>1.D-2) stop end if return 2 format ( A , 5E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) 5 format (( 5E15 . 7 )) end subroutine fbsub ( n , jmin , jmax , a , la , q , b , x , ls , aa , ll , save ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical save 9 format ( A / ( 15 I5 )) dimension a ( * ), la ( * ), b ( * ), x ( * ), ls ( * ), aa ( * ), ll ( * ) !  solves a system  B.x=b !  Parameter list !  ************** !   n   number of variables (as for bqpd) !   jmin,jmax  now redundant !   a,la   specification of QP problem data (as for bqpd) !   q   an integer which, if in the range 1:n+m, specifies that the rhs vector !       b is to be column q of the matrix A of general constraint normals. !       In this case the parameter b is not referenced by fbsub. !       If q=0 then b is taken as the vector given in the parameter b. !   b(n)  must be set to the r.h.s. vector b in natural order (but only if q=0) !   x(n+m)  contains the solution x, set according to the index number of that !           component (in the range 1:n for a simple bound and  n+1:n+m !           for a general constraint) !   ls(*)  now redundant. Previously ls was an index vector, listing the !       components of x that are required. Now all the solution x is provided, !       set as described above. !   aa(*)  real storage used by the basis matrix code (supply the vector !       ws(lu1) with ws as in the call of bqpd and lu1 as in common/bqpdc/...) !   ll(*)  integer storage used by the basis matrix code (supply the vector !       lws(ll1) with lws as in the call of bqpd and ll1 as in common/bqpdc/...) !   save   now redundant common / noutc / nout common / schurc / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , neb , neb1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 , & nq , nq1 , nr , nr1 , ny , ny1 , nz , nz1 , lv , lv1 , le , le1 common / factorc / m1 , m2 , mp , mq , lastr , irow !     write(nout,*)'fbsub  q =',q if ( q == 0 ) then do i = 1 , n aa ( nt + ll ( li + i )) = b ( i ) end do end if call aqsol ( n , a , la , q , aa ( nq1 ), aa ( nr1 ), aa ( neb1 ), aa ( nz1 ), aa ( nt1 ), & aa ( nu1 ), aa ( nx1 ), aa , aa ( np1 ), ll , ll ( lc1 ), ll ( li1 ), ll ( lv1 ), & ll ( le1 ), ll ( lp1 ), ll ( lq1 )) do j = 1 , n x ( ll ( lm + j )) = aa ( nt + j ) end do !     print *,'x =',(x(i),i=1,18) return end subroutine ztg ( n , k , rg , lv , aa , ll ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension rg ( * ), lv ( * ), aa ( * ), ll ( * ) common / schurc / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , neb , neb1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 , & nq , nq1 , nr , nr1 , ny , ny1 , nz , nz1 , lv_ , lv1 , le , le1 !     print *,'aa =',(aa(nu+i),i=1,18) do j = 1 , k rg ( j ) = aa ( nu + ll ( li + lv ( j ))) end do return end subroutine tfbsub ( n , a , la , p , b , x , aa , ll , ep , save ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical save dimension a ( * ), la ( * ), b ( * ), x ( * ), aa ( * ), ll ( * ) !  solves a system  Bt.x=b !  Parameter list !  ************** !   n   number of variables (as for bqpd) !   a,la   specification of QP problem data (as for bqpd) !   p    an integer which, if in the range 1:n+m, specifies that the rhs vector !        b is a unit vector appropriate to the position of p in the current !        ordering. In this case b is not referenced by tfbsub. !   b(n+m)  If p=0, this must be set to the r.h.s. vector b. Only the components !        of b need be set, according to the index number of each component (in !        the range 1:n for a simple bound and n+1:n+m for a general constraint) !   x(n)  contains the solution x (in natural ordering) !   aa(*)  real storage used by the basis matrix code (supply the vector !       ws(lu1) with ws as in the call of bqpd and lu1 as in common/bqpdc/...) !   ll(*)  integer storage used by the basis matrix code (supply the vector !       lws(ll1) with lws as in the call of bqpd and ll1 as in common/bqpdc/...) !   ep  if p>0, ep contains the L2 norm of the solution !   save  now redundant common / noutc / nout common / schurc / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , neb , neb1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 , & nq , nq1 , nr , nr1 , ny , ny1 , nz , nz1 , lv , lv1 , le , le1 common / factorc / m1 , m2 , mp , mq , lastr , irow !     write(nout,*)'tfbsub  p =',p call eptsol ( n , a , la , p , b , aa ( nq1 ), aa ( nr1 ), aa ( neb1 ), aa ( ny1 ), & aa ( ns1 ), aa ( nu1 ), aa ( nx1 ), aa , aa ( np1 ), ll , ll ( lc1 ), ll ( li1 ), & ll ( lv1 ), ll ( le1 ), ll ( lp1 ), ll ( lq1 ), ep ) do i = 1 , n x ( ll ( i )) = aa ( ns + i ) end do !     print 4,'x =',(x(i),i=1,n) 4 format ( A / ( 5E15 . 7 )) return end subroutine newg common / factorc / m1 , m2 , mp , mq , lastr , irow mq =- 1 return end !******** The following routines are internal to schurQR.f ************** subroutine check_L ( n , d , p , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension d ( * ), p ( * ) common / noutc / nout common / factorc / m1 , nu , mp , mq , lastr , irow common / epsc / eps , tol , emin write ( nout , * ) 'check_L' ifail = 1 dmin = 1.D37 do k = nu + 1 , n dmin = min ( dmin , abs ( d ( k ))) !       if (abs(d(k))<=tol) return end do write ( nout , * ) 'dmin =' , dmin !     len=0 !     do i=1,n !       len=len+p(i) !     end do !     write(nout,*)m1*(m1+1)/2,len+m1 !     write(nout,*)'m1 =',m1,'   file length =',len,'   total =',len+m1 ifail = 0 return end subroutine aqsol ( n , a , la , q , Q_ , R , EB , z , t , u , x , d , ws , & lr , lc , li , lv , le , pp , qq ) implicit double precision ( a - h , r - z ), integer ( i - q ) double precision Q_ dimension a ( * ), la ( * ), Q_ ( * ), R ( * ), EB ( * ), z ( * ), t ( * ), u ( * ), x ( * ), & d ( * ), ws ( * ), lr ( * ), lc ( * ), li ( * ), lv ( * ), le ( * ), pp ( * ), qq ( * ) common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / mc , mxmc common / pqc / pc , qr , lmp !     print *,'aqsol  q =',q if ( q > 0 ) then !       print *,'q,n,li(q),m2',q,n,li(q),m2 if ( q <= n . and . li ( q ) <= m2 . or . q > n . and . li ( q ) > 0 ) then !  q is in the starting active set (and hence in row qr of E) do qr = 1 , mc if ( q == le ( qr )) goto 10 end do print * , 'malfunction: q not in E' stop 10 continue else !  q is a new column qr = 0 end if !  form t=Bk&#94;{-1}.aq, else form t=Bk&#94;{-1}.t !  scatter a_q into t liq = li ( q ) do i = 1 , n t ( i ) = 0.D0 end do if ( q <= n ) then t ( liq ) = 1.D0 else call iscatter ( a , la , q - n , li , t , n ) end if end if !     print 4,'t=',(t(i),i=1,n) if ( mc > 0 ) then !  form u=E.B&#94;{-1}.t and possibly z=-u if ( q == 0 . or . q > n . and . qr == 0 ) then i1 = 1 do i = 1 , mc !           print 4,'EB =',(EB(j),j=i1,i1+m1-1) u ( i ) = scpr ( 0.D0 , EB ( i1 ), t ( m2 + 1 ), m1 ) if ( le ( i ) <= n ) u ( i ) = u ( i ) + t ( li ( le ( i ))) z ( i ) =- u ( i ) i1 = i1 + m1 end do else if ( qr > 0 ) then do i = 1 , mc u ( i ) = 0.D0 end do u ( qr ) = 1.D0 else !         print 4,'EB =',(EB(j),j=1,m1*mc) liq = liq - m2 do i = 1 , mc u ( i ) = EB ( liq ) z ( i ) =- u ( i ) liq = liq + m1 end do end if !       print 4,'u=',(u(i),i=1,mc) !  form x=C&#94;{-1}.u call Qtprod ( mc , mxmc , Q_ , u , x ) mm = mc * ( 3 - mc ) / 2 + ( mc - 1 ) * mxmc call rsol ( mc , mm , mxmc , R , x ) !       print 4,'x=',(x(i),i=1,mc) !  accumulate t=t+V.x do i = 1 , mc lvi = lv ( i ) if ( lvi <= n ) then t ( li ( lvi )) = t ( li ( lvi )) + x ( i ) else call isaipy ( x ( i ), a , la , lvi - n , t , n , lr , li ) end if end do end if !     print 4,'t in natural order =',(t(li(i)),i=1,n) !  finally t:=B&#94;{-1}.t-E'.x call aqsol0 ( n , a , la , 0 , t , u , d , ws , lr , lc , li , pp , qq ) do i = 1 , mc lei = li ( le ( i )) t ( lei ) = t ( lei ) - x ( i ) end do !     print 4,'t in column order',(t(i),i=1,n) mq = q return 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) end subroutine aqsol0 ( n , a , la , q , tn , xn , d , ws , lr , lc , li , pp , qq ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), tn ( * ), xn ( * ), d ( * ), ws ( * ), & lr ( * ), lc ( * ), li ( * ), pp ( * ), qq ( * ) common / factorc / m1 , m2 , mp , mq , lastr , irow if ( q > 0 ) then do i = 1 , n tn ( i ) = 0.D0 end do if ( q <= n ) then tn ( li ( q )) = 1.D0 else call iscatter ( a , la , q - n , li , tn , n ) end if end if !     print *,'tn =',(tn(i),i=1,n) do i = n , m2 + 1 , - 1 ir = lr ( i ) pri = pp ( ir ) if ( pri == 0 ) then xn ( i ) = tn ( i ) / d ( i ) else xn ( i ) = ( scpr ( tn ( i ), ws ( qq ( ir ) + 1 ), tn ( i - pri ), pri )) / d ( i ) end if call isaipy ( - xn ( i ), a , la , lc ( i ) - n , tn , n , lr , li ) end do do i = m2 + 1 , n tn ( i ) = xn ( i ) end do !     print *,'tn =',(tn(i),i=1,n) return end subroutine eptsol ( n , a , la , p , b , Q_ , R , EB , y , s , u , x , d , ws , & lr , lc , li , lv , le , pp , qq , ep ) implicit double precision ( a - h , r - z ), integer ( i - q ) double precision Q_ dimension a ( * ), la ( * ), b ( * ), Q_ ( * ), R ( * ), EB ( * ), y ( * ), s ( * ), u ( * ), x ( * ), & d ( * ), ws ( * ), lr ( * ), lc ( * ), li ( * ), lv ( * ), le ( * ), pp ( * ), qq ( * ) common / epsc / eps , tol , emin common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / mc , mxmc common / pqc / pc , qr , lmp !     print *,'eptsol  p =',p !  column ordering is that defined by Bk = B + (V-B.E').E !  row order is same as for B if ( p == 0 ) then !       print 3,'lr =',(lr(i),i=1,m2) !       print 3,'lc =',(lc(i),i=m2+1,n) !       print 3,'le =',(le(i),i=1,mc) !       print 3,'lv =',(lv(i),i=1,mc) do i = 1 , mc x ( i ) = b ( le ( i )) b ( le ( i )) = 0.D0 end do call eptsol0 ( n , a , la , 0 , b , s , d , ws , lr , lc , li , pp , qq ) do i = 1 , mc b ( le ( i )) = x ( i ) if ( lv ( i ) <= n ) then x ( i ) = s ( li ( lv ( i ))) - b ( lv ( i )) else x ( i ) = aiscpri ( n , a , la , lv ( i ) - n , s , - b ( lv ( i )), lr , li ) end if end do else if ( p <= n . and . li ( p ) <= m2 . or . p > n . and . li ( p ) > 0 ) then !  p is in the starting active set (set pc=0) pc = 0 lmp = li ( p ) else !  p is in V  (pc indicates where p is in V) do pc = 1 , mc if ( p == lv ( pc )) goto 10 end do print 1 , 'p,pc,li(p),m1,m2 =' , p , pc , li ( p ), m1 , m2 print 3 , 'le =' ,( le ( i ), i = 1 , mc ) print 3 , 'lv =' ,( lv ( i ), i = 1 , mc ) print * , 'malfunction: p not in V' stop 10 continue lmp = li ( le ( pc )) end if !  get s=Bk&#94;{-T}.ep if ( pc == 0 ) then call eptsol0 ( n , a , la , p , a , s , d , ws , lr , lc , li , pp , qq ) !       print 4,'s0 ordered by lr',(s(i),i=1,n) !       print 4,'s0 in natural order',(s(li(i)),i=1,n) m1mc = m1 * mc do i = 1 , m1 EB ( m1mc + i ) = s ( m2 + i ) end do !         print 1,'eptsol: p =',p !         print 4,'EB is',(s(i),i=m2+1,n) !         print 4,'EB is',(EB(i),i=1,m1mc+m1) !  form s=B&#94;{-T}.ep and then y=-V'.s do i = 1 , mc if ( lv ( i ) <= n ) then x ( i ) = s ( li ( lv ( i ))) else x ( i ) = aiscpri ( n , a , la , lv ( i ) - n , s , 0.D0 , lr , li ) end if y ( i ) =- x ( i ) end do else !  this is pc>0: set s=0 and x=-e_pc do i = 1 , n s ( i ) = 0.D0 end do do i = 1 , mc x ( i ) = 0.D0 end do x ( pc ) =- 1.D0 end if end if !     print 4,'x =',(x(i),i=1,mc) if ( mc > 0 ) then !  form u=C&#94;{-T}.x and accumulate EB'.u into s call rtsol ( mc , mm , mxmc , R , x ) call Qprod ( mc , mxmc , Q_ , x , u ) i1 = 1 do i = 1 , mc call mysaxpy ( u ( i ), EB ( i1 ), s ( m2 + 1 ), m1 ) if ( le ( i ) <= n ) s ( li ( le ( i ))) = u ( i ) i1 = i1 + m1 end do end if !     print 4,'sk in natural order=',(s(li(i)),i=1,n) !     print 4,'s =',(s(i),i=1,n) mp = p if ( p > 0 ) ep = xlen ( 0.D0 , s , n ) return 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) end subroutine eptsol0 ( n , a , la , p , b , sn , d , ws , lr , lc , li , pp , qq ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), b ( * ), sn ( * ), d ( * ), ws ( * ), & lr ( * ), lc ( * ), li ( * ), pp ( * ), qq ( * ) common / epsc / eps , tol , emin common / factorc / m1 , m2 , mp , mq , lastr , irow if ( p == 0 ) then do i = 1 , m2 sn ( i ) = b ( lr ( i )) end do do i = m2 + 1 , n sn ( i ) = 0.D0 end do do i = m2 + 1 , n j = lc ( i ) sn ( i ) =- aiscpri ( n , a , la , j - n , sn , - b ( j ), lr , li ) / d ( i ) ir = lr ( i ) pri = pp ( ir ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( qq ( ir ) + 1 ), sn ( i - pri ), pri ) end do else do i = 1 , n sn ( i ) = 0.D0 end do pr = li ( p ) if ( p <= n ) then if ( pr > m2 ) goto 1 sn ( pr ) = 1.D0 do i = m2 + 1 , n sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , 0.D0 , lr , li ) / d ( i ) ir = lr ( i ) pri = pp ( ir ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( qq ( ir ) + 1 ), sn ( i - pri ), pri ) end do else if ( pr <= m2 ) goto 1 do i = m2 + 1 , n bi = 0.D0 if ( i == pr ) bi =- 1.D0 sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , bi , lr , li ) / d ( i ) ir = lr ( i ) pri = pp ( ir ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( qq ( ir ) + 1 ), sn ( i - pri ), pri ) end do end if end if !     print *,'sn =',(sn(i),i=1,n) return 1 continue print * , 'malfunction detected in eptsol0: p =' , p stop end subroutine order ( n , nu , nc , la , lr , ls , li , p , q , r , ws , mxws , ifail ) implicit integer ( c - t ) double precision ws dimension la ( 0 : * ), lr ( * ), ls ( * ), li ( * ), p ( * ), q ( * ), r ( * ), ws ( * ) common / noutc / nout !     character star(1000,80) !     write(nout,*)'order' !  spk1 ordering on full matrix ifail = 0 if ( nu == n ) return !  set row and column counts and row-wise data structure nn = n - nu ii = mxws / nn do j = 1 , nn rowj = lr ( j ) p ( rowj ) = ( j - 1 ) * ii r ( rowj ) = 0 end do do j = nn + 1 , n r ( lr ( j )) = 0 end do 1 continue do i = nu + 1 , nc coli = abs ( ls ( i )) li ( coli ) = 0 jp = la ( 0 ) + coli - n do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) if ( li ( rowj ) <= nn ) then li ( coli ) = li ( coli ) + 1 r ( rowj ) = r ( rowj ) + 1 ij = p ( rowj ) + r ( rowj ) if ( ij > mxws ) then ij = mxws ifail = 1 end if ws ( ij ) = dble ( coli ) end if end do end do !  check for no overlaps qrj = 0 do j = 1 , nn rowj = lr ( j ) if ( p ( rowj ) < qrj ) ifail = 1 qrj = p ( rowj ) + r ( rowj ) q ( rowj ) = qrj p ( rowj ) = p ( rowj ) + 1 end do if ( ifail == 1 . or . qrj > mxws ) then qrj = 0 do j = 1 , nn rowj = lr ( j ) p ( rowj ) = qrj qrj = qrj + r ( rowj ) r ( rowj ) = 0 end do if ( qrj > mxws ) then write ( nout , * ) 'not enough space for ws in order:  mxws =' , mxws ifail = 7 return end if ifail = 0 goto 1 end if ifirstc = nu + 1 ifirstr = 1 2 continue !  move zero-column-count columns to lhs and find minimum column count mcc = n do i = ifirstc , nc coli = abs ( ls ( i )) if ( li ( coli ) == 0 ) then call iexch ( ls ( i ), ls ( ifirstc )) li ( coli ) = ifirstr - 1 ifirstc = ifirstc + 1 else mcc = min ( mcc , li ( coli )) end if end do !     write(nout,*)'ifirstc,ifirstr,mcc',ifirstc,ifirstr,mcc !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'ls =',(ls(i),i=nu+1,nc) !     write(nout,*)'row counts =',(r(lr(j)),j=1,n) !     write(nout,*)'column counts =',(li(abs(ls(i))),i=nu+1,nc) if ( ifirstc > nc ) goto 4 !  apply tie-break rule tie = 0 do i = ifirstc , nc coli = abs ( ls ( i )) if ( li ( coli ) == mcc ) then ti = 0 jp = la ( 0 ) + coli - n do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) if ( li ( rowj ) >= ifirstr ) ti = ti + r ( rowj ) end do if ( ti > tie ) then tie = ti mccc = coli end if end if end do !     write(nout,*)'tie,mccc',tie,mccc !  permute rows of m-c-c column to top and update column counts jp = la ( 0 ) + mccc - n do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) jr = li ( rowj ) if ( jr < ifirstr ) goto 3 if ( jr > nn ) goto 3 lr ( jr ) = lr ( ifirstr ) li ( lr ( jr )) = jr lr ( ifirstr ) = rowj li ( rowj ) = ifirstr ifirstr = ifirstr + 1 do i = p ( rowj ), q ( rowj ) coli = int ( ws ( i )) li ( coli ) = li ( coli ) - 1 end do 3 continue end do goto 2 4 continue !  print star diagram !     if (nc-nu>80 .or. n>1000) stop !     write(nout,*)'spk1 ordering' !     ij=li(abs(ls(nc))) !     do i=1,ij !       do j=1,nc-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,nc-nu !       jp=la(0)+abs(ls(nu+j))-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=1,ij !       write(nout,*)(star(i,j),j=1,nc-nu) !     end do !     write(nout,*)'lr =',(lr(i),i=1,n) !     write(nout,*)'ls =',(ls(i),i=nu+1,nc) !     write(nout,*)'lower profile =',(li(abs(ls(i))),i=nu+1,nc) return end subroutine factor ( n , nm , nu , nc , a , la , e , ls , sn , tn , un , xn , lr , lc , li , & mao , p , q , r , s , ws , mxws , d , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) integer coli , r , s , rowi , rowp , tl , tu dimension a ( * ), la ( 0 : * ), e ( * ), ls ( * ), sn ( * ), tn ( * ), un ( * ), xn ( * ), & lr ( * ), lc ( * ), li ( * ), mao ( * ), p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ), d ( * ) !     character star(1000,80) common / factorc / m1 , m2 , mp , mq , lastr , irow common / iprintc / iprint common / refactorc / mc , mxmc common / epsc / eps , tol , emin common / noutc / nout parameter ( thresh = 1.D-1 ) !  factorize LPA=U when A is rectangular !    p(row) stores the number of stored elements of a natural row !    q(row) stores the base address in ws of a natural row !    r(row) stores the previous row stored in ws (or 0 if the first row in ws) !    s(row) stores the next row stored in ws (or 0 if the last row in ws) !    li(n+*) stores the lower profile of the sparse matrix !    irow stores the natural row number of the initial row stored in ws !    lastr stores the natural row number of the previous row put into ws !     write(nout,*)'factor' nup = 0 lastr = 0 irow = 0 do i = 1 , n p ( i ) = 0 end do m1 = 0 tl = 1 do ii = nu + 1 , nc coli = abs ( ls ( ii )) !       write(nout,*)'coli =',coli tu = li ( coli ) do i = 1 , n tn ( i ) = 0.D0 end do call iscatter ( a , la , coli - n , li , tn , n ) do i = m1 , 1 , - 1 rowi = lr ( i ) pri = p ( rowi ) if ( pri == 0 ) then xn ( i ) = tn ( i ) / d ( i ) else xn ( i ) = ( scpr ( tn ( i ), ws ( q ( rowi ) + 1 ), tn ( i - pri ), pri )) / d ( i ) end if call isaipy ( - xn ( i ), a , la , lc ( i ) - n , tn , n , lr , li ) end do do i = 1 , m1 tn ( i ) = xn ( i ) end do m1p = m1 + 1 !       write(nout,*)'lr =',(lr(i),i=1,n) !       write(nout,*)'tn =',(tn(i),i=1,tu) !  threshold pivot selection call linf ( tu - m1 , tn ( m1p ), z , iz ) if ( z <= tol ) then li ( coli ) = 0 goto 2 end if zz = max ( tol , z * thresh ) do i = tl , tu q ( lr ( i )) = m1p end do !       write(nout,*)'q =',(q(lr(i)),i=m1p,tu) iz = iz + m1 if ( iz < tl ) then z = 0.D0 qri = m1p do j = m1p , tu tnj = abs ( tn ( j )) if ( tnj >= zz ) then qrj = q ( lr ( j )) if ( qrj == qri ) then if ( tnj > z ) then z = tnj iz = j end if else if ( qrj > qri ) then z = tnj iz = j qri = qrj end if end if end do end if tl = tu + 1 !       write(nout,*)'zz,z,iz,m1,qri',zz,z,iz,m1,qri if ( iz > m1p ) then call rexch ( tn ( m1p ), tn ( iz )) call iexch ( lr ( m1p ), lr ( iz )) li ( lr ( m1p )) = m1p li ( lr ( iz )) = iz end if rowp = lr ( m1p ) !  reset q values qrp = q ( rowp ) do i = m1p + 1 , tu if ( abs ( tn ( i )) > tol ) then rowi = lr ( i ) if ( qrp < q ( rowi )) q ( rowi ) = qrp end if end do tnp = tn ( m1p ) do i = 1 , n sn ( i ) = 0.D0 end do sn ( m1p ) = 1.D0 do i = 1 , m1 sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , 0.D0 , lr , li ) / d ( i ) rowi = lr ( i ) pri = p ( rowi ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( q ( rowi ) + 1 ), sn ( i - pri ), pri ) end do !       write(nout,*)'sn =',(sn(i),i=1,m1) !  update steepest edge coefficients ep = e ( rowp ) e ( rowp ) = 0.D0 eq = 2.D0 / ep do i = 1 , n un ( i ) = eq * sn ( i ) end do do i = m1 , 1 , - 1 rowi = lr ( i ) pri = p ( rowi ) if ( pri == 0 ) then xn ( i ) = un ( i ) / d ( i ) else xn ( i ) = ( scpr ( un ( i ), ws ( q ( rowi ) + 1 ), un ( i - pri ), pri )) / d ( i ) end if call isaipy ( - xn ( i ), a , la , lc ( i ) - n , un , n , lr , li ) end do do i = 1 , m1 un ( i ) = xn ( i ) end do !       write(nout,*)'un =',(un(i),i=1,n) eq = ep / tnp do i = 1 , nm if ( e ( i ) > 0.D0 ) then j = li ( i ) ei = e ( i ) wi = tn ( j ) * eq awi = abs ( wi ) if ( ei >= awi ) then wi = wi / ei e ( i ) = max ( emin , ei * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - un ( j ) / ei )))) else wi = ei / wi e ( i ) = max ( emin , awi * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - un ( j ) / ei )))) end if end if end do e ( coli ) = max ( emin , abs ( eq )) do j = qrp , m1 if ( abs ( sn ( j )) > tol ) goto 1 end do j = m1p 1 continue pri = m1p - j if ( pri > 0 ) then call newslot ( rowp , pri , lastr , irow , p , q , r , s , ws , mxws , i , ifail ) if ( ifail > 0 ) return p ( rowp ) = pri i = q ( rowp ) do j = j , m1 i = i + 1 ws ( i ) = sn ( j ) end do end if m1 = m1p ls ( m1 ) = ls ( ii ) lc ( m1 ) = coli li ( coli ) = m1 d ( m1 ) = tnp 2 continue end do !  complete ls and reorder lr, lc and d do i = m1 + 1 , n ls ( i ) = lr ( i ) end do j = n do i = 1 , nm if ( e ( i ) == 0.D0 ) then j = j + 1 ls ( j ) = i end if end do m2 = n - m1 do i = n , m2 + 1 , - 1 lc ( i ) = lc ( i - m2 ) li ( lc ( i )) = i lr ( i ) = lr ( i - m2 ) li ( lr ( i )) = i d ( i ) = d ( i - m2 ) end do do i = 1 , m2 lr ( i ) = ls ( m1 + i ) li ( lr ( i )) = i end do !  reset mao ilast = n ii = ilast do i = ilast , m2 + 1 , - 1 mao ( i ) = ilast ii = min ( ii , i - p ( lr ( i ))) if ( ii == i ) ilast = i - 1 end do !     write(nout,*)'PAQ factors:  m1 =',m1 !     write(nout,4)'d =',(d(ij),ij=m2+1,n) !     do ij=m2+1,n !       rowp=lr(ij) !       if (p(rowp)/=0) then !         write(nout,*)'L(',rowp,')', !    *      (ws(k),k=q(rowp)+1,q(rowp)+p(rowp)) !       end if !     end do !  print star diagram !     write(nout,*)'factored ordering:  m1 =',m1 !     if (m1>80 .or. n>1000) stop !     do i=1,n !       do j=1,m1 !         star(i,j)=' ' !       end do !     end do !     do j=1,m1 !       jp=la(0)+lc(m2+j)-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=m2+1,n !       write(nout,*)(star(i,j),j=1,m1) !     end do !     write(nout,9)'ls =',(ls(j),j=1,n) !     write(nout,*)'s.e. coeffs =',(e(i),i=1,nm) !     write(nout,9)'lr =',(lr(j),j=1,n) !     write(nout,9)'lc =',(lc(j),j=m2+1,n) !     write(nout,9)'li =',(li(j),j=1,nm) !     write(nout,9)'mao =',(mao(j),j=m2+1,n) !     call checkout(n,a,la,lr,lc,li,p,q,r,s,ws,mxws,d) 4 format ( A / ( 5E15 . 7 )) 9 format ( A / ( 15 I5 )) return end subroutine re_order ( n , nm , a , la , point , lr , lc , li , mao , p , q , r , s , & t , ws , mxws , ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) dimension a ( * ), la ( * ), point ( 0 : * ), lr ( * ), lc ( * ), li ( * ), mao ( * ), & p ( * ), q ( * ), r ( * ), s ( * ), t ( * ), ws ( * ) common / factorc / m1 , nu , mp , mq , lastr , irow common / noutc / nout logical backtrack !     character star(1000,80) !  print star diagram !     if (n-nu>80 .or. n>1000) stop !     write(nout,*)'initial ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !     write(nout,*)'re_order' if ( nu == n ) then ifail = 0 return end if m = nm - n !  transversal search do iq = nu + 1 , n backtrack = . false . istack = nu inode = iq nodec = lc ( inode ) nodec_n = nodec - n lap = point ( nodec_n + 1 ) - point ( nodec_n ) !       write(nout,*)'column node =',nodec,'  look-ahead rows =', !    *    (la(j),j=point(nodec_n),point(nodec_n)+lap-1) !  look-ahead loop 1 continue lap = lap - 1 nextr = la ( point ( nodec_n ) + lap ) inext = li ( nextr ) if ( inext >= iq ) goto 4 if ( lap > 0 ) goto 1 li ( nodec ) = 0 2 continue !  reassignment depth first search t ( inode ) = point ( nodec_n + 1 ) - point ( nodec_n ) !       write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *    (la(j),j=point(nodec_n),point(nodec_n)+t(inode)-1) 3 continue !  examine successor nodes if ( t ( inode ) == 0 ) then if ( istack == nu ) then ifail = 1 !           ifail=iq !           write(nout,*)'exit: ifail =',iq !           print *,'lc(iq) =',lc(iq) return end if istack = istack - 1 backtrack = . true . if ( istack == nu ) then inode = iq else inode = mao ( istack ) end if !         write(nout,*)'backtrack to node at address =',inode nodec = lc ( inode ) nodec_n = nodec - n !         write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *      (la(j),j=point(nodec_n),point(nodec_n)+t(inode)-1) goto 3 end if t ( inode ) = t ( inode ) - 1 nextr = la ( point ( nodec_n ) + t ( inode )) inext = li ( nextr ) if ( inext <= nu ) goto 3 if ( t ( inext ) >= 0 ) goto 3 !  extend depth first search !       write(nout,*)'nextr,inext',nextr,inext inode = inext !       write(nout,*)'put node address on stack' istack = istack + 1 mao ( istack ) = inode !       write(nout,*)'stack =',(mao(j),j=nu+1,istack) nodec = lc ( inode ) nodec_n = nodec - n lap = li ( nodec ) if ( lap == 0 ) goto 2 !       write(nout,*)'column node =',nodec,'  look-ahead rows =', !    *    (la(j),j=point(nodec_n),point(nodec_n)+lap-1) goto 1 4 continue !       write(nout,*)'new assignment found in row',nextr !       write(nout,*)'istack,inext,nextr',istack,inext,nextr !       if (istack>nu) write(nout,*)'stack =',(mao(j),j=nu+1,istack) li ( nodec ) = lap !  perform row permutation lr ( inext ) = lr ( iq ) li ( lr ( inext )) = inext inode = iq do i = nu + 1 , istack inext = mao ( i ) lr ( inode ) = lr ( inext ) li ( lr ( inode )) = inode inode = inext end do lr ( inode ) = nextr li ( nextr ) = inode !       write(nout,*)'lr =',(lr(j),j=nu+1,n) !       write(nout,*)'look-ahead lengths =',(li(lc(j)),j=nu+1,iq) t ( iq ) =- 1 if ( backtrack . or . istack > nu + 1 ) then do i = nu + 1 , iq - 1 t ( i ) =- 1 end do end if do i = 1 , n if ( li ( i ) > n ) then write ( nout , * ) 'iq =' , iq stop end if end do end do !     write(nout,*)'transversal found' !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !  print star diagram !     if (n-nu>80 .or. n>1000) stop !     write(nout,*)'transversal ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !  tarjan ordering do i = 1 , n q ( i ) = 0 r ( i ) = 0 end do !  reset li and pair off columns with rows do i = nu + 1 , n nodec = lc ( i ) li ( nodec ) = i t ( lr ( i )) = nodec s ( i ) = 0 end do do i = nu + 1 , n noder = lr ( i ) nodec = t ( noder ) lc ( noder ) = point ( nodec - n + 1 ) - point ( nodec - n ) li ( nodec ) =- 1 end do ifath = nu istack = n + 1 !  tarjan loop 10 continue istack = istack - 1 inode = istack noder = lr ( inode ) if ( lc ( noder ) == 0 ) then write ( nout , * ) 'malfunction: zero length' stop end if nodec = t ( noder ) 11 continue li ( nodec ) = lc ( noder ) mao ( inode ) = istack !       write(nout,*)'put new node',noder,' on stack' !       write(nout,*)'active part of lr =',(lr(j),j=ifath+1,n) !       write(nout,*)'ifath,istack =',ifath,istack !       write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *    (la(j),j=point(nodec-n),point(nodec-n)+li(nodec)-1) 12 continue if ( li ( nodec ) == 0 ) then !           write(nout,*)'backtrack to previous nodes' 13 continue if ( inode == n ) goto 14 inext = inode + 1 nextr = lr ( inext ) if ( mao ( inode ) < mao ( inext )) goto 14 inode = inext noder = nextr nodec = t ( noder ) if ( li ( nodec ) == 0 ) goto 13 !           write(nout,*)'stack =',(lr(j),j=istack,n) !           write(nout,*)'lengths =',(li(t(lr(j))),j=istack,n) !           write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *        (la(j),j=point(nodec-n),point(nodec-n)+li(nodec)-1) goto 12 end if !  examine successors of current node li ( nodec ) = li ( nodec ) - 1 nextr = la ( point ( nodec - n ) + li ( nodec )) inext = li ( nextr ) if ( inext <= ifath ) goto 12 q ( nextr ) = q ( nextr ) + 1 nextc = t ( nextr ) !         write(nout,*)'nextc,nextr,inext',nextc,nextr,inext if ( li ( nextc ) >= 0 ) then mx = mao ( inext ) if ( mao ( inode ) >= mx ) goto 12 do j = istack , n if ( mao ( j ) == mx ) goto 12 mao ( j ) = mx end do write ( nout , * ) 'malfunction' stop end if nodec = nextc noder = nextr istack = istack - 1 inode = istack lr ( inext ) = lr ( inode ) li ( lr ( inext )) = inext lr ( inode ) = noder li ( noder ) = inode goto 11 14 continue !       write(nout,*)'strong component identified' !       write(nout,*)'active part of lr =',(lr(j),j=ifath+1,n) !       write(nout,*)'ifath,istack,inode =',ifath,istack,inode,n !  shift forward strong component inext = istack - 1 ir = inode - inext do j = istack , inode mao ( j ) = lr ( j ) end do do j = inext + ir , ifath + 1 + ir , - 1 lr ( j ) = lr ( j - ir ) li ( lr ( j )) = j end do mx = ifath + ir iq = inext - ifath ifath = ifath + 1 do j = ifath , mx lr ( j ) = mao ( j + iq ) li ( lr ( j )) = j mao ( j ) = mx end do istack = inode + 1 ifath = mx !       write(nout,*)'active part of lr =',(lr(j),j=ifath+1,n) !       write(nout,*)'ifath,istack =',ifath,istack if ( istack <= n ) then inode = istack noder = lr ( inode ) nodec = t ( noder ) nodec_n = nodec - n !         write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *      (la(j),j=point(nodec-n),point(nodec-n)+li(nodec)-1) goto 12 end if if ( ifath < n ) goto 10 !  end of tarjan process !  reset lc and li do i = nu + 1 , n lc ( i ) = t ( lr ( i )) li ( lc ( i )) = i end do !     write(nout,*)'mao =',(mao(j),j=nu+1,n) !     write(nout,*)'q =',(q(j),j=1,n) !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !     write(nout,*)'li =',(li(j),j=1,n+m) !  print star diagram !     if (n-nu>80 .or. n>1000) stop !     write(nout,*)'tarjan ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !  set up pointers for row-wise sparse structure p ( 1 ) = 1 do i = 1 , n - 1 p ( i + 1 ) = p ( i ) + q ( i ) q ( i ) = p ( i ) - 1 end do if ( p ( n ) + q ( n ) > mxws ) then print * , 'not enough space for ws in re_order' ifail = 7 return end if q ( n ) = p ( n ) - 1 i = nu + 1 20 continue if ( i == mao ( i )) then t ( i ) = i else !  spk1 ordering on tarjan block !  set row and column counts do inode = i , mao ( i ) nodec = lc ( inode ) do j = point ( nodec - n ), point ( nodec - n + 1 ) - 1 noder = la ( j ) if ( li ( noder ) >= i ) then q ( noder ) = q ( noder ) + 1 ws ( q ( noder )) = dble ( nodec ) s ( inode ) = s ( inode ) + 1 end if end do end do !       print *,'r-c counts: i =',i,'   mao(i) =',mao(i) !       print *,'q =',(q(j),j=i,mao(i)) !       print *,'s =',(s(j),j=i,mao(i)) !  find minimum-column-count column mcc = n do inode = i , mao ( i ) noder = lr ( inode ) r ( noder ) = q ( noder ) - p ( noder ) + 1 mcc = min ( mcc , s ( inode )) end do !     write(nout,*)'i,mao(i),mcc',i,mao(i),mcc !     write(nout,*)'p =',(p(lr(j)),j=i,mao(i)) !     write(nout,*)'q =',(q(lr(j)),j=i,mao(i)) !     write(nout,*)'r =',(r(lr(j)),j=i,mao(i)) !     write(nout,*)'s =',(s(j),j=i,mao(i)) !  check for fully dense block if ( mcc > mao ( i ) - i ) then do inode = i , mao ( i ) t ( inode ) = mao ( i ) end do goto 22 end if !  determine spk1 ordering ifirstr = i ifirstc = i 21 continue !  apply tie-break rule tie = 0 do inode = ifirstc , mao ( i ) if ( s ( inode ) == mcc ) then nodec = lc ( inode ) - n ti = 0 do j = point ( nodec ), point ( nodec + 1 ) - 1 noder = la ( j ) if ( li ( noder ) >= ifirstr ) ti = ti + r ( noder ) end do if ( ti > tie ) then tie = ti mccc = nodec end if end if end do !       write(nout,*)'tie,mccc',tie,mccc+n !  permute rows of m-c-c column to top and update column counts do j = point ( mccc ), point ( mccc + 1 ) - 1 noder = la ( j ) ir = li ( noder ) if ( ir >= ifirstr ) then lr ( ir ) = lr ( ifirstr ) li ( lr ( ir )) = ir lr ( ifirstr ) = noder li ( noder ) = ifirstr ifirstr = ifirstr + 1 do ir = p ( noder ), q ( noder ) inode = li ( int ( ws ( ir ))) s ( inode ) = s ( inode ) - 1 end do end if end do !       write(nout,*)'s =',(s(ij),ij=i,mao(i)) !       write(nout,*)'lr =',(lr(ij),ij=i,mao(i)) !  move zero-column-count columns to lhs and find minimum column count mcc = n do inode = ifirstc , mao ( i ) if ( s ( inode ) == 0 ) then nodec = lc ( inode ) lc ( inode ) = lc ( ifirstc ) li ( lc ( inode )) = inode lc ( ifirstc ) = nodec li ( nodec ) = ifirstc s ( inode ) = s ( ifirstc ) t ( ifirstc ) = ifirstr - 1 ifirstc = ifirstc + 1 else mcc = min ( mcc , s ( inode )) end if end do !       write(nout,*)'lc =',(lc(ij),ij=i,mao(i)) !       write(nout,*)'ifirstc,mcc',ifirstc,mcc if ( ifirstc < mao ( i )) goto 21 end if 22 continue i = mao ( i ) + 1 if ( i <= n ) goto 20 !  print star diagram !     if (n-nu>80 .or. n>1000) stop !     write(nout,*)'tarjan + spk1 ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !     write(nout,*)'lr =',(lr(j),j=nu+1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !     write(nout,*)'lower profile =',(t(j),j=nu+1,n) ifail = 0 return end subroutine re_factor ( n , nm , a , la , lr , lc , li , mao , p , q , r , s , & t , ws , mxws , d , ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) dimension a ( * ), la ( 0 : * ), lr ( * ), lc ( * ), li ( * ), mao ( * ), & p ( * ), q ( * ), r ( * ), s ( * ), t ( * ), d ( * ), ws ( * ) !     character star(1000,80) common / factorc / m1 , nu , mp , mq , lastr , irow common / iprintc / iprint common / refactorc / mc , mxmc common / epsc / eps , tol , emin common / noutc / nout double precision thresh , tol parameter ( thresh = 1.D-1 ) !  factorize LPA=U !    p(row) stores the number of stored elements of a natural row !    q(row) stores the base address in ws of a natural row !    r(row) stores the previous row stored in ws (or 0 if the first row in ws) !    s(row) stores the next row stored in ws (or 0 if the last row in ws) !    t(*) stores the lower profile of the sparse matrix !    irow stores the natural row number of the initial row stored in ws !    lastr stores the natural row number of the previous row put into ws !     write(nout,*)'re_factor' nup = 0 m = nm - n lastr = 0 irow = 0 do i = 1 , n p ( i ) = 0 end do if ( m1 == 0 ) return i = nu + 1 1 continue if ( i == mao ( i )) then d ( i ) = aij ( lr ( i ), lc ( i ) - n , a , la ) if ( d ( i ) == 0.D0 ) d ( i ) = eps !       write(nout,*)'row,col,d(i) =',lr(i),lc(i),d(i) else !       write(nout,*)'lc =',(lc(j),j=i,mao(i)) do inode = i , mao ( i ) - 1 nodec = lc ( inode ) - n im = inode - 1 !  form L.a_q z = 0. !         write(nout,*)'inode,t(inode)',inode,t(inode) do j = inode , t ( inode ) rowj = lr ( j ) prj = p ( rowj ) if ( prj > 0 ) then d ( j ) = aiscpri2 ( n , a , la , rowj , nodec , ws ( q ( rowj ) + 1 ), 1.D0 , im , & prj , li ) else d ( j ) = aij ( rowj , nodec , a , la ) end if z = max ( z , abs ( d ( j ))) end do !         write(nout,*)'d =',(d(ij),ij=inode,t(inode)) !  threshold pivot selection zz = z * thresh z = 0.D0 pri = n do j = inode , t ( inode ) dj = abs ( d ( j )) if ( dj >= zz ) then prj = p ( lr ( j )) if ( prj == pri ) then if ( dj > z ) then z = dj iz = j end if else if ( prj < pri ) then z = dj iz = j pri = prj end if end if end do !       write(nout,*)'zz,z,iz,pri',zz,z,iz,pri if ( iz > inode ) then !  pivot interchange call rexch ( d ( inode ), d ( iz )) call iexch ( lr ( inode ), lr ( iz )) li ( lr ( iz )) = iz li ( lr ( inode )) = inode end if if ( d ( inode ) == 0.D0 ) d ( inode ) = eps !  update L qri = q ( lr ( inode )) zz =- d ( inode ) do j = inode + 1 , t ( inode ) z = d ( j ) / zz rowj = lr ( j ) prj = p ( rowj ) qrj = q ( rowj ) !  find space available in-situ in ws if ( prj == 0 ) then len = 0 else if ( s ( rowj ) == 0 ) then len = mxws - qrj else len = q ( s ( rowj )) - qrj end if if ( abs ( z ) <= tol ) then !  special case of a zero multiplier if ( prj == 0 ) goto 2 len_ = prj + 1 if ( len_ > len ) then call newslot ( rowj , len_ , lastr , irow , p , q , r , s , ws , mxws , qrj , & ifail ) if ( ifail > 0 ) return qrj_ = q ( rowj ) do k = 1 , prj ws ( qrj_ + k ) = ws ( qrj + k ) end do ws ( qrj_ + len_ ) = z else ws ( qrj + len_ ) = z end if p ( rowj ) = len_ goto 2 end if len_ = max ( pri , prj ) + 1 if ( len_ > len . or . pri > prj ) then !  create a new slot and use saxpyz ... call newslot ( rowj , len_ , lastr , irow , p , q , r , s , ws , mxws , qrj , & ifail ) if ( ifail > 0 ) return qrj_ = q ( rowj ) len = prj - pri if ( len >= 0 ) then do k = 1 , len ws ( qrj_ + k ) = ws ( qrj + k ) end do len = len + 1 call saxpyz ( z , ws ( qri + 1 ), ws ( qrj + len ), ws ( qrj_ + len ), & len_ - len ) else len =- len do k = 1 , len ws ( qrj_ + k ) = z * ws ( qri + k ) end do len = len + 1 call saxpyz ( z , ws ( qri + len ), ws ( qrj + 1 ), ws ( qrj_ + len ), & len_ - len ) end if ws ( qrj_ + len_ ) = z else !  ... else saxpy in-situ if ( pri > 0 ) & call mysaxpy ( z , ws ( qri + 1 ), ws ( qrj + prj - pri + 1 ), pri ) ws ( qrj + len_ ) = z end if p ( rowj ) = len_ !           do rj=1,n !             if (p(rj)/=0) then !               write(nout,*)'storage for row',rj,'  p,q,r,s =', !    *            p(rj),q(rj),r(rj),s(rj) !             end if !           end do 2 continue end do !         write(nout,*)'lr =',(lr(j),j=i,mao(i)) !         do j=i,mao(i) !           rowj=lr(j) !           if (p(rowj)/=0) then !             write(nout,*)'L(',rowj,')', !    *          (ws(k),k=q(rowj)+1,q(rowj)+p(rowj)) !           end if !         end do end do inode = mao ( i ) noder = lr ( inode ) pri = p ( noder ) if ( pri > 0 ) then d ( inode ) = aiscpri2 ( n , a , la , noder , lc ( inode ) - n , ws ( q ( noder ) + 1 ), & 1.D0 , inode - 1 , pri , li ) else d ( inode ) = aij ( noder , lc ( inode ) - n , a , la ) end if if ( d ( inode ) == 0.D0 ) d ( inode ) = eps end if i = mao ( i ) + 1 if ( i <= n ) goto 1 !     write(nout,*)'PAQ factors:  nu =',nu !     write(nout,*)'column perm =',(lc(j),j=nu+1,n) !     write(nout,*)'row perm =',(lr(j),j=nu+1,n) !     write(nout,*)'d =',(d(ij),ij=nu+1,n) !     do j=nu+1,n !       rowj=lr(j) !       if (p(rowj)/=0) then !         write(nout,*)'L(',rowj,')', !    *      (ws(k),k=q(rowj)+1,q(rowj)+p(rowj)) !       end if !     end do !     call checkout(n,a,la,lr,lc,li,p,q,r,s,ws,mxws,d) !  print star diagram !     if (m1>80 .or. n>1000) stop !     write(nout,*)'factored tarjan + spk1 ordering:  nu =',nu !     do i=1,n !       do j=1,m1 !         star(i,j)=' ' !       end do !     end do !     do j=1,m1 !       jp=la(0)+lc(nu+j)-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,m1) !     end do !     write(nout,*)'lr =',(lr(j),j=nu+1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) mp =- 1 mq =- 1 ifail = 0 return end function aiscpri2 ( n , a , la , rowi , coli , ws , di , im , pri , li ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), ws ( * ), li ( * ) integer rowi , coli , rowj , pri aiscpri2 = 0.D0 jp = la ( 0 ) + coli do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) if ( rowj == rowi ) then aiscpri2 = aiscpri2 + di * a ( j ) else ir = li ( rowj ) - im if ( ir > 0 ) goto 1 ir = ir + pri if ( ir > 0 ) aiscpri2 = aiscpri2 + ws ( ir ) * a ( j ) end if 1 continue end do return end subroutine updateSE ( p , q , n , nm , a , la , e , Q_ , R , EB , y , z , s , t , u , x , & d , ws , lr , lc , li , pp , qq , lm , lv , le , ifail ) implicit double precision ( a - h , o - z ) integer p , q , pc , qr , pp , qq dimension a ( * ), la ( 0 : * ), e ( * ), Q_ ( * ), R ( * ), EB ( * ), y ( * ), z ( * ), s ( * ), t ( * ), & x ( * ), u ( * ), d ( * ), ws ( * ), & lr ( * ), lc ( * ), li ( * ), pp ( * ), qq ( * ), lm ( * ), lv ( * ), le ( * ) common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / mc , mxmc common / epsc / eps , tol , emin common / pqc / pc , qr , lmp 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) 5 format (( 5E15 . 7 )) !     print 1,'updateSE: p,q =',p,q !     print 3,'lm =',(lm(i),i=1,n) if ( p /= mp ) then call eptsol ( n , a , la , p , a , Q_ , R , EB , y , s , u , x , d , ws , & lr , lc , li , lv , le , pp , qq , ep ) !       print 4,'sk in natural ordering',(s(li(i)),i=1,n) !       print 4,'sk ordered by lr',(s(i),i=1,n) else ep = e ( p ) end if if ( q /= mq ) then call aqsol ( n , a , la , q , Q_ , R , EB , z , t , u , x , d , ws , & lr , lc , li , lv , le , pp , qq ) !       print 4,'tk =',(t(i),i=1,n) end if !  update steepest edge coefficients tp = t ( lmp ) eq = 2.D0 / ep do i = 1 , n u ( i ) = eq * s ( i ) end do call aqsol ( n , a , la , 0 , Q_ , R , EB , x , u , s , x , d , ws , & lr , lc , li , lv , le , pp , qq ) !     print 4,'u in natural order =',(u(li(i)),i=1,n) !     print 4,'u ordered by lr =',(u(i),i=1,n) eq = ep / tp do j = 1 , n i = lm ( j ) if ( e ( i ) == 0.D0 ) then print * , 'malfunction: e(i)=0.D0, i =' , i return end if ei = e ( i ) wi = t ( j ) * eq awi = abs ( wi ) if ( ei >= awi ) then wi = wi / ei e ( i ) = max ( emin , ei * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - u ( j ) / ei )))) else wi = ei / wi e ( i ) = max ( emin , awi * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - u ( j ) / ei )))) end if end do e ( p ) = 0.D0 e ( q ) = max ( emin , abs ( eq )) !     print 4,'e =',(e(i),i=1,nm) return end subroutine updateQR ( p , q , n , a , la , Q_ , R , EB , x , y , z , & lr , lc , li , lv , le , lm , ifail ) implicit double precision ( a - h , o - z ) integer p , q , pc , qr dimension a ( * ), la ( 0 : * ), Q_ ( * ), R ( * ), EB ( * ), x ( * ), y ( * ), z ( * ), & lr ( * ), lc ( * ), li ( * ), lv ( * ), le ( * ), lm ( * ) common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / mc , mxmc common / epsc / eps , tol , emin common / pqc / pc , qr , lmp 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) 5 format (( 5E15 . 7 )) !     print 1,'updateQR:  p,q =',p,q,pc,qr !     print *,'mc =',mc !  x is only used for checking m1mc = m1 * mc !     print 4,'EB on entry to updateQR =',(EB(i),i=1,m1mc+m1) if ( pc == 0 ) then !  p is in the starting active set if ( qr == 0 ) then !  q is a new column: extend QR case !         print *,'extend  ',p,q mc1 = mc + 1 !         print 4,'EB for c/s p =',(EB(i),i=m1mc+1,m1mc+m1) ii = m1mc - m2 if ( q <= n ) then if ( li ( q ) > m2 ) sum =- EB ( li ( q ) + ii ) else sum = 0.D0 jp = la ( 0 ) + q - n do j = la ( jp ), la ( jp + 1 ) - 1 i = la ( j ) if ( i == p ) then sum = sum - a ( j ) else if ( li ( i ) > m2 ) then sum = sum - EB ( li ( i ) + ii ) * a ( j ) end if end do end if y ( mc1 ) = sum if ( mc == 0 ) then Q_ ( 1 ) = 1.D0 R ( 1 ) = y ( 1 ) !           print 2,'R(1) =',R(1) mc = 1 else !  new row and column of C !           print 2,'y =',(y(i),i=1,mc1) !           print 2,'z =',(z(i),i=1,mc) ic = mc1 mmx = mc * mxmc do i = 1 , mc Q_ ( ic ) = 0.D0 Q_ ( mmx + i ) = 0.D0 ic = ic + mxmc end do Q_ ( ic ) = 1.D0 ii = 1 ic = 1 mmx1 = mmx + 1 do i = 1 , mc call angle ( R ( ii ), y ( i ), cos , sin ) call rot ( mc - i , R ( ii + 1 ), y ( i + 1 ), cos , sin ) call rot ( mc1 , Q_ ( ic ), Q_ ( mmx1 ), cos , sin ) ii = ii + mxmc - i + 1 ic = ic + mxmc end do z ( mc1 ) = y ( mc1 ) !           print 2,'z =',(z(i),i=1,mc1) ii = mc1 ic = 1 do i = 1 , mc1 R ( ii ) = scpr ( 0.D0 , Q_ ( ic ), z , mc1 ) ii = ii + mxmc - i ic = ic + mxmc end do mc = mc1 end if lv ( mc ) = q le ( mc ) = p lm ( lmp ) = q goto 10 else !  row replacement case: p is in the starting active set and !  q is in the starting active set (and hence in row qr of E) !         print *,'row     ',p,q !         print 3,'lr =',(lr(i),i=1,n) !         print 3,'lc =',(lc(i),i=m2+1,n) !         print 3,'le =',(le(i),i=1,mc) !         print 3,'lv =',(lv(i),i=1,mc) !         print 3,'lm =',(lm(i),i=1,n) mc1 = mc mc = mc - 1 j = mc1 - qr if ( mc > 0 ) then icp = mxmc * mc + mc1 ic = icp call rexch ( Q_ ( icp ), Q_ ( icp - j )) ii = mc1 * ( 3 - mc1 ) / 2 + ( mc1 - 1 ) * mxmc z ( mc1 ) = R ( ii ) do i = mc , 1 , - 1 ic = ic - mxmc call rexch ( Q_ ( ic ), Q_ ( ic - j )) call angle ( Q_ ( icp ), Q_ ( ic ), cos , sin ) call rot ( mc , Q_ ( icp - mc ), Q_ ( ic - mc ), cos , sin ) ii = ii - mxmc + i - 1 z ( i ) = sin * R ( ii ) R ( ii ) =- cos * R ( ii ) call rot ( mc1 - i , z ( i + 1 ), R ( ii + 1 ), cos , sin ) end do ic = 1 icp = icp - mc do i = 1 , mc call angle ( R ( ii ), y ( i ), cos , sin ) call rot ( mc1 - i , R ( ii + 1 ), y ( i + 1 ), cos , sin ) call rot ( mc1 , Q_ ( ic ), Q_ ( icp ), cos , sin ) ii = ii + mxmc - i + 1 ic = ic + mxmc end do R ( ii ) = y ( mc1 ) le ( qr ) = le ( mc1 ) else Q_ ( 1 ) = 1.D0 R ( 1 ) = y ( 1 ) end if le ( mc1 ) = p !         j=m1*(mc1-qr) j = m1 * j do i = m1mc - m1 + 1 , m1mc EB ( i - j ) = EB ( i ) EB ( i ) = EB ( i + m1 ) end do mc = mc1 end if else !  p is not in the starting active set (and hence in column pc of V) !  first remove column pc from V call ishift ( lv ( pc ), mc - pc , 1 ) ic = pc do i = 1 , pc - 1 call r_shift ( R ( ic ), mc - pc , 1 ) ic = ic + mxmc - i end do mc1 = mc mc = mc - 1 ii = ic + 1 iip = ii + mxmc - pc ic = ( pc - 1 ) * mxmc + 1 do i = pc , mc call angle ( R ( ii ), R ( iip ), cos , sin ) call rot ( mc - i , R ( ii + 1 ), R ( iip + 1 ), cos , sin ) call r_shift ( R ( ii - 1 ), mc1 - i , 1 ) ii = iip + 1 iip = ii + mxmc - i - 1 icp = ic + mxmc call rot ( mc1 , Q_ ( ic ), Q_ ( icp ), cos , sin ) ic = icp end do if ( qr == 0 ) then !         print *,'column  ',p,q !  q is a new column (column interchange case) !         print 2,'z =',(z(i),i=1,mc1) ii = mc1 ic = 1 do i = 1 , mc1 R ( ii ) = scpr ( 0.D0 , Q_ ( ic ), z , mc1 ) ii = ii + mxmc - i ic = ic + mxmc end do mc = mc1 lv ( mc ) = q else !  q is in the starting active set and hence in row qr of E (contract QR case) !         print *,'contract',p,q icp = mxmc * mc + mc1 ic = icp j = mc1 - qr call rexch ( Q_ ( icp ), Q_ ( icp - j )) ii = mc * ( 3 - mc ) / 2 + ( mc - 1 ) * mxmc do i = mc , 1 , - 1 ic = ic - mxmc call rexch ( Q_ ( ic ), Q_ ( ic - j )) call angle ( Q_ ( icp ), Q_ ( ic ), cos , sin ) call rot ( mc , Q_ ( icp - mc ), Q_ ( ic - mc ), cos , sin ) y ( i ) = sin * R ( ii ) R ( ii ) =- cos * R ( ii ) call rot ( mc - i , y ( i + 1 ), R ( ii + 1 ), cos , sin ) ii = ii - mxmc + i - 2 end do le ( qr ) = le ( mc1 ) j = m1 * ( mc1 - qr ) do i = m1mc - m1 + 1 , m1mc EB ( i - j ) = EB ( i ) end do end if end if !  reset lm (except when extending) do i = 1 , m2 lm ( i ) = lr ( i ) end do do i = m2 + 1 , n lm ( i ) = lc ( i ) end do do i = 1 , mc lm ( li ( le ( i ))) = lv ( i ) end do !     print 3,'le =',(le(i),i=1,mc) !     print 3,'lv =',(lv(i),i=1,mc) !     print 3,'lm =',(lm(i),i=1,n) 10 continue ifail = 0 if ( mc == 0 ) return !     print 4,'Q transpose =',(Q_(j),j=1,mc) !     do i=1,mc-1 !       print 5,(Q_(j),j=i*mxmc+1,i*mxmc+mc) !     end do !     print 4,'R =',(R(j),j=1,mc) !     ii=mxmc+1 !     do i=1,mc-1 !       print 5,(R(j),j=ii,ii+mc-i-1) !       ii=ii+mxmc-i !     end do sum = R ( mc * ( 3 - mc ) / 2 + ( mc - 1 ) * mxmc ) if ( sum - sum /= 0.D0 . or . sum == 0.D0 ) ifail = 1 return !  check QR factors !     print 4,'EB in check =',(EB(i),i=1,m1mc) do j = 1 , mc do i = 1 , n x ( i ) = 0.D0 end do if ( lv ( j ) <= n ) then x ( li ( lv ( j ))) = 1.D0 else call iscatter ( a , la , lv ( j ) - n , li , x , n ) end if do i = 1 , mc z ( i ) = 0.D0 end do i1 = j do i = 1 , j call mysaxpy ( R ( i1 ), Q_ (( i - 1 ) * mxmc + 1 ), z , mc ) i1 = i1 + mxmc - i end do !       print 4,'z =',(z(i),i=1,mc) !       print 4,'x =',(x(i),i=1,n) emax = 0.D0 do i = 1 , mc cij =- scpr ( 0.D0 , EB (( i - 1 ) * m1 + 1 ), x ( m2 + 1 ), m1 ) if ( le ( i ) <= n ) cij = cij - x ( li ( le ( i ))) qrij = z ( i ) emax = max ( emax , abs ( cij - qrij )) !         if (abs(cij-qrij)>tol) then !           print *,'error in C=QR:  i,j =',i,j !           print *,'cij,qrij =',cij,qrij !           if (abs(cij-qrij)>1.D-6) stop !         end if end do end do if ( emax > tol ) print * , 'max error in C=QR =' , emax if ( emax > tol ) stop return end subroutine newslot ( row , len , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) parameter ( igap = 10 ) dimension p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ) common / noutc / nout !     write(nout,*)'newslot: row =',row,'   len =',len !     write(nout,*)'irow,lastr,mxws =',irow,lastr,mxws ifail = 0 if ( lastr == 0 ) then if ( mxws < len ) then write ( nout , * ) 'insufficient space available for profile' ifail = 7 else irow = row q ( row ) = 0 r ( row ) = 0 s ( row ) = 0 lastr = row end if return end if igp = igap 1 continue len_ = len + igp thisr = lastr 2 continue qrow = q ( thisr ) + p ( thisr ) nextr = s ( thisr ) !     write(nout,*)'thisr,nextr,qrow,p(thisr),len_', !    *  thisr,nextr,qrow,p(thisr),len_ if ( nextr /= 0 ) then if ( q ( nextr ) >= qrow + len_ ) then !  free slot after this row goto 4 else thisr = nextr if ( thisr /= lastr ) goto 2 end if else if ( mxws - qrow >= len_ ) then !  free slot at end of ws goto 4 else if ( q ( irow ) >= len_ ) then !  free slot at beginning of ws qrow = 0 thisr = 0 nextr = irow irow = row igp = 0 goto 4 end if thisr = irow if ( thisr /= lastr ) goto 2 end if !  no free space: try minimum value of len if ( igp > 0 ) then igp = 0 goto 1 end if !  compress ws thisr = irow qrow = 0 3 continue call r_shift ( ws ( qrow + 1 ), p ( thisr ), q ( thisr ) - qrow ) q ( thisr ) = qrow qrow = qrow + p ( thisr ) if ( s ( thisr ) /= 0 ) then thisr = s ( thisr ) goto 3 end if if ( mxws < qrow + len_ ) then write ( nout , * ) 'insufficient space available for profile' write ( nout , * ) 'mxws,qrow,len_' , mxws , qrow , len_ ifail = 7 return end if !  insert at end of compressed file nextr = 0 4 continue qr_ = q ( row ) q ( row ) = qrow + igp if ( p ( row ) > 0 ) then if ( r ( row ) == thisr . or . s ( row ) == nextr ) return !  insert after row thisr and take out old row call erase ( row , lastr , irow , r , s ) end if lastr = row r ( row ) = thisr if ( thisr > 0 ) s ( thisr ) = row s ( row ) = nextr if ( nextr > 0 ) r ( nextr ) = row i = 0 return end subroutine erase ( row , lastr , irow , r , s ) !  remove slot for row from the data file implicit integer ( i - s ) dimension r ( * ), s ( * ) common / noutc / nout !     write(nout,*)'erase: row,irow,lastr =',row,irow,lastr if ( r ( row ) == 0 ) then if ( s ( row ) == 0 ) then irow = 0 lastr = 0 return end if irow = s ( row ) r ( irow ) = 0 else if ( s ( row ) == 0 ) then s ( r ( row )) = 0 else s ( r ( row )) = s ( row ) r ( s ( row )) = r ( row ) end if if ( row == lastr ) lastr = irow return end subroutine trim_ ( rowi , pri , qri , q , ws ) !  trim leading zeros off slot for row i implicit double precision ( a - h , s - z ), integer ( i - r ) dimension q ( * ), ws ( * ) common / epsc / eps , tol , emin 1 continue qri = qri + 1 pri = pri - 1 if ( pri == 0 ) return if ( abs ( ws ( qri + 1 )) <= tol ) goto 1 q ( rowi ) = qri return end subroutine EBspace ( n , p , q , s , lr , ws , neb , nprof , ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) dimension p ( * ), q ( * ), s ( * ), lr ( * ), ws ( * ) common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / mc , mxmc common / noutc / nout ifail = 0 !  find length and last entry in file len = 0 last = 0 do i = m2 + 1 , n row = lr ( i ) if ( p ( row ) > 0 ) then len = len + p ( row ) last = max ( last , q ( row ) + p ( row )) end if end do neb = m1 * ( mxmc + 1 ) !     print *,'nprof =',nprof !     print *,'m1,len,last,neb',m1,len,last,neb if ( last + neb <= nprof ) then neb = last return else if ( len + neb <= nprof ) then !  compress the file thisr = irow qrow = 0 1 continue call r_shift ( ws ( qrow + 1 ), p ( thisr ), q ( thisr ) - qrow ) q ( thisr ) = qrow qrow = qrow + p ( thisr ) if ( s ( thisr ) /= 0 ) then thisr = s ( thisr ) goto 1 end if neb = len return end if write ( nout , * ) 'not enough additional space for E.B&#94;{-1} matrix' write ( nout , * ) 'space required is at least len+m1*(mxmc+1)' write ( nout , * ) 'space left =' , nprof - len , '  len,m1 =' , len , m1 ifail = 7 9 format ( A / ( 15 I5 )) return end subroutine checkperms ( n , lr , lc , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension lr ( * ), lc ( * ), li ( * ) common / factorc / m1 , m2 , mp , mq , lastr , irow do i = 1 , n if ( lr ( li ( i )) /= i ) print * , 'wrong perm 1' if ( lr ( li ( i )) /= i ) stop if ( li ( lr ( i )) /= i ) print * , 'wrong perm 2' if ( li ( lr ( i )) /= i ) stop end do do i = m2 + 1 , n if ( li ( lc ( i )) /= i ) print * , 'wrong perm 3' if ( li ( lc ( i )) /= i ) stop end do return end subroutine checkout ( n , a , la , lr , lc , li , p , q , r , s , ws , mxws , d ) implicit double precision ( a - h , r - z ), integer ( i - q ) integer r , s , rowj , thisr dimension a ( * ), la ( * ), lr ( * ), lc ( * ), li ( * ), p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ), & d ( * ) common / factorc / m1 , nu , mp , mq , lastr , irow common / noutc / nout common / epsc / eps , tol , emin !  check indexing do j = 1 , nu if ( p ( lr ( j )) /= 0 ) then write ( nout , * ) 'p(lr(j))/=0' goto 11 end if end do np = 0 do i = nu + 1 , n if ( p ( lr ( i )) > 0 ) np = np + 1 end do if ( irow > 0 ) then if ( r ( irow ) /= 0 ) then write ( nout , * ) 'r(irow)/=0' goto 11 end if thisr = irow 1 continue if ( p ( thisr ) <= 0 ) then write ( nout , * ) 'p(thisr)<=0' goto 11 end if np = np - 1 nextr = s ( thisr ) if ( nextr == 0 ) then if ( q ( thisr ) + p ( thisr ) > mxws ) then write ( nout , * ) 'q(thisr)+p(thisr)>mxws' goto 11 end if else if ( r ( nextr ) /= thisr ) then write ( nout , * ) 'r(nextr)/=thisr' goto 11 end if if ( nextr /= s ( thisr )) then write ( nout , * ) 'nextr/=s(thisr)' goto 11 end if if ( q ( thisr ) + p ( thisr ) > q ( nextr )) then write ( nout , * ) 'q(thisr)+p(thisr)>q(nextr)' goto 11 end if thisr = nextr goto 1 end if end if if ( np /= 0 ) then write ( nout , * ) 'np/=0' goto 11 end if last = 0 emax = 0.D0 length = 0 do inode = nu + 1 , n nodec = lc ( inode ) !  form L.a_q rowj = lr ( inode ) prj = p ( rowj ) length = length + prj if ( prj < 0 ) then write ( nout , * ) 'prj<0' goto 11 else if ( prj == 0 ) then e = abs ( aij ( rowj , nodec - n , a , la ) - d ( inode )) else e = abs ( d ( inode ) - aiscpri2 ( n , a , la , rowj , nodec - n , ws ( q ( rowj ) + 1 ), & 1.D0 , inode - 1 , prj , li )) end if !       if (e>tol) write(nout,*)'error =',e, !    *    '  inode,nodec,rowj =',inode,nodec,rowj emax = max ( emax , e ) do j = inode + 1 , n rowj = lr ( j ) prj = p ( rowj ) if ( prj > 0 ) then e = abs ( aiscpri2 ( n , a , la , rowj , nodec - n , ws ( q ( rowj ) + 1 ), 1.D0 , j - 1 , & prj , li )) else e = abs ( aij ( rowj , nodec - n , a , la )) end if !         if (e>tol) write(nout,*)'error =',e, !    *      '  inode,nodec,j,rowj =',inode,nodec,j,rowj emax = max ( emax , e ) end do end do write ( nout , * ) 'checkout:  m1 =' , m1 , '  file length =' , length if ( emax > tol ) write ( nout , * ) 'error =' , emax return 11 continue write ( nout , * ) 'thisr,nextr =' , thisr , nextr write ( nout , * ) 'i,p(i),q(i),r(i),s(i):  irow =' , irow do i = 1 , n if ( p ( i ) /= 0 ) write ( nout , * ) i , p ( i ), q ( i ), r ( i ), s ( i ) end do stop end","tags":"","loc":"sourcefile/schurqr.f90.html"},{"title":"denseL.f90 – filterSD","text":"Contents Subroutines start_up refactor pivot fbsub tfbsub newg re_factor check_L aqsol eptsol c_flma r_flma permop checkout Source Code denseL.f90 Source Code !Christen this file denseL.f !  Copyright (C) 1996 Roger Fletcher !  Current version dated 4 October 2011 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT !***************** dense matrix routines for manipulating L ******************** !  *************************************************************** !  Basis matrix routines for bqpd with dense matrices (block form) !  *************************************************************** !  These routines form and update L-Implicit-U factors LPB=U of a matrix B !  whose columns are the normal vectors of the active constraints. In this !  method only the unit lower triangular matrix L and the diagonal of U (in !  addition to the row permutation P) is stored. B is represented in block form !    | A_1  0 |    where the first m1 columns (A_1 and A_2) come from the !    | A_2  I |    general constraint normals (columns of the matrix A in bqpd) !  and the remaining unit columns come from simple bounds. The matrix A may be !  specified in either dense or sparse format and the user is referred to the !  files  denseA.f  or  sparseA.f. About m1*m1/2 locations are required to store !  L-Implicit-U factors of B. The user MUST supply an upper bound on m1 by !  setting mxm1 in the labelled common block !     common/mxm1c/mxm1 !  Setting  mxm1=min(m+1,n)  is always sufficient. !  Workspace !  ********* !  denseL.f requires !     mxm1*(mxm1+1)/2+3*n+mxm1   locations of real workspace, and !     n+mxm1+n+m                 locations of integer workspace !  These are stored at the end of the workspace arrays ws and lws in bqpd. !  The user MUST set the lengths of these arrays in mxws and mxlws in !     common/wsc/kk,ll,kkk,lll,mxws,mxlws !  along with the values kk and ll of space to be used by gdotx. !  Other information !  ***************** !  L-Implicit-U factors are updated by a variant of the Fletcher-Matthews !  method, which has proved very reliable in practice. The method is described !  in the reference !    Fletcher R., Dense Factors of Sparse Matrices, in \"Approximation Theory !    and Optimization. Tributes to M.J.D. Powell\", (M.D. Buhmann and A. Iserles, !    eds), Cambridge University Press (1997), pp. 145-166. !  Steepest edge coefficients e(i) are also updated in these routines !  The file contains routines for solving systems with B or its transpose !  which might be of use in association with bqpd. These routines are !  documented below. subroutine start_up ( n , nm , nmi , a , la , nk , e , ls , aa , ll , mode , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), e ( * ), ls ( * ), aa ( * ), ll ( * ) common / noutc / nout common / wsc / kk , ll_ , kkk , lll , mxws , mxlws common / epsc / eps , tol , emin common / densec / ns , ns1 , nt , nt1 , nu , nu1 , mx1 , lc , lc1 , li , li1 common / factorc / m0 , m1 , mm0 , mm , mp , mq common / refactorc / nup , nfreq common / mxm1c / mxm1 if ( mxm1 <= 0 ) then write ( nout , * ) 'mxm1 =' , mxm1 , ' is not set correctly' ifail = 7 return end if ns = kk + kkk + mxm1 * ( mxm1 + 1 ) / 2 + 3 * n + mxm1 nt = ll_ + lll + n + mxm1 + nmi if ( ns > mxws . or . nt > mxlws ) then write ( nout , * ) 'not enough real (ws) or integer (lws) workspace' write ( nout , * ) 'you give values for mxws and mxlws as' , mxws , mxlws write ( nout , * ) 'minimum values for mxws and mxlws are' , ns , nt ifail = 7 return end if nup = 0 small = max ( 1.D1 * tol , sqrt ( eps )) smallish = max ( eps / tol , 1.D1 * small ) !  set storage map for dense factors ns = mxm1 * ( mxm1 + 1 ) / 2 ns1 = ns + 1 nt = ns + n nt1 = nt + 1 nu = nt + n nu1 = nu + 1 mx1 = nu1 + n lc = n lc1 = lc + 1 li = lc + mxm1 li1 = li + 1 !     write(nout,*)'ls',(ls(ij),ij=1,nk) !     write(nout,*)'ls',(ls(ij),ij=nm+1,nmi) if ( mode >= 3 ) then call re_factor ( n , nm , a , la , aa , aa ( ns1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) call check_L ( n , aa , ifail ) if ( ifail == 1 ) then mode = 2 goto 1 end if if ( nk == n ) return !  reset ls from e do j = 1 , nk i =- ls ( j ) if ( i > 0 ) e ( i ) =- e ( i ) end do j = 0 nk = nmi do i = 1 , nmi if ( e ( i ) /= 0.D0 ) then j = j + 1 if ( e ( i ) > 0.D0 ) then ls ( j ) = i else ls ( j ) =- i e ( i ) =- e ( i ) end if else ls ( nk ) = i nk = nk - 1 end if end do if ( j /= n ) then write ( nout , * ) 'malfunction in reset sequence in start_up' stop end if ifail = 0 return end if 1 continue if ( emin == 0.D0 ) then !  set a lower bound on e(i) emin = 1.D0 do i = 1 , nmi - n emin = max ( emin , ailen ( n , a , la , i )) end do emin = 1.D0 / emin end if do i = 1 , n e ( i ) = 1.D0 ll ( i ) = i end do do i = n + 1 , nmi e ( i ) = 0.D0 ll ( li + i ) = 0 end do !  shift designated bounds to end nn = n do j = nk , 1 , - 1 i = abs ( ls ( j )) if ( i == 0 . or . i > nmi ) then write ( nout , * ) & 'ls(j) is zero, or greater in modulus than n+m, for j =' , j ifail = 4 return end if if ( i <= n ) then ls ( j ) = ls ( nk ) nk = nk - 1 call iexch ( ll ( nn ), ll ( i )) nn = nn - 1 end if end do do i = 1 , n ll ( li + ll ( i )) = i end do m0 = ( max ( mxm1 - nk , 0 )) / 2 mm0 = m0 * ( m0 + 1 ) / 2 m1 = 0 mm = mm0 j = 1 2 continue if ( j > nk ) goto 3 q = abs ( ls ( j )) !  extend factors call aqsol ( n , a , la , q , aa , aa ( nt1 ), aa ( mx1 ), aa , ll , ll ( lc1 ), ll ( li1 )) m1p = m1 + 1 call linf ( nn - m1 , aa ( nt + m1p ), z , iz ) iz = iz + m1 if ( z <= tol ) then !         write(nout,*)'reject c/s',q nk = nk - 1 do ij = j , nk ls ( ij ) = ls ( ij + 1 ) end do goto 2 end if if ( m1p > mxm1 ) then write ( nout , * ) 'mxm1 =' , mxm1 , '  is insufficient' ifail = 7 return end if if ( iz > m1p ) then !  pivot interchange ll ( li + ll ( m1p )) = iz call iexch ( ll ( m1p ), ll ( iz )) call rexch ( aa ( nt + m1p ), aa ( nt + iz )) ll ( li + ll ( m1p )) = m1p end if p = ll ( m1p ) tp = aa ( nt + m1p ) call eptsol ( n , a , la , p , a , aa , aa ( ns1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) aa ( ns + m1p ) = 1.D0 !  update steepest edge coefficients ep = e ( p ) !       eq=ep/tp eq = abs ( ep / tp ) tp_ = tp / ep tpsq = tp_ ** 2 call aqsol ( n , a , la , - 1 , a , aa ( nu1 ), aa ( mx1 ), aa , ll , ll ( lc1 ), ll ( li1 )) do i = 1 , m1p aa ( nu + i ) = aa ( ns + i ) / ep end do do i = m1p + 1 , n aa ( nu + i ) = 0.D0 end do e ( p ) = 0.D0 do i = 1 , nmi if ( e ( i ) > 0.D0 ) then ij = ll ( li + i ) ei = e ( i ) !           ti=aa(nt+ij)*eq/ei !           e(i)=max(emin,ei*sqrt(max(1.D0-ti*(2.D0*aa(nu+ij)/ei-ti),0.D0))) ti = aa ( nt + j ) / ei e ( i ) = max ( emin , & ei * sqrt ( max ( tpsq - ti * ( 2.D0 * tp * aa ( nu + j ) / ei - ti ), 0.D0 )) * eq ) end if end do !       e(q)=max(emin,abs(eq)) e ( q ) = max ( emin , eq ) m1 = m1p mm = mm + m0 do ij = 1 , m1 aa ( mm + ij ) = aa ( ns + ij ) end do ll ( lc + m1 ) = q ll ( li + q ) = m1 mm = mm + m1 aa ( mm ) = tp j = j + 1 goto 2 3 continue !  complete the vector ls do i = nn + 1 , n nk = nk + 1 ls ( nk ) = ll ( i ) end do j = nk do i = m1 + 1 , nn j = j + 1 ls ( j ) = ll ( i ) end do do j = nm + 1 , nmi e ( abs ( ls ( j ))) = 1.D0 end do j = n do i = 1 , nmi if ( e ( i ) == 0.D0 ) then j = j + 1 ls ( j ) = i end if end do do j = nm + 1 , nmi e ( abs ( ls ( j ))) = 0.D0 end do if ( mode > 2 ) then z = sqrt ( eps ) do j = 1 , n i = abs ( ls ( j )) e ( i ) = max ( z , e ( i )) end do do j = n + 1 , nmi i = abs ( ls ( j )) e ( i ) = 0.D0 end do end if !     write(nout,*)'e =',(e(ij),ij=1,nmi) !     write(nout,*)'PAQ factors' !     ij=mm0+m0 !     do ii=1,m1 !       write(nout,*)(aa(ij+j),j=1,ii) !       ij=ij+m0+ii !     end do !     write(nout,*)'m0,mm0,m1,mm',m0,mm0,m1,mm !     write(nout,*)'ls',(ls(ij),ij=1,nmi) !     write(nout,*)'row perm',(ll(ij),ij=1,n) !     write(nout,*)'column perm',(ll(lc+ij),ij=1,m1) !     write(nout,*)'inverse perm',(ll(li+ij),ij=1,nmi) !     call checkout(n,a,la,aa,ll,ll(lc1),ll(li1)) mp =- 1 mq =- 1 ifail = 0 return end subroutine refactor ( n , nm , a , la , aa , ll , ifail ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( * ), aa ( * ), ll ( * ) common / densec / ns , ns1 , nt , nt1 , nu , nu1 , mx1 , lc , lc1 , li , li1 common / factorc / m0 , m1 , mm0 , mm , mp , mq !     write(nout,*)'refactor' call re_factor ( n , nm , a , la , aa , aa ( ns1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) call check_L ( n , aa , ifail ) return end subroutine pivot ( p , q , n , nm , a , la , e , aa , ll , ifail , info ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), e ( * ), aa ( * ), ll ( * ), info ( * ) common / noutc / nout common / iprintc / iprint common / densec / ns , ns1 , nt , nt1 , nu , nu1 , mx1 , lc , lc1 , li , li1 common / factorc / m0 , m1 , mm0 , mm , mp , mq common / mxm1c / mxm1 common / refactorc / nup , nfreq common / epsc / eps , tol , emin !     write(nout,*)'pivot: p,q =',p,q ifail = 0 if ( p /= mp ) then call eptsol ( n , a , la , p , a , aa , aa ( ns1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) e ( p ) = sqrt ( scpr ( 0.D0 , aa ( ns1 ), aa ( ns1 ), m1 + 1 )) mp = p end if if ( q /= mq ) then call aqsol ( n , a , la , q , a , aa ( nt1 ), aa ( mx1 ), aa , ll , ll ( lc1 ), ll ( li1 )) mq = q end if !  update steepest edge coefficients tp = aa ( nt + ll ( li + p )) if ( tp == 0.D0 ) tp = eps ep = e ( p ) !     eq=ep/tp eq = abs ( ep / tp ) tp = tp / ep tpsq = tp ** 2 do i = 1 , m1 + 1 aa ( nu + i ) = aa ( ns + i ) / ep end do do i = m1 + 2 , n aa ( nu + i ) = 0.D0 end do call aqsol ( n , a , la , - 1 , a , aa ( nu1 ), aa ( mx1 ), aa , ll , ll ( lc1 ), ll ( li1 )) !     write(nout,*)'row perm',(ll(ij),ij=1,n) !     write(nout,*)'column perm',(ll(lc+ij),ij=1,m1) !     write(nout,*)'s =',(aa(ns+ij),ij=1,n) !     write(nout,*)'t =',(aa(nt+ij),ij=1,n) !     write(nout,*)'u =',(aa(nu+ij),ij=1,n) e ( p ) = 0.D0 do i = 1 , nm if ( e ( i ) > 0.D0 ) then j = ll ( li + i ) ei = e ( i ) !         ti=aa(nt+j)*eq/ei !         e(i)=max(emin,ei*sqrt(max(1.D0-ti*(2.D0*aa(nu+j)/ei-ti),0.D0))) ti = aa ( nt + j ) / ei e ( i ) = max ( emin , & ei * sqrt ( max ( tpsq - ti * ( 2.D0 * tp * aa ( nu + j ) / ei - ti ), 0.D0 )) * eq ) end if end do !     e(q)=max(emin,abs(eq)) e ( q ) = max ( emin , eq ) info ( 1 ) = info ( 1 ) + 1 if ( nup >= nfreq ) then !  refactorize L ip = ll ( li + p ) if ( p > n ) then qq = ll ( lc + m1 ) ll ( lc + ip ) = qq ll ( li + qq ) = ip m1 = m1 - 1 ll ( li + p ) = 0 else m1p = m1 + 1 ll ( ip ) = ll ( m1p ) ll ( li + ll ( ip )) = ip ll ( m1p ) = p ll ( li + p ) = m1p end if if ( q > n ) then if ( m1 == mxm1 ) then ifail = 7 return end if m1 = m1 + 1 ll ( lc + m1 ) = q ll ( li + q ) = m1 else iq = ll ( li + q ) m1p = m1 + 1 ll ( iq ) = ll ( m1p ) ll ( li + ll ( iq )) = iq ll ( m1p ) = q ll ( li + q ) = m1p end if call re_factor ( n , nm , a , la , aa , aa ( ns1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) else !  update L nup = nup + 1 if ( p <= n ) then if ( m1 == mxm1 ) then ifail = 7 return end if call linf ( m1 , aa ( ns1 ), z , iz ) if ( z <= 4.D0 ) then if ( m0 + m1 == mxm1 ) then !             write(nout,*)'m0 + m1 = mxm1:  re-centre triangle' ii = mm0 mo = m0 m0 = m0 / 2 mm0 = m0 * ( m0 + 1 ) / 2 mm = mm0 do i = 1 , m1 ii = ii + mo + i mm = mm + m0 + i do j = 1 - i , 0 aa ( mm + j ) = aa ( ii + j ) end do end do end if do i = 1 , m1 aa ( mm + m0 + i ) = aa ( ns + i ) end do goto 1 end if end if call c_flma ( n , a , la , p , aa , ll , ll ( lc1 ), ll ( li1 )) 1 continue if ( q <= n ) then call r_flma ( n , a , la , q , aa , ll , ll ( lc1 ), ll ( li1 )) else m1 = m1 + 1 mm = mm + m0 + m1 aa ( mm ) = 1.D0 aa ( mm ) = aiscpri1 ( n , a , la , q - n , aa ( mm - m1 + 1 ), 0.D0 , ll , ll ( li1 ), m1 ) if ( abs ( aa ( mm )) <= eps ) aa ( mm ) = eps ll ( lc + m1 ) = q ll ( li + q ) = m1 end if mp =- 1 mq =- 1 end if call check_L ( n , aa , ifail ) !     write(nout,*)'PAQ factors' !     ij=m0+mm0 !     do ii=1,m1 !       write(nout,*)(aa(ij+j),j=1,ii) !       ij=ij+m0+ii !     end do !     write(nout,*)'m0,mm0,m1,mm',m0,mm0,m1,mm !     write(nout,*)'row perm',(ll(ij),ij=1,n) !     write(nout,*)'column perm',(ll(lc+ij),ij=1,m1) !     write(nout,*)'inverse perm',(ll(li+ij),ij=1,nm) !     call checkout(n,a,la,aa,ll,ll(lc1),ll(li1)) !     write(nout,*)'steepest edge coefficients',(e(ij),ij=1,nm) !     emax=0.D0 !     do i=1,nm !       if (e(i)>0.D0) then !         call eptsol(n,a,la,i,a,aa,aa(ns1),aa(nt1),ll,ll(lc1),ll(li1)) !         ei=sqrt(scpr(0.D0,aa(ns1),aa(ns1),n)) !         emax=max(emax,abs(ei-e(i))) !       end if !     end do !     if (emax>=tol) !    *  write(nout,*)'error in steepest edge coefficients =',emax return end subroutine fbsub ( n , jmin , jmax , a , la , q , b , x , ls , aa , ll , save ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical save dimension a ( * ), la ( * ), b ( * ), x ( * ), ls ( * ), aa ( * ), ll ( * ) !  solves a system  B.x=b !  Parameter list !  ************** !   n   number of variables (as for bqpd) !   a,la   specification of QP problem data (as for bqpd) !   jmin,jmax  (see description of ls below) !   q   an integer which, if in the range 1:n+m, specifies that the rhs vector !       b is to be column q of the matrix A of general constraint normals. !       In this case the parameter b is not referenced by fbsub. !       If q=0 then b is taken as the vector given in the parameter b. !   b(n)  must be set to the r.h.s. vector b (but only if q=0) !   x(n+m)  contains the required part of the solution x, set according to the !       index number of that component (in the range 1:n for a simple bound and !       n+1:n+m for a general constraint) !   ls(*)  an index vector, listing the components of x that are required. !       Only the absolute value of the elements of ls are used (this allows !       the possibility of using of the contents of the ls parameter of bqpd). !       Elements of x in the range abs(ls(j)), j=jmin:jmax are set by fbsub. !       These contortions allow bqpd to be independent of the basis matrix code. !   aa(*)  real storage used by the basis matrix code (supply the vector !       ws(lu1) with ws as in the call of bqpd and lu1 as in common/bqpdc/...) !   ll(*)  integer storage used by the basis matrix code (supply the vector !       lws(ll1) with lws as in the call of bqpd and ll1 as in common/bqpdc/...) !   save   indicates if fbsub is to save its copy of the solution for possible !       future use. We suggest that the user only sets save = .false. common / noutc / nout common / densec / ns , ns1 , nt , nt1 , nu , nu1 , mx1 , lc , lc1 , li , li1 common / factorc / m0 , m1 , mm0 , mm , mp , mq !     write(nout,*)'fbsub  q =',q if ( save ) then if ( q /= mq ) then call aqsol ( n , a , la , q , b , aa ( nt1 ), aa ( mx1 ), aa , ll , ll ( lc1 ), ll ( li1 )) mq = q end if do j = jmin , jmax i = abs ( ls ( j )) x ( i ) = aa ( nt + ll ( li + i )) end do else call aqsol ( n , a , la , q , b , aa ( nu1 ), aa ( mx1 ), aa , ll , ll ( lc1 ), ll ( li1 )) do j = jmin , jmax i = abs ( ls ( j )) x ( i ) = aa ( nu + ll ( li + i )) end do end if return end subroutine tfbsub ( n , a , la , p , b , x , aa , ll , ep , save ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical save dimension a ( * ), la ( * ), b ( * ), x ( * ), aa ( * ), ll ( * ) !  solves a system  Bt.x=b !  Parameter list !  ************** !   n   number of variables (as for bqpd) !   a,la   specification of QP problem data (as for bqpd) !   p    an integer which, if in the range 1:n+m, specifies that the rhs vector !        b is a unit vector appropriate to the position of p in the current !        ordering. In this case b is not referenced by tfbsub. !   b(n+m)  If p=0, this must be set to the r.h.s. vector b. Only the components !        of b need be set, according to the index number of each component (in !        the range 1:n for a simple bound and n+1:n+m for a general constraint) !   x(n)  contains the solution x (in natural ordering) !   aa(*)  real storage used by the basis matrix code (supply the vector !       ws(lu1) with ws as in the call of bqpd and lu1 as in common/bqpdc/...) !   ll(*)  integer storage used by the basis matrix code (supply the vector !       lws(ll1) with lws as in the call of bqpd and ll1 as in common/bqpdc/...) !   ep  if p/=0 and save is true, ep contains the l_2 length of x on exit !   save  indicates if tfbsub is to save its copy of the solution for possible !       future use. We suggest that the user only sets save = .false. common / noutc / nout common / densec / ns , ns1 , nt , nt1 , nu , nu1 , mx1 , lc , lc1 , li , li1 common / factorc / m0 , m1 , mm0 , mm , mp , mq !     write(nout,*)'tfbsub  p =',p if ( save ) then if ( p /= mp ) then call eptsol ( n , a , la , p , b , aa , aa ( ns1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) mp = p end if do i = 1 , n x ( ll ( i )) = aa ( ns + i ) end do if ( p > 0 ) ep = sqrt ( scpr ( 0.D0 , aa ( ns1 ), aa ( ns1 ), m1 + 1 )) else call eptsol ( n , a , la , p , b , aa , aa ( nu1 ), aa ( nt1 ), ll , ll ( lc1 ), ll ( li1 )) do i = 1 , n x ( ll ( i )) = aa ( nu + i ) end do end if !     write(nout,*)'x =',(x(i),i=1,n) return end subroutine newg common / factorc / m0 , m1 , mm0 , mm , mp , mq mq =- 1 return end !******** The following routines are internal to denseL.f ************** subroutine re_factor ( n , nm , a , la , T , sn , tn , lr , lc , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), T ( * ), sn ( * ), tn ( * ), lr ( * ), lc ( * ), li ( * ) common / noutc / nout common / iprintc / iprint common / refactorc / nup , nfreq common / factorc / m0 , m1 , mm0 , mm , mp , mq common / mxm1c / mxm1 common / epsc / eps , tol , emin !     write(nout,*)'re_factor' nup = 0 if ( m1 == 0 ) return m0 = ( mxm1 - m1 ) / 2 mm0 = m0 * ( m0 + 1 ) / 2 !     write(nout,*)'row perm',(lr(ij),ij=1,n) !     write(nout,*)'column perm',(lc(ij),ij=1,m1) do i = 1 , m1 sn ( i ) = 0.D0 end do mm = mm0 do i = 1 , m1 - 1 mm = mm + m0 + i im = i - 1 i1 = mm - im q = lc ( i ) - n if ( q <= 0 ) goto 1 !  form L.a_q call iscatter ( a , la , q , li , sn , n ) !       write(nout,*)'aq =',(sn(ij),ij=1,m1) jj = mm j1 = i1 do j = i , m1 tn ( j ) = scpr ( sn ( j ), T ( j1 ), sn , im ) j1 = jj + m0 + 1 jj = j1 + j end do call iunscatter ( a , la , q , li , sn , n ) !       write(nout,*)'L.aq =',(tn(ij),ij=i,m1) call linf ( m1 - im , tn ( i ), z , iz ) if ( iz > 1 ) then !  pivot interchange iz = iz - 1 call vexch ( T ( i1 ), T ( i1 + iz * ( m0 + i ) + iz * ( iz - 1 ) / 2 ), im ) iz = iz + i call rexch ( tn ( i ), tn ( iz )) li ( lr ( i )) = iz call iexch ( lr ( i ), lr ( iz )) li ( lr ( i )) = i end if if ( tn ( i ) == 0.D0 ) tn ( i ) = eps !  update L j1 = i1 + m0 + i zz =- tn ( i ) do j = i + 1 , m1 z = tn ( j ) / zz call mysaxpy ( z , T ( i1 ), T ( j1 ), i - 1 ) T ( j1 + im ) = z !         write(nout,*)'L(j) =',(T(ij),ij=j1,j1+im) j1 = j1 + m0 + j end do T ( mm ) =- zz end do mm = mm + m0 + m1 q = lc ( i ) - n if ( q <= 0 ) goto 1 call iscatter ( a , la , q , li , sn , n ) T ( mm ) = scpr ( sn ( m1 ), T ( mm - m1 + 1 ), sn , m1 - 1 ) if ( T ( mm ) == 0.D0 ) T ( mm ) = eps !     write(nout,*)'PAQ factors' !     ij=mm0+m0 !     do ii=1,m1 !       write(nout,*)(T(ij+j),j=1,ii) !       ij=ij+m0+ii !     end do !     write(nout,*)'m0,mm0,m1,mm',m0,mm0,m1,mm !     write(nout,*)'row perm',(lr(ij),ij=1,n) !     write(nout,*)'column perm',(lc(ij),ij=1,m1) !     write(nout,*)'inverse perm',(li(ij),ij=1,nm) !     call checkout(n,a,la,T,lr,lc1,li) mp =- 1 mq =- 1 return 1 continue write ( nout , * ) 'malfunction in re_factor:  i,lc(i) =' , i , q + n stop end subroutine check_L ( n , T , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension T ( * ) common / noutc / nout common / factorc / m0 , m1 , mm0 , mm , mp , mq common / epsc / eps , tol , emin !     write(nout,*)'check_L' ifail = 1 kk = mm0 !     dmin=1.D37 do k = 1 , m1 kk = kk + m0 + k !       dmin=min(dmin,abs(T(kk))) if ( abs ( T ( kk )) <= tol ) return end do !     write(nout,*)'dmin =',dmin ifail = 0 return end subroutine aqsol ( n , a , la , q , b , tn , xm , T , lr , lc , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), b ( * ), tn ( * ), xm ( * ), T ( * ), lr ( * ), lc ( * ), li ( * ) common / noutc / nout common / factorc / m0 , m1 , mm0 , mm , mp , mq !     write(nout,*)'aqsol  q =',q if ( q > 0 ) then do i = 1 , n tn ( i ) = 0.D0 end do if ( q <= n ) then tn ( li ( q )) = 1.D0 else !         call isaipy(1.D0,a,la,q-n,tn,n,lr,li) call iscatter ( a , la , q - n , li , tn , n ) end if else if ( q == 0 ) then do i = 1 , n tn ( li ( i )) = b ( i ) end do end if !     write(nout,*)'tn =',(tn(i),i=1,n) ii = mm do i = m1 , 1 , - 1 xm ( i ) = ( scpr ( tn ( i ), T ( ii - i + 1 ), tn , i - 1 )) / T ( ii ) call isaipy ( - xm ( i ), a , la , lc ( i ) - n , tn , n , lr , li ) ii = ii - m0 - i end do do i = 1 , m1 tn ( i ) = xm ( i ) end do !     write(nout,*)'tn =',(tn(i),i=1,n) return end subroutine eptsol ( n , a , la , p , b , T , sn , tn , lr , lc , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), b ( * ), T ( * ), sn ( * ), tn ( * ), lr ( * ), lc ( * ), li ( * ) common / noutc / nout common / iprintc / iprint common / epsc / eps , tol , emin common / factorc / m0 , m1 , mm0 , mm , mp , mq !     write(nout,*)'eptsol  p =',p !     if (p==9) then !         write(nout,9)'row perm',(lr(ij),ij=1,n) !         write(nout,9)'column perm',(lc(ij),ij=1,m1) !         write(nout,9)'inverse perm',(li(ij),ij=1,p) !   9     format(A/(15I5)) !     end if if ( p > n ) then pr = li ( p ) if ( pr <= 0 ) print * , 'here1' if ( pr <= 0 ) goto 1 if ( pr /= m1 ) then z = tn ( pr ) call r_shift ( tn ( pr ), m1 - pr , 1 ) tn ( m1 ) = z call c_flma ( n , a , la , p , T , lr , lc , li ) m1 = m1 + 1 mm = mm + m0 + m1 li ( p ) = m1 lc ( m1 ) = p T ( mm ) = 1.D0 T ( mm ) = aiscpri1 ( n , a , la , p - n , T ( mm - m1 + 1 ), 0.D0 , lr , li , m1 ) if ( T ( mm ) == 0.D0 ) T ( mm ) = eps !         write(nout,*)'PAQ factors' !         ij=m0+mm0 !         do ii=1,m1 !           write(nout,*)(T(ij+j),j=1,ii) !           ij=ij+m0+ii !         end do !         write(nout,*)'m0,mm0,m1,mm',m0,mm0,m1,mm !         write(nout,*)'row perm',(lr(ij),ij=1,n) !         write(nout,*)'column perm',(lc(ij),ij=1,m1) !         write(nout,*)'inverse perm',(li(ij),ij=1,p) !         call checkout(n,a,la,T,lr,lc,li) end if ii = mm - m1 z = 1.D0 / T ( mm ) do i = 1 , m1 - 1 sn ( i ) = T ( ii + i ) * z end do sn ( m1 ) = z do i = m1 + 1 , n sn ( i ) = 0.D0 end do else ii = m0 + mm0 if ( p == 0 ) then do i = 1 , m1 sn ( i ) = 0.D0 end do do i = m1 + 1 , n sn ( i ) = b ( lr ( i )) end do do i = 1 , m1 ii = ii + i j = lc ( i ) sn ( i ) =- aiscpri ( n , a , la , j - n , sn , - b ( j ), lr , li ) / T ( ii ) call mysaxpy ( sn ( i ), T ( ij ), sn , i - 1 ) ii = ii + m0 ij = ii + 1 end do else pr = li ( p ) if ( pr <= m1 ) print * , 'here2' if ( pr <= m1 ) goto 1 m1p = m1 + 1 call iexch ( lr ( pr ), lr ( m1p )) call iexch ( li ( lr ( pr )), li ( lr ( m1p ))) call rexch ( tn ( pr ), tn ( m1p )) do i = 1 , n sn ( i ) = 0.D0 end do sn ( m1p ) = 1.D0 do i = 1 , m1 ii = ii + i sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , 0.D0 , lr , li ) / T ( ii ) call mysaxpy ( sn ( i ), T ( ij ), sn , i - 1 ) ii = ii + m0 ij = ii + 1 end do end if end if !     write(nout,*)'sn =',(sn(i),i=1,n) return 1 continue write ( nout , * ) 'malfunction detected in eptsol: p =' , p stop end subroutine c_flma ( n , a , la , q , T , lr , lc , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), T ( * ), lr ( * ), lc ( * ), li ( * ) common / noutc / nout common / mxm1c / mxm1 common / epsc / eps , tol , emin common / factorc / m0 , m1 , mm0 , mm , mp , mq double precision l21 !     write(nout,*)'c_flma: q =',q qc = li ( q ) if ( q > n ) then if ( qc <= 0 ) goto 1 call ishift ( lc ( qc ), m1 - qc , 1 ) do j = qc , m1 - 1 li ( lc ( j )) = j end do li ( q ) = 0 mm = mm - m1 - m0 m1 = m1 - 1 else if ( qc <= m1 ) goto 1 call iexch ( lr ( qc ), lr ( m1 + 1 )) call iexch ( li ( lr ( qc )), li ( lr ( m1 + 1 ))) call ishift ( lr ( 2 ), m1 , - 1 ) lr ( 1 ) = q do i = 1 , m1 + 1 li ( lr ( i )) = i end do if ( m0 == 0 ) then !         write(nout,*)'m0 = 0:  re-centre triangle' m0 = ( mxm1 + 1 - m1 ) / 2 mm0 = m0 * ( m0 + 1 ) / 2 ii = mm mm = ( m0 + m1 ) * ( m0 + m1 + 1 ) / 2 ii = ii - mm ij = mm + m0 + 1 do i = m1 , 1 , - 1 ij = ij - m0 - i call r_shift ( T ( ij ), i , ii ) ii = ii + m0 end do end if mm = mm - m0 - m1 m0 = m0 - 1 do i = 1 , m1 mm0 = mm0 + m0 + i T ( mm0 ) = 0.D0 end do mm0 = m0 * ( m0 + 1 ) / 2 qc = 1 end if iswap = 0 ii = ( qc + m0 ) * ( qc + m0 + 1 ) / 2 do i = qc , m1 im = i + m0 ii1 = ii + m0 + 1 iip = ii1 + i T ( ii ) = 1.D0 u21 = T ( iip ) u11 = aiscpri1 ( n , a , la , lc ( i ) - n , T ( ii1 - im ), 0.D0 , lr , li , i ) ij = ii + im - iswap !       write(nout,*)'i,im,ii,iip,iswap,ij',i,im,ii,iip,iswap,ij l21 = T ( ij ) if ( abs ( l21 ) <= eps ) l21 = 0.D0 if ( iswap > 0 ) call r_shift ( T ( ij ), iswap , 1 ) del = u21 - l21 * u11 !       write(nout,*)'l21,u11,u21,del =',l21,u11,u21,del !       write(nout,*)'old row =',(T(j),j=ii1-im,ii) !       write(nout,*)'new row =',(T(j),j=ii1,ii+im) if ( abs ( del ) <= abs ( u11 ) * max ( 1.D0 , abs ( l21 ))) then !         if (u11==0.D0) then !           r=0.D0 !         else if ( u11 == 0.D0 ) u11 = eps r =- u21 / u11 if ( abs ( r ) <= eps ) r = 0.D0 call mysaxpy ( r , T ( ii1 - im ), T ( ii1 ), i - 1 ) !         end if T ( ii ) = u11 T ( ii + im ) = l21 + r if ( iswap > 0 ) then do j = im + 1 , m0 + m1 ij = ij + j r = T ( ij ) call r_shift ( T ( ij ), iswap , 1 ) T ( ij + iswap ) = r end do end if iswap = 0 else r =- u11 / del if ( abs ( r ) <= eps ) r = 0.D0 call permop ( T ( ii1 - im ), T ( ii1 ), r , - l21 , i - 1 ) T ( ii ) = del T ( ii + im ) = r call iexch ( lr ( i ), lr ( i + 1 )) call iexch ( li ( lr ( i )), li ( lr ( i + 1 ))) iswap = iswap + 1 end if ii = iip end do return 1 continue write ( nout , * ) 'malfunction detected in c_flma: q =' , q stop end subroutine r_flma ( n , a , la , p , T , lr , lc , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), T ( * ), lr ( * ), lc ( * ), li ( * ) common / noutc / nout common / epsc / eps , tol , emin common / factorc / m0 , m1 , mm0 , mm , mp , mq double precision l11 !     write(nout,*)'r_flma: p =',p pr = li ( p ) if ( pr > m1 ) then if ( pr == m1 + 1 ) return write ( nout , * ) 'malfunction detected in r_flma: p =' , p stop end if ii = ( pr + m0 ) * ( pr + m0 + 1 ) / 2 u11 = T ( ii ) T ( ii ) = 1.D0 ip = ii do i = pr , m1 - 1 im = i + m0 ii1 = ii + m0 + 1 iip = ii1 + i u22 = T ( iip ) l11 =- T ( ip + im ) / T ( ip ) if ( abs ( l11 ) <= eps ) l11 = 0.D0 u12 = aiscpri1 ( n , a , la , lc ( i + 1 ) - n , T ( ii1 - im ), 0.D0 , lr , li , i ) del = l11 * u12 + u22 !       write(nout,*)'l11,u11,u12,u22,del',l11,u11,u12,u22,del !       write(nout,*)'old row =',(T(j),j=ii1-im,ii) !       write(nout,*)'new row =',(T(j),j=ii1,ii+im) if ( abs ( del ) <= abs ( l11 ) * max ( abs ( u11 ), abs ( u12 ))) then call saxpyx ( l11 , T ( ii1 - im ), T ( ii1 ), i ) u11 = l11 * u11 if ( u11 == 0.D0 ) u11 = eps T ( iip ) = 1.D0 else r =- u12 / del if ( abs ( r ) <= eps ) r = 0.D0 call permop ( T ( ii1 - im ), T ( ii1 ), r , l11 , i ) call iexch ( lc ( i ), lc ( i + 1 )) call iexch ( li ( lc ( i )), li ( lc ( i + 1 ))) T ( iip ) = r u22 = u11 * u22 / del u11 = del end if call r_shift ( T ( ip ), i - pr , 1 ) T ( ii ) = u11 u11 = u22 ip = ip + im ii = iip end do call ishift ( lr ( pr ), m1 - pr + 1 , 1 ) lr ( m1 + 1 ) = p do j = pr , m1 + 1 li ( lr ( j )) = j end do !     if (T(ip)==0.D0)T(ip)=eps l11 =- T ( ip + m0 + m1 ) / T ( ip ) call saxpyx ( l11 , T ( mm - m1 + 1 ), T ( mm + m0 + 1 ), m1 ) call r_shift ( T ( ip ), m1 - pr , 1 ) T ( mm ) = l11 * u11 if ( T ( mm ) == 0.D0 ) T ( mm ) = eps return end subroutine permop ( v1 , v2 , r , s , n ) implicit double precision ( a - h , o - z ) dimension v1 ( * ), v2 ( * ) common / noutc / nout if ( s == 0 ) then if ( r == 0 ) then call vexch ( v1 , v2 , n ) else do i = 1 , n z = v2 ( i ) v2 ( i ) = v1 ( i ) + r * z v1 ( i ) = z end do end if else if ( r == 0 ) then do i = 1 , n z = v1 ( i ) v1 ( i ) = v2 ( i ) + s * z v2 ( i ) = z end do else do i = 1 , n z = v1 ( i ) v1 ( i ) = v2 ( i ) + s * z v2 ( i ) = z + r * v1 ( i ) end do end if end if return end subroutine checkout ( n , a , la , T , lr , lc , li ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( * ), T ( * ), lr ( * ), lc ( * ), li ( * ) common / noutc / nout common / mxm1c / mxm1 common / epsc / eps , tol , emin common / factorc / m0 , m1 , mm0 , mm , mp , mq emax = 0.D0 gmax = 0.D0 ii = mm0 do i = 1 , m1 ii1 = ii + m0 + 1 ii = ii + m0 + i d = T ( ii ) T ( ii ) = 1.D0 do j = 1 , i - 1 e = aiscpri1 ( n , a , la , lc ( j ) - n , T ( ii1 ), 0.D0 , lr , li , i ) emax = max ( emax , abs ( e )) gmax = max ( gmax , abs ( T ( ii + m0 + j ))) end do e = aiscpri1 ( n , a , la , lc ( i ) - n , T ( ii1 ), - d , lr , li , i ) emax = max ( emax , abs ( e )) T ( ii ) = d end do !     if (emax>tol .or. gmax>1.D1) !    *  write(nout,*)'error in LA=U is ',emax,'  growth in L =',gmax write ( nout , * ) 'error in LA=U is ' , emax , '  growth in L =' , gmax return end","tags":"","loc":"sourcefile/densel.f90.html"},{"title":"qlcpd.f90 – filterSD","text":"Contents Subroutines qlcpd stmapq setfg2 checkq Source Code qlcpd.f90 Source Code !Christen this file qlcpd.f !ut here >>>>>>>>>>>>>>>>> !  Copyright (C) 2010 Roger Fletcher !  Current version dated 18 April 2013 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT subroutine qlcpd ( n , m , k , kmax , maxg , a , la , x , bl , bu , f , fmin , g , r , w , e , ls , & alp , lp , mlp , peq , ws , lws , v , nv , linear , rgtol , m0de , ifail , mxgr , iprint , & nout ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical linear !  This routine finds a KT point for the Quadratic LCP (QP) problem !       minimize    f(x) = ct.x + xt.G.x/2 !       subject to  l <= [I : A]t.x <= u                  (t = transpose) !  where x and c are n-vectors, G is a symmetric n*n matrix, and A is an !  n*m matrix. If G is also positive semi-definite then the KT point is a !  global solution, else usually a local solution. The method may also be !  used efficiently to solve an LP problem (G=0). A recursive form of an !  active set method is used, using Wolfe's method to resolve degeneracy. !  A limited memory sweep method is used for minimization in the null space. !  Matrix information is made available and processed by calls to external !  subroutines. Details of these are given in an auxiliary file named either !  'denseL.f' or 'schurQR.f'. (schurQR.f is a more recent replacement for !  the file sparseL.f) !  parameter list  (variables in a line starting with C must be set on entry) !  ************** !  n     number of variables !  m     number of general constraints (columns of A) !  k     dimension of the null space obtained by eliminating the active !        constraints (only to be set if mode>=2). The number of constraints in !        the active set is n-k !  kmax  maximum value of k (kmax <= n) !  maxg  max number of reduced gradient vectors stored in sweep method: !        (1 < maxg <= kmax+1), typically maxg = min(6,kmax+1) !  a(*)  storage of reals associated with c and A. This storage may be provided !        in either dense or sparse format. Refer to either denseA.f or sparseA.f !        for information on how to set a(*) and la(*). !  la(*) storage of integers associated with c and A !  x(n)  contains the vector of variables. Initially an estimate of the solution !        must be set, replaced by the solution (if it exists) on exit. !  bl(n+m)  vector of lower bounds for variables and general constraints !  bu(n+m)  vector of upper bounds (use numbers less than about 1.e30, and !        where possible supply realistic bounds on the x variables) !  f     returns the value of f(x) when x is a feasible solution !        Otherwise f stores the sum of constraint infeasibilities !  fmin  set a strict lower bound on f(x) (used to identify an unbounded LCP) !  g(n)  returns the gradient vector of f(x) when x is feasible !  r(n+m) workspace: stores constraint residuals (or multipliers if the !        constraint is active). The sign convention is such that these are !        nonnegative at a solution (except multipliers of equality constraints) !  w(n+m) workspace: stores denominators for ratio tests !  e(n+m) stores steepest-edge normalization coefficients: if mode>2 then !        information in this vector from a previous call should not be changed. !        (In mode 3 these values provide approximate coefficients) !  ls(n+m) stores indices of the active constraints in locations 1:n and of !        the inactive constraints in locations n+1:n+m. The simple bounds !        on the variables are indexed by 1:n and the general constraints by !        n+1:n+m. The sign of ls(j) indicates whether the lower bound (+) or !        the upper bound (-) of constraint ls(j) is currently significant. !        Within the set of active constraints, locations 1:peq store the indices !        of any equality constraints, locations peq+1:n-k store the indices of !        any inequality constraints, and locations n-k+1 store the indices of !        any free variables (variables not on a bound, which are used to !        parametrise the null space: ls(j) is always positive in this range) !          If mode>=2, the first n-k elements of ls must be set on entry !  alp(mlp) workspace associated with recursion !  lp(mlp)  list of pointers to recursion information in ls !  mlp   maximum number of levels of recursion allowed (mlp>2: typically !        mlp=20 would usually be adequate but mlp=m is an upper bound) !  peq   pointer to the end of equality constraint indices in ls !  ws(*) real workspace for gdotx (see below), qlcpd and denseL.f (or schurQR.f) !          Set the total number in mxws (see \"Common\" below). !  lws(*) integer workspace for gdotx, qlcpd and denseL.f (or schurQR.f). !          Set the total number in mxlws (see \"Common\" below). !        The storage maps for ws and lws are set by the routine stmapq below !  v(maxg) set nv estimates of the eigenvalues of the reduced Hessian of f(x) !          (for example from a previous run of qlcpd). Set nv=1 and v(1)=1.D0 !          in absence of other information. New values of v are left on exit !  nv    Number of estimates in v !  linear  (logical) set linear = .true. iff the problem is an LP !  rgtol required accuracy in the reduced gradient l2 norm: it is advisable not !        to seek too high accuracy - rgtol may be increased by the code if it !        is deemed to be too small, see the definition of sgnf below !  m0de  mode of operation (larger numbers imply extra information): !          0 = cold start (no other information available, takes simple !                bounds for the initial active set) !          1 = as 0 but includes all equality constraints in initial active set !          2 = user sets n-k active constraint indices in ls(j), j=1,..,n-k. !                For a general constraint the sign of ls(j) indicates which !                bound to use. For a simple bound the current value of x is used !          3 = takes active set and other information from a previous call. !                Steepest edge weights are approximated using previous values. !          4 = as 3 but it is also assumed that A is unchanged so !                that factors of the basis matrix stored in ws and lws are valid !                (changes in the vectors c, l, u and the matrix G are allowed) !        A local copy (mode) of m0de is made and may be changed by qlcpd !  ifail   outcome of the process !              0 = solution obtained !              1 = unbounded problem detected (f(x)<=fmin would occur) !              2 = bl(i) > bu(i) for some i !              3 = infeasible problem detected in Phase 1 !              4 = line search cannot improve f (possibly increase rgtol) !              5 = mxgr gradient calls exceeded (this test is only carried !                    out at the start of each iteration) !              6 = incorrect setting of m, n, kmax, maxg, mlp, mode or tol !              7 = not enough space in ws or lws !              8 = not enough space in lp (increase mlp) !              9 = dimension of reduced space too large (increase kmax) !             10 = maximum number of unsuccessful restarts taken !          >  10 = crash in pivot call !  mxgr  maximum number of gradient evaluations !  iprint  switch for diagnostic printing (0 = off, 1 = summary, !                 2 = scalar information, 3 = verbose) !  nout  channel number for output !  Common !  ****** !  User information about the lengths of ws and lws is supplied to qlcpd in !    common/wsc/kk,ll,kkk,lll,mxws,mxlws !  kk and ll refer to the length of ws and lws needed by gdotx. !  kkk and lll are the numbers of locations used by qlcpd and are set by qlcpd. !  the rest of ws and lws is used by the files denseL.f or schurQR.f !  mxws and mxlws must be set to the total length of ws and lws available: a !  message will be given if more storage is needed. !  User subroutine !  *************** !  The user must provide a subroutine to calculate the vector v := G.x from a !  given vector x. The header of the routine is !            subroutine gdotx(n,x,ws,lws,v) !            implicit double precision(a-h,o-z) !            dimension x(*),ws(*),lws(*),v(*) !  In the case that linear is .true. the subroutine is not called by qlcpd and !  a dummy routine may be supplied. Otherwise the user may use the parameters !  ws and lws (see above) for passing real or integer arrays relating to G. !  Locations ws(1),...,ws(kk) are available to the user for storing any real !  information to be used by gdotx. Likewise locations lws(1),...,lws(ll) are !  available for storing any integer information. Default values are kk=ll=0. !  Any other setting is made by changing  common/wsc/kk,ll,kkk,lll,mxws,mxlws !  Tolerances and accuracy !  *********************** !  qlcpd uses tolerance and accuracy information stored in !     common/epsc/eps,tol,emin !     common/repc/sgnf,nrep,npiv,nres !     common/refactorc/mc,mxmc !     common/infoc/rgnorm,vstep,iter,npv,ngr !  eps must be set to the machine precision (unit round-off) and tol is a !  tolerance such that numbers whose absolute value is less than tol are !  truncated to zero. This tolerance strategy in the code assumes that the !  problem is well-scaled and a pre-scaling routine cscale is supplied in !  denseA.f or sparseA.f. The parameter sgnf is used to measure the maximum !  allowable relative error in gradient values. If at any stage the accuracy !  requirement rgtol < sgnf*rgnorm then rgtol is increased to sgnf*rgnorm !    The code allows one or more refinement steps after the !  calculation has terminated, to improve the accuracy of the solution, !  and a fixed number nrep of such repeats is allowed. However the code !  terminates without further repeats if no more than npiv pivots are taken. !    In case of any breakdown, the code is restarted, usually in mode 2. !  The maximum number of unsuccessful restarts allowed is set in nres. !    The basis matrix may be refactorised on occasions, for example to prevent !  build-up of round-off in the factors or (when using schurQR.f) to limit !  the growth in the Schur complement. The maximum interval between !  refactorizations (or size of Schur complement) is set in mxmc. !    Default values are set in block data but can be reset by the user. !    infoc returns information about the progress of the method: rgnorm is the !  norm of the reduced gradient on exit, and vstep is the length of the vertical !  step in the warm start process. iter is the total number of iterations taken, !  npv is the number of pivots, and ngr is the number of calls of gdotx. parameter ( ainfty = 1.D100 ) dimension a ( * ), x ( * ), bl ( * ), bu ( * ), g ( * ), r ( * ), w ( * ), e ( * ), alp ( * ), ws ( * ), & la ( * ), ls ( * ), lp ( * ), lws ( * ), v ( * ) character ( len = 32 ) spaces common / lcpdc / na , na1 , nb , nb1 , krg , krg1 , kr , kr1 , & ka , ka1 , kb , kb1 , kc , kc1 , kd , kd1 , ke , ke1 , lu1 , ll1 common / epsc / eps , t0l , emin common / infoc / rgnorm , vstep , iter , npv , ngr common / repc / sgnf , nrep , npiv , nres common / wsc / kk , ll , kkk , lll , mxws , mxlws common / refactorc / mc , mxmc common / alphac / alpha , rp , pj , qqj , qqj1 logical plus 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) 5 format (( 6E15 . 7 )) 6 format ( A , I5 , 2E15 . 7 ) spaces = '         ' mode = m0de tol = t0l iter = 0 npv = 0 if ( m < 0 . or . n <= 0 . or . mlp < 2 . or . mode < 0 . or . mode > 4 . or . & kmax < 0 . or . ( kmax > 0 . and . maxg <= 1 ) . or . tol <= 0.0D0 ) then ifail = 6 return end if rgt0l = rgtol n1 = n + 1 nm = n + m nmi = nm ngr = 0 nv0 = nv if ( iprint >= 3 ) then write ( nout , 1000 ) 'lower bounds' ,( bl ( i ), i = 1 , nm ) write ( nout , 1000 ) 'upper bounds' ,( bu ( i ), i = 1 , nm ) end if irep = 0 ires = 0 mres = 0 bestf = ainfty do i = 1 , nm t = bu ( i ) - bl ( i ) if ( t <- tol ) then ifail = 2 return end if if ( t <= tol . and . t > 0.D0 ) then bl ( i ) = 5.D-1 * ( bl ( i ) + bu ( i )) bu ( i ) = bl ( i ) end if end do vmax = 0.D0 do i = 1 , n x ( i ) = min ( bu ( i ), max ( bl ( i ), x ( i ))) vmax = max ( vmax , bu ( i ) - bl ( i )) end do if ( mode <= 2 ) then call stmapq ( n , nm , kmax , maxg ) if ( mode == 0 ) then nk = 0 else if ( mode == 1 ) then !  collect equality c/s nk = 0 do i = 1 , nm if ( bu ( i ) == bl ( i )) then nk = nk + 1 ls ( nk ) = i end if end do !         write(nout,*)'number of eqty c/s =',nk else nk = n - k end if end if !  restarts loop 7 continue lp ( 1 ) = nm lev = 1 if ( mode <= 3 ) then !  set up factors of basis matrix and permutation vectors ifail = mode call start_up ( n , nm , nmi , a , la , nk , e , ls , ws ( lu1 ), lws ( ll1 ), mode , ifail ) if ( ifail > 0 ) return end if 8 continue peq = 0 ig = 0 !  refinement step loop mpiv = iter + npiv ninf = 0 do i = 1 , n g ( i ) = 0.D0 end do if ( mode > 0 ) then call warm_start ( n , nm , a , la , x , bl , bu , r , ls , ws ( lu1 ), & lws ( ll1 ), ws ( na1 ), vstep ) !       print *,'vstep,vmax',vstep,vmax if ( vstep > 2.D0 * vmax ) then mpiv = 0 mode = 0 nk = 0 do i = 1 , n x ( i ) = min ( bu ( i ), max ( bl ( i ), x ( i ))) end do goto 7 end if if ( vstep > tol ) mpiv = 0 end if k = 0 !  collect free variables do j = n , 1 , - 1 i = abs ( ls ( j )) if ( i <= n . and . x ( i ) > bl ( i ) . and . x ( i ) < bu ( i )) then call iexch ( ls ( j ), ls ( n - k )) k = k + 1 end if end do if ( mode == 0 ) then do j = 1 , n - k i = ls ( j ) if ( x ( i ) == bu ( i )) ls ( j ) =- i end do lp ( 1 ) = n goto 9 end if phase = 0 !  move inactive general c/s to the end do j = nm , n1 , - 1 i = abs ( ls ( j )) if ( i > n ) then call iexch ( ls ( j ), ls ( lp ( 1 ))) lp ( 1 ) = lp ( 1 ) - 1 end if end do call residuals ( n , n1 , lp ( 1 ), a , la , x , bl , bu , r , ls , f , g , ninf ) if ( ninf > 0 ) then gnorm = sqrt ( dble ( ninf )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) goto 15 end if 9 continue !  enter phase 1 phase = 1 !  collect active equality c/s do j = 1 , n - k i = abs ( ls ( j )) if ( bu ( i ) == bl ( i )) then peq = peq + 1 call iexch ( ls ( j ), ls ( peq )) end if end do call residuals ( n , lp ( 1 ) + 1 , nm , a , la , x , bl , bu , r , ls , f , g , ninf ) lp ( 1 ) = nm if ( ninf > 0 ) then gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) goto 15 end if 10 continue phase = 2 if ( iprint >= 1 ) write ( nout , * ) 'FEASIBILITY OBTAINED at level 1' n_inf = 0 call setfg2 ( n , linear , a , la , x , f , g , ws , lws ) fbase = f f = 0.D0 ngr = ngr + 1 !     write(nout,4)'g =',(g(i),i=1,n) call newg gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) ig = 0 if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , fbase goto 16 !  start of major iteration 15 continue if ( iprint >= 1 ) then if ( ninf == 0 ) then if ( k > 0 ) then !           write(nout,'(''pivots ='',I5, !    *        ''  level = 1    df ='',E16.8,''   k ='',I4)')npv,f,k write ( nout , '(''pivots ='',I5, ''  level = 1    df ='',E16.8,''   rg ='',E12.4, ''  k ='',I4)' ) npv , f , rgnorm , k else write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , fbase + f end if else if ( phase == 0 ) then write ( nout , '(''pivots ='',I5,''  level = 1    f ='', E16.8,''   ninfb ='',I4)' ) npv , f , ninf else write ( nout , '(''pivots ='',I5,''  level = 1    f ='', E16.8,''   ninf ='',I4)' ) npv , f , ninf end if end if 16 continue !  calculate multipliers do i = 1 , nm w ( i ) = 0.D0 end do !     write(nout,4)'g =',(g(i),i=1,n) call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) call signst ( n , r , w , ls ) !  opposite bound or reset multiplier loop 20 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) !       write(nout,1000)'steepest edge coefficients', !    *    (e(abs(ls(j))),j=1,n) if ( peq > 0 . or . k > 0 ) write ( nout , 1 ) & '# active equality c/s and free variables = ' , peq , k end if !     if (iphase<=1)fbase=0.D0 !     call checkq(n,lp(1),nmi,kmax,g,a,la,x,bl,bu,r,ls,ws(nb1),fbase+f, !    *  ws,lws,ninf,peq,k,1,p,rp,linear) 21 continue call optest ( peq + 1 , n - k , r , e , ls , rp , pj ) if ( phase == 0 ) then !  possibly choose an active general c/s to relax (marked by rp>0) t =- 1.D1 * rp do 13 j = 1 , n i = abs ( ls ( j )) if ( i <= n ) goto 13 if ( bu ( i ) == bl ( i ) . and . r ( i ) < 0.D0 ) then r ( i ) =- r ( i ) ls ( j ) =- ls ( j ) end if if ( r ( i ) / e ( i ) <= t ) goto 13 rp = r ( i ) t = rp / e ( i ) pj = j 13 continue end if if ( ig == 0 ) then gg = 0.D0 do j = n - k + 1 , n i = ls ( j ) gg = gg + r ( i ) ** 2 end do rgnorm = sqrt ( gg ) end if !     print 2,'rgtol,rgnorm,rp',rgtol,rgnorm,rp 25 continue if ( rgnorm <= rgtol . and . abs ( rp ) <= gtol ) then !  allow for changes to norm(g) gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) end if if (( rgnorm <= rgtol . and . abs ( rp ) <= gtol ) . or . ngr > mxgr ) then !  optimal at current level: first tidy up x do j = peq + 1 , n - k i = abs ( ls ( j )) if ( i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do do i = 1 , n x ( i ) = max ( min ( x ( i ), bu ( i )), bl ( i )) end do do j = n1 , nm i = abs ( ls ( j )) if ( r ( i ) == 0.D0 . and . i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do if ( ngr > mxgr ) then f = fbase + f ifail = 5 return end if if ( iprint >= 2 ) then write ( nout , * ) 'OPTIMAL at level 1' if ( iprint >= 3 ) then !           write(nout,1000)'x variables',(x(i),i=1,n) write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , nm ) end if end if irep = irep + 1 if ( irep <= nrep . and . iter > mpiv ) then if ( iprint >= 1 ) write ( nout , 1 ) 'refinement step #' , irep mode = 4 goto 8 end if if ( iprint >= 2 . and . nrep > 0 ) & write ( nout , * ) 'total number of restarts =' , ires if ( ninf > 0 ) then ifail = 3 return end if nv = nv0 ifail = 0 f = fbase + f return end if if ( rgnorm >= abs ( rp )) then !  ignore the multiplier of c/s p and set up or continue SD steps p = 0 else p = abs ( ls ( pj )) if ( iprint >= 2 ) print 1 , 'CHOOSE p =' , p rp = r ( p ) call iexch ( ls ( pj ), ls ( n - k )) pj = n - k ig = 0 end if if ( p > 0 ) then !  compute +/- Steepest Edge (SE) search direction s in an(.) call tfbsub ( n , a , la , p , ws ( na1 ), ws ( na1 ), ws ( lu1 ), lws ( ll1 ), & e ( p ),. true .) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( ls ( pj ) < 0 ) rp =- rp if ( rp * r ( p ) <= 0.D0 ) then r ( p ) = 0.D0 goto 21 end if if ( abs ( rp - r ( p )) > 5.D-1 * max ( abs ( rp ), abs ( r ( p )))) then !       if (abs(rp-r(p))>1.D-1*gnorm) then print 2 , '1rp,r(p),rp-r(p)' , rp , r ( p ), rp - r ( p ) goto 98 end if snorm = e ( p ) plus = ls ( pj ) >= 0. eqv . rp < 0.D0 f0 = f ig = 0 else if ( ig == 0 ) then !  start up the limited memory sweep method !         if (p>0) then !  transfer c/s p into Z !           if (ls(pj)<0) then !             r(p)=-r(p) !             ls(pj)=-ls(pj) !           end if !           k=k+1 !           gg=gg+r(p)**2 !         end if ig = 1 ngv = 1 f0 = f ws ( kb1 ) = gg rgnorm = sqrt ( gg ) !         print 2,'initial rg =',(r(ls(j)),j=n-k+1,n) if ( k * ngv > kmax * maxg ) then f = fbase + f ifail = 9 return end if call store_rg ( k , ig , ws ( krg1 ), r , ls ( n - k + 1 )) end if !  compute Steepest Descent (SD) search direction s = -Z.rg in an(.) call zprod ( k , n , a , la , ws ( na1 ), r , w , ls , ws ( lu1 ), lws ( ll1 )) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( abs ( gg + rp ) > 5.D-1 * max ( gg , abs ( rp ))) then !       if (abs(gg+rp)>1.D-2*max(gg,abs(rp))) then print 2 , 'gg,rp,gg+rp' , gg , rp , gg + rp goto 98 end if snorm = sqrt ( scpr ( 0.D0 , ws ( na1 ), ws ( na1 ), n )) plus = . true . end if !     print 4,'s (or -s if .not.plus) =',(ws(i),i=na1,na+n) !     print *,'plus =',plus !  form At.s and denominators call form_Ats ( n1 , lp ( 1 ), n , plus , a , la , ws ( na1 ), w , ls , snorm * tol ) !  return from degeneracy code 30 continue if ( iprint >= 3 ) then write ( nout , 1000 ) 'x variables' ,( x ( i ), i = 1 , n ) write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , lp ( 1 )) write ( nout , 1000 ) 'denominators' ,( w ( abs ( ls ( j ))), j = n1 , lp ( 1 )) end if !     read *,i 40 continue !  level 1 ratio tests amax = ainfty qj = 0 qj1 = 0 do 41 j = n - k + 1 , n i = ls ( j ) if ( i <= 0 ) print * , 'i<=0' if ( i <= 0 ) stop si = ws ( na + i ) if ( si == 0.D0 ) goto 41 t = abs ( si ) if ( si > 0.D0 . eqv . plus ) then z = bu ( i ) - x ( i ) if ( abs ( z ) < tol ) then z = 0.D0 x ( i ) = bu ( i ) else z = z / t end if else z = x ( i ) - bl ( i ) if ( abs ( z ) < tol ) then z = 0.D0 x ( i ) = bl ( i ) else z = z / t end if end if if ( z > amax ) goto 41 amax = z qj = j 41 continue if ( ig == 0 . and . rp < 0.D0 . and . bu ( p ) - bl ( p ) < amax ) then amax = bu ( p ) - bl ( p ) qj = pj end if if ( ninf > 0 ) then alpha1 = ainfty do 42 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi == 0.D0 ) goto 42 ri = r ( i ) if ( wi > 0.D0 ) then if ( ri < 0.D0 ) goto 42 z = ( ri + tol ) / wi else if ( ri < 0.D0 ) then z = ri / wi if ( z < alpha1 ) then alpha1 = z qj1 = j end if end if z = (( bl ( i ) - bu ( i )) + ri - tol ) / wi end if if ( z >= amax ) goto 42 amax = z qj = j 42 continue if ( qj1 > 0 . and . alpha1 <= amax ) then !  find feasible step that zeros most infeasible c/s do 43 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi >= 0.D0 ) goto 43 ri = r ( i ) if ( ri < 0.D0 ) then z = ri / wi if ( z > alpha1 . and . z <= amax ) then alpha1 = z qj1 = j end if end if 43 continue amax = alpha1 qj = qj1 else qj1 = 0 end if else do 44 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi == 0.D0 ) goto 44 ri = r ( i ) if ( wi > 0.D0 ) then z = ( ri + tol ) / wi else z = ( bl ( i ) - bu ( i ) + ri - tol ) / wi end if if ( z >= amax ) goto 44 amax = z qj = j 44 continue end if q = abs ( ls ( qj )) if ( iprint >= 2 . and . q /= p . and . qj > n ) & write ( nout , * ) 'q,r(q),w(q) =' , q , r ( q ), w ( q ) if ( qj > n . and . qj1 == 0 ) then if ( w ( q ) > 0.D0 ) then amax = r ( q ) / w ( q ) else amax = ( bl ( q ) - bu ( q ) + r ( q )) / w ( q ) end if end if if ( amax == 0.D0 . and . rp <= 0.D0 ) then alpha = 0.D0 !  potential degeneracy block at level 1 if ( p == 0 ) goto 65 if ( bu ( q ) == bl ( q )) goto 70 plev = n do j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( r ( i ) == 0.D0 ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) if ( bu ( i ) > bl ( i )) r ( i ) = 1.D0 end if end do if ( plev > n1 ) then lp ( 2 ) = plev lev = 2 alp ( 1 ) = f f = 0.D0 qj = pj q = p if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,''     level = 2'', ''    f ='',E16.8)' ) npv , f goto 86 end if qj = n1 r ( q ) = 0.D0 !       print *,'only one degenerate c/s' goto 70 end if if ( ninf > 0 ) then alpha = amax else if ( linear ) then alpha = amax ff = f + alpha * rp if ( ff < fmin ) goto 75 f = ff goto 60 end if call gdotx ( n , ws ( na1 ), ws , lws , ws ( nb1 )) ngr = ngr + 1 sgs = scpr ( 0.D0 , ws ( na1 ), ws ( nb1 ), n ) !       print 2,'rp,sgs',rp,sgs ggo = gg if ( p == 0 ) then t = v ( nv ) if ( t <= 0.D0 ) goto 52 alpha = 1.D0 / t if ( alpha >= amax ) goto 52 nv = nv - 1 ff = f + alpha * ( rp + 5.D-1 * alpha * sgs ) if ( ff >= f0 ) goto 52 !           print 2,'alphar =',alpha !  need to set f0 somewhere if ( iprint >= 2 ) write ( nout , * ) 'Ritz value step:  alpha =' , & alpha , '   p =' , p goto 54 end if 52 continue if ( sgs > 0.D0 ) then alpha =- rp / sgs if ( alpha < amax ) then !     accept Cauchy step if ( iprint >= 2 ) write ( nout , * ) 'Cauchy step:  alpha =' , & alpha , '   p =' , p ff = f + alpha * ( rp + 5.D-1 * alpha * sgs ) nv = 0 !           print 2,'alphac =',alpha goto 54 end if end if !  Cauchy step infeasible alpha = amax ff = f + alpha * ( rp + 5.D-1 * alpha * sgs ) if ( ff < fmin ) goto 75 if ( ff >= f ) then if ( ires < nres ) goto 98 f = fbase + f if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f ifail = 4 return end if f = ff if ( plus ) then call mysaxpy ( alpha , ws ( nb1 ), g , n ) else call mysaxpy ( - alpha , ws ( nb1 ), g , n ) end if !       print 4,'new g =',(g(i),i=1,n) call newg goto 60 54 continue if ( ff < fmin ) goto 75 if ( ff >= f ) then if ( ires < nres ) goto 98 f = fbase + f if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f ifail = 4 return end if f = ff if ( plus ) then call mysaxpy ( alpha , ws ( nb1 ), g , n ) else call mysaxpy ( - alpha , ws ( nb1 ), g , n ) end if !       print 4,'new g =',(g(i),i=1,n) call newg if ( ig == 0 ) goto 60 ig1 = ig + 1 if ( ig1 > maxg ) ig1 = 1 call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) !       print 4,'new rg =',(w(ls(j)),j=n-k+1,n) if ( ngv < maxg ) ngv = ngv + 1 if ( k * ngv > kmax * maxg ) then f = fbase + f ifail = 9 return end if call store_rg ( k , ig1 , ws ( krg1 ), w , ls ( n - k + 1 )) gpg = 0.D0 gg = 0.D0 do j = n - k + 1 , n i = ls ( j ) gpg = gpg + r ( i ) * w ( i ) gg = gg + w ( i ) ** 2 end do rgnorm = sqrt ( gg ) !       print 2,'gpg,gg',gpg,gg !       print 2,'f =',f call signst ( n , r , w , ls ) ws ( ka + ig ) = 1.D0 / alpha ws ( kb + ig1 ) = gg ws ( kc + ig ) = gpg if ( nv == 0 . or . gg > ggo ) then !  compute new Ritz values if ( ngv == 2 ) then nv = 1 v ( 1 ) = 1.D0 / alpha else nv = min ( ngv - 1 , k ) if ( nv <= 0 ) print 1 , 'ngv,k,ig,nv =' , ngv , k , ig , nv if ( nv <= 0 ) stop !           print 1,'ngv,k,ig,nv =',ngv,k,ig,nv !           print 4,'G =',(ws(krg+i),i=1,k*ngv) !           print 4,'a =',(ws(ka+i),i=1,ngv) !           print 4,'b =',(ws(kb+i),i=1,ngv+1) !           print 4,'c =',(ws(kc+i),i=1,ngv) call formR ( nv , k , ig , maxg , ws ( ka1 ), ws ( kb1 ), ws ( kc1 ), ws ( kd1 ), & ws ( ke1 ), ws ( krg1 ), ws ( kr1 )) !           call checkT(nv,maxg,ws(kr1),ws(ke1),ws(kd1)) call formT ( nv , maxg , ws ( kr1 ), v , ws ( ke1 )) !           print 4,'T matrix',(v(i),i=1,nv) !             if (nv>1) print 5,(ws(ke+i),i=1,nv-1) call trid ( v ( 1 ), ws ( ke1 ), nv ) !           print 4,'eigenvalues of T',(v(i),i=1,nv) call insort ( nv , v ) !           print 4,'sorted eigenvalues of T',(v(i),i=1,nv) end if nv0 = nv f0 = f end if ig = ig1 end if 60 continue if ( alpha > 0.D0 ) then !  update x if ( plus ) then call mysaxpy ( alpha , ws ( na1 ), x , n ) else call mysaxpy ( - alpha , ws ( na1 ), x , n ) end if !  update r for inactive c/s iter = iter + 1 if ( ninf > 0 ) then n_inf = 0 ff = f f = 0.D0 do 61 j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( w ( i ) == 0.D0 ) then if ( r ( i ) >= 0.D0 ) goto 61 n_inf = n_inf + 1 f = f - r ( i ) goto 61 end if ri = r ( i ) - alpha * w ( i ) if ( abs ( ri ) <= tol ) ri = 0.D0 if ( r ( i ) < 0.D0 ) then if ( ri >= 0.D0 ) then !  remove contribution to gradient if ( i > n ) then call saipy ( sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , g , n ) else g ( i ) = 0.D0 end if else n_inf = n_inf + 1 f = f - ri end if end if if ( w ( i ) < 0.D0 ) then ro = ( bu ( i ) - bl ( i )) - ri if ( abs ( ro ) <= tol ) ro = 0.D0 if ( ro < ri ) then ri = ro ls ( j ) =- ls ( j ) end if end if if ( ri == 0.D0 . and . i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if r ( i ) = ri 61 continue if ( n_inf /= ninf ) then call iexch ( ninf , n_inf ) call newg !         else if (f>=ff) then else if ( f >= eps * ff + ff ) then goto 98 end if else n_inf = 0 do 62 j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( w ( i ) == 0.D0 ) goto 62 ri = r ( i ) - alpha * w ( i ) if ( w ( i ) < 0.D0 ) then ro = ( bu ( i ) - bl ( i )) - ri if ( ro < ri ) then ri = max ( ro , 0.D0 ) w ( i ) =- w ( i ) ls ( j ) =- ls ( j ) end if end if if ( ri <= tol ) then ri = 0.D0 if ( i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end if r ( i ) = ri 62 continue end if end if if ( alpha < amax ) then if ( ig > 0 ) then !  continue limited memory SD iterations if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    df ='',E16.8,''   rg ='',E12.4, ''  k ='',I4)' ) npv , f , rgnorm , k if ( alpha > 0.D0 ) goto 20 print * , 'alpha<=0' goto 98 end if !  Cauchy step with SE iteration k = k + 1 if ( p <= n ) then ls ( pj ) = p goto 15 end if !  case p>n: find best inactive simple bound to replace p in ls(pj) t = 0.D0 do j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( i <= n ) then ti = abs ( ws ( na + i )) if ( ti > t ) then t = ti qj = j end if end if end do if ( t <= snorm * tol ) then print * , 'no suitable simple bound available' goto 98 end if q = abs ( ls ( qj )) ls ( qj ) = q if ( iprint >= 2 ) write ( nout , 1 ) 'New free variable' , q goto 70 end if 65 continue if ( iprint >= 2 ) & write ( nout , * ) 'New active c/s:  alpha =' , alpha , '   q =' , q if ( ig > 0 ) then !  case alpha=amax and SD step: find best free variable to relax k = k - 1 if ( qj <= n ) then !  case: q is a free variable if ( ws ( na + q ) > 0.D0 ) ls ( qj ) =- q call iexch ( ls ( qj ), ls ( n - k )) ig = 0 if ( n_inf > 0 . and . ninf == 0 ) goto 10 goto 15 end if call fbsub ( n , n - k , n , a , la , q , w , w , ls , ws ( lu1 ), lws ( ll1 ),. false .) !       print 4,'w(n-k:n) =',(w(ls(j)),j=n-k,n) t = 0.D0 do j = n - k , n i = ls ( j ) ti = abs ( w ( i )) / e ( i ) if ( ti > t ) then t = ti pj = j end if end do if ( t <= tol ) then print * , 'no suitable free variable to relax' goto 98 end if p = ls ( pj ) call iexch ( ls ( pj ), ls ( n - k )) pj = n - k if ( iprint >= 2 ) write ( nout , * ) 'relax free variable' , p end if !  return from degeneracy with an equality c/s 70 continue if ( qj /= pj ) then !  pivot interchange if ( iprint >= 2 ) write ( nout , * ) 'replace' , p , ' by' , q if ( p == 0 ) print * , 'p==0' if ( p == 0 ) goto 98 call pivot ( p , q , n , nmi , a , la , e , ws ( lu1 ), lws ( ll1 ), ifail , npv ) if ( ifail >= 1 ) then if ( ifail >= 2 ) then ifail = 11 return end if if ( iprint >= 1 ) write ( nout , * ) 'failure detected in pivot (1)' print * , 'r(q),w(q),q' , r ( q ), w ( q ), q goto 98 end if if ( rp > 0.D0 ) then call iexch ( ls ( pj ), ls ( qj )) call iexch ( ls ( lp ( 1 )), ls ( qj )) lp ( 1 ) = lp ( 1 ) - 1 if ( ninf > 0 ) goto 15 goto 9 end if if ( ig > 0 ) then ri = x ( p ) - bl ( p ) ro = bu ( p ) - x ( p ) if ( ro < ri ) then ri = ro ls ( pj ) =- p end if if ( ri <= tol ) ri = 0.D0 r ( p ) = ri ig = 0 else rpu = max ( bu ( p ) - bl ( p ) - alpha , 0.D0 ) if ( alpha <= rpu ) then rpu = alpha else ls ( pj ) =- ls ( pj ) end if if ( abs ( rpu ) <= tol ) rpu = 0.D0 r ( p ) = rpu end if !       print 2,'r(p)',r(p) call iexch ( ls ( pj ), ls ( qj )) if ( phase > 0 . and . bu ( q ) == bl ( q )) then peq = peq + 1 call iexch ( ls ( pj ), ls ( peq )) end if if ( ninf == 0 ) then if ( phase == 0 ) goto 9 if ( phase == 1 ) goto 10 end if goto 15 end if !  opposite bound comes active if ( ninf == 0 ) then if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , fbase + f else if ( phase == 0 ) then if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8,''   ninfb ='',I4)' ) & npv , f , ninf else if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8,''   ninf ='',I4)' ) & npv , f , ninf end if ls ( pj ) =- ls ( pj ) if ( ninf == 0 . and . . not . linear ) goto 16 if ( ninf > 0 . and . ninf /= n_inf ) goto 16 r ( p ) =- rp goto 20 !  unbounded solution case 75 continue irep = irep + 1 if ( irep <= nrep . and . iter > mpiv ) then mode = 4 if ( iprint >= 1 ) write ( nout , 1 ) & 'unbounded solution identified: refinement step #' , irep goto 8 end if ifail = 1 !  tidy up x do i = 1 , n x ( i ) = max ( min ( x ( i ), bu ( i )), bl ( i )) end do do j = n1 , nm i = abs ( ls ( j )) if ( r ( i ) == 0.D0 . and . i <= n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do nv = nv0 f = fbase + f return !  recursive code for resolving degeneracy (Wolfe's method) 80 continue !  calculate multipliers call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) call signst ( n , r , w , ls ) !  reset multiplier loop 82 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) !       write(nout,1000)'steepest edge coefficients', !    *    (e(abs(ls(j))),j=1,n) if ( peq > 0 . or . k > 0 ) write ( nout , 1 ) & '# active equality c/s and free variables = ' , peq , k end if 84 continue call optest ( peq + 1 , n - k , r , e , ls , rp , pj ) if ( - rp <= gtol ) then if ( iprint >= 2 ) write ( nout , * ) 'return to level 1' lev = 1 f = alp ( 1 ) do j = n1 , lp ( 2 ) r ( abs ( ls ( j ))) = 0.D0 end do lev = 1 if ( rp == 0.D0 . and . phase > 0 ) goto 25 goto 20 end if call iexch ( ls ( pj ), ls ( n - k )) pj = n - k plus = ls ( pj ) >= 0 p = abs ( ls ( pj )) rp = r ( p ) !  compute search direction s in an(.) call tfbsub ( n , a , la , p , ws ( na1 ), ws ( na1 ), ws ( lu1 ), lws ( ll1 ), & e ( p ),. true .) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( ls ( pj ) < 0 ) rp =- rp if ( rp * r ( p ) <= 0.D0 ) then r ( p ) = 0.D0 goto 84 end if if ( abs ( rp - r ( p )) > 5.D-1 * max ( abs ( rp ), abs ( r ( p )))) then !       if (abs(rp-r(p))>1.D-1*gnorm) then print 2 , '2rp,r(p),rp-r(p)' , rp , r ( p ), rp - r ( p ) goto 98 end if snorm = e ( p ) !  form At.s and denominators call form_Ats ( n1 , lp ( lev ), n , plus , a , la , ws ( na1 ), w , ls , snorm * tol ) 86 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , lp ( lev )) write ( nout , 1000 ) 'denominators' ,( w ( abs ( ls ( j ))), j = n1 , lp ( lev )) end if 88 continue !  ratio test at higher levels alpha = ainfty qj = 0 do 90 j = n1 , lp ( lev ) i = abs ( ls ( j )) wi = w ( i ) if ( wi <= 0.D0 ) goto 90 if ( r ( i ) < 0.D0 ) goto 90 z = ( r ( i ) + tol ) / wi if ( z >= alpha ) goto 90 alpha = z qj = j 90 continue if ( qj == 0 ) then do j = n1 , lp ( lev ) i = abs ( ls ( j )) w ( i ) = min ( w ( i ), 0.D0 ) r ( i ) = 0.D0 end do call form_Ats ( lp ( lev ) + 1 , lp ( lev - 1 ), n , plus , a , la , ws ( na1 ), & w , ls , snorm * tol ) lev = lev - 1 f = alp ( lev ) if ( iprint >= 2 ) write ( nout , * ) 'UNBOUNDED:   p =' , p , & '   return to level' , lev if ( lev > 1 ) goto 86 if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) if ( peq > 0 . or . k > 0 ) print 1 , & '# active equality c/s and free variables = ' , peq , k end if !       call checkq(n,lp(1),nmi,kmax,g,a,la,x,bl,bu,r,ls,ws(nb1), !         f,ws,lws,ninf,peq,k,1,p,rp,linear) goto 30 end if q = abs ( ls ( qj )) alpha = r ( q ) / w ( q ) ff = f + alpha * rp if ( iprint >= 2 ) then write ( nout , * ) 'alpha =' , alpha , '   p =' , p , '   q =' , q write ( nout , 2 ) 'r(p),r(q),w(q) =' , r ( p ), r ( q ), w ( q ) end if !  test for equality c/s if ( bu ( q ) == bl ( q )) then do j = n1 , lp ( 2 ) r ( abs ( ls ( j ))) = 0.D0 end do lev = 1 f = alp ( 1 ) alpha = 0.D0 if ( iprint >= 2 ) write ( nout , * ) 'EQTY:   p =' , p , '   q =' , q , & '   return to level 1' goto 70 end if if ( alpha == 0.D0 ) then !  potential degeneracy block at level lev if ( lev + 2 > mlp ) then ifail = 8 return end if r ( q ) = 0.D0 plev = n do j = n1 , lp ( lev ) i = abs ( ls ( j )) if ( r ( i ) == 0.D0 ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) if ( bu ( i ) > bl ( i )) r ( i ) = 1.D0 end if end do if ( plev > n1 ) then lev = lev + 1 lp ( lev ) = plev alp ( lev ) = f f = 0.D0 if ( iprint >= 2 ) write ( nout , * ) & 'degeneracy: increase level to ' , lev if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,A,''level ='',I2, ''    f ='',E16.8)' ) npv , spaces (: 3 * lev - 1 ), lev , f goto 86 end if qj = n1 end if iter = iter + 1 if ( iprint >= 2 ) write ( nout , * ) 'replace' , p , ' by' , q call pivot ( p , q , n , nmi , a , la , e , ws ( lu1 ), lws ( ll1 ), ifail , npv ) if ( ifail >= 1 ) then if ( ifail >= 2 ) then ifail = 11 return end if !       call iexch(ls(pj),ls(qj)) if ( iprint >= 1 ) write ( nout , * ) 'failure detected in pivot (4)' !       print *,'r(q),w(q),q',r(q),w(q),q goto 98 end if !  update r and f do j = n1 , lp ( lev ) i = abs ( ls ( j )) ri = r ( i ) - alpha * w ( i ) if ( abs ( ri ) <= tol ) ri = 0.D0 r ( i ) = ri end do f = ff !  exchange a constraint r ( p ) = alpha if ( r ( p ) <= tol ) r ( p ) = 0.D0 call iexch ( ls ( pj ), ls ( qj )) if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,A,''level ='',I2, ''    f ='',E16.8)' ) npv , spaces (: 3 * lev - 1 ), lev , f goto 80 !  restart sequence 98 continue do i = 1 , n x ( i ) = min ( bu ( i ), max ( bl ( i ), x ( i ))) end do nk = peq do j = peq + 1 , n - k i = abs ( ls ( j )) if ( i > n ) then nk = nk + 1 ls ( nk ) = ls ( j ) end if end do k = n - nk mode = 2 ires = ires + 1 if ( iprint >= 1 ) write ( nout , * ) 'major restart #' , ires tol = 1.D1 * tol if ( ires <= nres ) goto 7 ifail = 10 return 1000 format ( a / ( e16 . 5 , 4e16 . 5 )) 1001 format ( a / ( i4 , 1 x , e12 . 5 , 4 ( i4 , 1 x , e12 . 5 ))) !1000 format(a/(e18.8,3e19.8)) !1001 format(a/(i3,1x,e14.8,3(i4,1x,e14.8))) end subroutine stmapq ( n , nm , kmax , maxg ) !  set storage map for workspace in qlcpd and auxiliary routines implicit double precision ( a - h , r - z ), integer ( i - q ) common / wsc / kk , ll , kkk , lll , mxws , mxlws common / lcpdc / na , na1 , nb , nb1 , krg , krg1 , kr , kr1 , & ka , ka1 , kb , kb1 , kc , kc1 , kd , kd1 , ke , ke1 , lu1 , ll1 !  double precision storage (ws) !  locations 1:kk are user workspace for gdotx !  scratch slots of length n+m and n na = kk na1 = kk + 1 nb = na + nm nb1 = nb + 1 !  workspace of length kmax*maxg for reduced gradient vectors krg = nb + n krg1 = krg + 1 !  a slot of length maxg*(maxg+1)/2 and 5 slots of length maxg for sweep method kr = krg + kmax * maxg kr1 = kr + 1 ka = kr + maxg * ( maxg + 1 ) / 2 ka1 = ka + 1 kb = ka + maxg kb1 = kb + 1 kc = kb + maxg kc1 = kc + 1 kd = kc + maxg kd1 = kd + 1 ke = kd + maxg ke1 = ke + 1 !  remaining space for use by denseL.f or schurQR.f lu1 = ke1 + maxg !  total number of double precision locations required by qlcpd kkk = nm + n + maxg * ( maxg + 1 ) / 2 + maxg * ( kmax + 5 ) !  integer storage (lws) !  locations 1:ll are user workspace for gdotx !  number of integer locations required by qlcpd lll = 0 !  remaining space for use by denseL.f or schurQR.f ll1 = ll + 1 return end subroutine setfg2 ( n , linear , a , la , x , f , g , ws , lws ) implicit double precision ( a - h , o - z ) logical linear dimension a ( * ), la ( * ), x ( * ), g ( * ), ws ( * ), lws ( * ) common / noutc / nout if ( linear ) then do i = 1 , n g ( i ) = 0.D0 end do call saipy ( 1.D0 , a , la , 0 , g , n ) f = scpr ( 0.D0 , x , g , n ) else call gdotx ( n , x , ws , lws , g ) call saipy ( 1.D0 , a , la , 0 , g , n ) f = 5.D-1 * scpr ( aiscpr ( n , a , la , 0 , x , 0.D0 ), g , x , n ) end if 1 format ( A , 15 I4 ) 2 format ( A , 5E15 . 7 ) 3 format ( A / ( 20 I4 )) 4 format ( A / ( 5E15 . 7 )) return end subroutine checkq ( n , nm , nmi , kmax , g , a , la , x , bl , bu , r , ls , an , f , & ws , lws , ninf , peq , k , lev , p , alp2 , linear ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension g ( * ), a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), r ( * ), ls ( * ), & an ( * ), ws ( * ), lws ( * ) common / noutc / nout common / epsc / eps , tol , emin logical linear !     if (lev==2) then !       do i=1,n !         an(i)=g(i) !       end do !       e=alp2*sign(1.D0,dble(p)) !       i=abs(p) !       if (i<=n) then !         an(i)=an(i)-e !       else !         call saipy(-e,a,la,i-n,an,n) !       end if !        goto 10 !     end if j = nmi * ( nmi + 1 ) / 2 do i = 1 , nmi j = j - abs ( ls ( i )) end do if ( j /= 0 ) write ( nout , * ) 'indexing error' if ( j /= 0 ) stop do j = 1 , peq i = abs ( ls ( j )) if ( bu ( i ) > bl ( i )) then write ( nout , * ) 'non-equality constraint i =' , i write ( nout , * ) 'j,peq =' , j , peq stop end if end do do j = n - k + 1 , n i = ls ( j ) if ( i <= 0 . or . i > n ) then write ( nout , * ) 'faulty free variable: i, j =' , i , j stop end if end do e = 0.D0 do j = n + 1 , nm i = abs ( ls ( j )) if ( i <= n ) then s = x ( i ) else s = aiscpr ( n , a , la , i - n , x , 0.D0 ) end if if ( ls ( j ) > 0 ) then !         print *,'i,s,r(i),bl(i)',i,s,r(i),bl(i) s = r ( i ) - s + bl ( i ) else s = r ( i ) + s - bu ( i ) end if if ( abs ( s ) <= tol * max ( 1.D0 , abs ( r ( i )))) s = 0.D0 if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do if ( e > tol ) write ( nout , * ) 'residual error at level 1 = ' , e , ie !     if (e>tol) stop if ( ninf == 0 ) then call setfg2 ( n , linear , a , la , x , ff , an , ws , lws ) else do i = 1 , n an ( i ) = 0.D0 end do ff = 0.D0 do j = n + 1 , nm i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) then ff = ff - r ( i ) if ( i > n ) then call saipy ( - sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , an , n ) else an ( i ) = an ( i ) - sign ( 1.D0 , dble ( ls ( j ))) end if end if end do end if gnm = sqrt ( scpr ( 0.D0 , an , an , n )) if ( lev == 1 . and . max ( abs ( f ), abs ( ff )) < 1.D20 ) then e = abs ( ff - f ) if ( e > tol * max ( 1.D0 , abs ( f ))) write ( nout , * ) 'function error = ' , e , & '   f(x) =' , ff !     if (e>tol) stop if ( e > tol * max ( 1.D0 , abs ( f ))) print 4 , 'x =' ,( x ( j ), j = 1 , n ) if ( e > tol * max ( 1.D0 , abs ( f ))) stop end if 10 continue e = 0.D0 do j = 1 , n !       write(nout,*)'an =',(an(i),i=1,n) i = abs ( ls ( j )) s = sign ( 1.D0 , dble ( ls ( j ))) if ( i <= n ) then !         print *,'i,s,r(i)',i,s,r(i) an ( i ) = an ( i ) - s * r ( i ) if ( j > n - k ) then s = max ( 0.D0 , bl ( i ) - x ( i ), x ( i ) - bu ( i )) else if ( ls ( j ) > 0 ) then s = x ( i ) - bl ( i ) else s = bu ( i ) - x ( i ) end if else !         print *,'i,s,r(i)',i,s,r(i) call saipy ( - s * r ( i ), a , la , i - n , an , n ) if ( ls ( j ) > 0 ) then s = aiscpr ( n , a , la , i - n , x , - bl ( i )) else s =- aiscpr ( n , a , la , i - n , x , - bu ( i )) end if end if if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do if ( e > tol ) write ( nout , * ) 'residual error at level 2 = ' , e , ie !     if (e>tol) stop !     if (e>1.D-6) print 4,'x =',(x(i),i=1,n) if ( e > 1.D-6 ) stop e = 0.D0 do j = 1 , n if ( abs ( an ( j )) > e ) then e = abs ( an ( j )) ie = ls ( j ) je = j end if end do !     write(nout,*)'KT condition error = ',e,je,ie,gnm if ( e > gnm * tol ) write ( nout , * ) 'KT condition error = ' , e , je , ie , gnm !     if (e>gnm*tol) write(nout,4)'KT cond_n errors = ',(an(i),i=1,n) if ( e > gnm * tol ) stop !     if (e>1.D-4) stop 1 format ( A , 15 I4 ) 2 format ( A , 5E15 . 7 ) 3 format ( A / ( 20 I4 )) 4 format ( A / ( 5E15 . 7 )) return end","tags":"","loc":"sourcefile/qlcpd.f90.html"},{"title":"denseA.f90 – filterSD","text":"Contents Functions aiscpr daiscpr aiscpri daiscpri aiscpri1 aiscpri2 ailen aij dscpr scpri dscpri Subroutines saipy isaipy isaipy1 iscatter iunscatter setaij isaxpy cscale Source Code denseA.f90 Source Code !Christen this file    denseA.f !  Copyright (C) 1996 Roger Fletcher !  Current version dated 21 May 1998 !  ****************************************** !  Specification of A in dense matrix format !  ****************************************** !  The matrix A contains gradients of the linear terms in the objective !  function (column 0) and the general constraints (columns 1:m). !  No explicit reference to simple bound constraints is required in A. !  The information is set in the parameters a(*) and la. !  In this dense case A is set in standard matrix format as a(la,0:m), where la !  is the stride between columns. la is an integer which must be greater or !  equal to n. !  In the straightforward case that la=n, columns of A follow successively !  in the space occupied by a(.). subroutine saipy ( s , a , la , i , y , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), y ( * ) !  saxpy with column i of A call mysaxpy ( s , a ( 1 , i ), y , n ) return end subroutine isaipy ( s , a , la , i , y , n , lr , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), y ( * ), lr ( * ), li ( * ) !  indirectly addressed saxpy with column i of A call isaxpy ( s , a ( 1 , i ), lr , y , n ) return end subroutine isaipy1 ( s , a , la , i , y , n , lr , li , m1 ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), y ( * ), lr ( * ), li ( * ) !  indirectly addressed saxpy with column i of A_1 call isaxpy ( s , a ( 1 , i ), lr , y , m1 ) return end !     subroutine isaipy2(s,a,la,i,y,n,lr,li,m1) !     implicit double precision (a-h,r-z), integer (i-q) !     dimension a(la,0:*),y(*),lr(*),li(*) !  indirectly addressed saxpy with column i of A_2 !     call isaxpy(s,a(1,i),lr(m1+1),y(m1+1),n-m1) !     return !     end !     subroutine ssaipy(s,a,la,i,y,n) !     implicit double precision (a-h,r-z), integer (i-q) !     dimension a(la,0:*),y(*) !  ssaxpy with column i of A !     call ssaxpy(s,a(1,i),y,n) !     return !     end !     subroutine ssaxpy(a,x,y,n) !     implicit double precision (a-h,r-z), integer (i-q) !     dimension x(*),y(*) !  saxpy with squares of x !     do i=1,n !       y(i)=y(i)+a*x(i)**2 !     end do !     return !     end function aiscpr ( n , a , la , i , x , b ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ) !  scalar product with column i of A aiscpr = scpr ( b , a ( 1 , i ), x , n ) return end function daiscpr ( n , a , la , i , x , b ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ) DOUBLE PRECISION daiscpr , dscpr daiscpr = dscpr ( b , a ( 1 , i ), x , n ) return end function aiscpri ( n , a , la , i , x , b , lr , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ), lr ( * ), li ( * ) !  indirectly addressed scalar product with column i of A aiscpri = scpri ( b , a ( 1 , i ), lr , x , n ) return end function daiscpri ( n , a , la , i , x , b , lr , li ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ), lr ( * ), li ( * ) DOUBLE PRECISION daiscpri , dscpri daiscpri = dscpri ( b , a ( 1 , i ), lr , x , n ) return end function aiscpri1 ( n , a , la , i , x , b , lr , li , m1 ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ), lr ( * ), li ( * ) !  indirectly addressed scalar product with column i of A_1 aiscpri1 = scpri ( b , a ( 1 , i ), lr , x , m1 ) return end function aiscpri2 ( n , a , la , i , x , b , lr , li , m1 ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ), lr ( * ), li ( * ) !  indirectly addressed scalar product with column i of A_2 aiscpri2 = scpri ( b , a ( 1 , i ), lr ( m1 + 1 ), x ( m1 + 1 ), n - m1 ) return end function ailen ( n , a , la , i ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ) !  L2 length of column i of A ailen = scpr ( 0.D0 , a ( 1 , i ), a ( 1 , i ), n ) ailen = sqrt ( ailen ) return end subroutine iscatter ( a , la , i , li , an , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), li ( * ), an ( * ) !  indirect scatter into vector an do j = 1 , n an ( li ( j )) = a ( j , i ) end do return end subroutine iunscatter ( a , la , i , li , an , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), li ( * ), an ( * ) !  included for compatibility with sparseA.f return end function aij ( i , j , a , la ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ) !  get element A(i,j) aij = a ( i , j ) return end subroutine setaij ( aij , i , j , a , la ) implicit double precision ( a - h , o - z ) dimension a ( la , 0 : * ) !  set element A(i,j) aij = a ( i , j ) end subroutine isaxpy ( a , x , lr , y , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension x ( * ), lr ( * ), y ( * ) !  saxpy with x indirectly addressed if ( a == 0.D0 ) return do i = 1 , n y ( i ) = y ( i ) + a * x ( lr ( i )) end do return end function dscpr ( a , x , y , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension x ( * ), y ( * ) DOUBLE PRECISION dscpr dscpr = dble ( a ) do i = 1 , n dscpr = dscpr + dble ( x ( i )) * dble ( y ( i )) end do return end function scpri ( a , x , lr , y , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension x ( * ), lr ( * ), y ( * ) !  scpr with x indirectly addressed scpri = a do i = 1 , n scpri = scpri + x ( lr ( i )) * y ( i ) end do return end function dscpri ( a , x , lr , y , n ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension x ( * ), lr ( * ), y ( * ) DOUBLE PRECISION dscpri dscpri = dble ( a ) do i = 1 , n dscpri = dscpri + dble ( x ( lr ( i ))) * dble ( y ( i )) end do return end subroutine cscale ( n , m , a , la , x , bl , bu , s , menu , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( la , 0 : * ), x ( * ), bl ( * ), bu ( * ), s ( * ) !     Constraint scaling procedure for use prior to calling bqpd when using !     denseA.f !     The user must set the parameter menu to control how the !     x-variables are scaled (or equivalently how constraints i = 1:n !     are scaled), as follows !     menu = 1 indicates that a unit scaling applies to the x-variables !     menu = 2 the user provides estimates s(i)>0 of the magnitude of !              x(i) for i = 1:n. In this case the elements  x(i), bl(i), bu(i) !              are divided by s(i) for i = 1:n. !     In all cases, cscale goes on to scale the general constraints, in !     such a way that the normal vector of each nontrivial constraint in !     the scaled problem has an l_2 norm of unity. This scaling is also !     applied to the right hand sides  bl(i), bu(i) for i = n+1:n+m. !     The scaled data overwrites the original data. !     cscale also scales the constant vector of the quadratic function, !     which is found in a(1:n). However if a non-unit x-variable scaling !     is used, it is necessary for the user to scale the Hessian matrix !     G appropriately. This can be done by passing the x-variable scale !     factors s(i) i = 1:n into the subroutine gdotx using the !     parameter ws, and multiplying G(i,j) by s(i)*s(j) (possibly !     implicitly). !     cscale sets ifail = 1 to indicate that some s(i)< = 0, !             and ifail = 2 to indicate an incorrect setting of menu. !       Otherwise ifail = 0. ifail = 2 if ( menu < 1 . or . menu > 2 ) return !     z=1.D0/log(2.D0) if ( menu == 1 ) then do j = 1 , n s ( j ) = 1.D0 end do else ifail = 1 do j = 1 , n if ( s ( j ) <= 0.D0 ) return end do !       if (menu==2) then !         do j=1,n !           s(j)=2.D0**nint(log(s(j))*z) !         end do !       end if do j = 1 , n if ( s ( j ) /= 1.D0 ) then x ( j ) = x ( j ) / s ( j ) bl ( j ) = bl ( j ) / s ( j ) bu ( j ) = bu ( j ) / s ( j ) a ( j , 0 ) = a ( j , 0 ) * s ( j ) end if end do end if do i = 1 , m t = 0.D0 do j = 1 , n a ( j , i ) = a ( j , i ) * s ( j ) t = t + a ( j , i ) ** 2 end do t = sqrt ( t ) if ( t == 0.D0 ) then s ( n + i ) = 1.D0 else !         t=2.D0**nint(log(t)*z) s ( n + i ) = t do j = 1 , n a ( j , i ) = a ( j , i ) / t end do bl ( n + i ) = bl ( n + i ) / t bu ( n + i ) = bu ( n + i ) / t end if end do ifail = 0 return end","tags":"","loc":"sourcefile/densea.f90.html"},{"title":"sparseL.f90 – filterSD","text":"Contents Functions aiscpri2 Subroutines start_up refactor pivot fbsub ztg tfbsub newg check_L aqsol eptsol order factor re_order re_factor update_L newslot erase trim_ checkout Source Code sparseL.f90 Source Code !Christen this file sparseL.f !ut here >>>>>>>>>>>>>>>>> !***************** sparse matrix routines for manipulating L ******************* !           *************************************************** !           Basis matrix routines for bqpd with sparse matrices !           *************************************************** !  These routines form and update L-Implicit-U factors LPB=U of a matrix B !  whose columns are the normal vectors of the active constraints. In this !  method only the unit lower triangular matrix L and the diagonal of U (in !  addition to the row permutation P) is stored. B is represented in block form !    | I  A_2 |    where the last m1 columns (A_2 and A_1) come from the !    | 0  A_1 |    general constraint normals (columns of the matrix A in bqpd) !  and the remaining unit columns come from simple bounds. The matrix A must be !  specified in sparse format and the user is referred to the file  sparseA.f. !  The data structure used for L is that of a profile or skyline scheme, in !  which the nontrivial rows of L are stored as dense row spikes. The use of !  a Tarjan+spk1 ordering algorithm to control the length of these spikes has !  proved quite effective. The factors are updated by a variant of the !  Fletcher-Matthews method, which has proved very reliable in practice. !  However the B matrix is re-factored every 30 updates to control growth in !  the total spike length. !  Workspace !  ********* !  The user needs to supply storage for the rows of L, although the amount !  required is unknown a-priori. !  sparse.f requires !     5*n+nprof          locations of real workspace, and !     9*n+m              locations of integer workspace !  where nprof is the space required for storing the row spikes of the L matrix. !  Storage for sparseL.f is situated at the end of the workspace arrays ws !  and lws in bqpd. !  Allow as much space for nprof as you can afford: the routine will report if !  there is not enough. So far 10&#94;6 locations has proved adequate for problems !  of up to 5000 variables. !  In addition the current version of bqpd.f requires !     kmax*(kmax+9)/2+2*n+m   locations of real workspace in ws !     kmax                    locations of integer workspace in lws !  The user is also allowed to reserve storage in ws and lws, for use in the !  user-supplied routine gdotx. This storage is situated at the start of the !  arrays ws and lws. The user specifies the amount required by !  setting the parameters kk and ll in the common block !     common/wsc/kk,ll,kkk,lll,mxws,mxlws !  The user MUST also set mxws and mxlws to be (respectively) the total amount !  of real and integer workspace for the arrays ws and lws. !  Other information !  ***************** !  The methodology behind the L-Implicit-U factors and the row spike storage !  scheme for L is described in the references !    Fletcher R., Dense Factors of Sparse Matrices, in \"Approximation Theory !    and Optimization. Tributes to M.J.D. Powell\", (M.D. Buhmann and A. Iserles, !    eds), Cambridge University Press (1997), pp. 145-166. !  and !    Fletcher R., Block Triangular Orderings and Factors for Sparse Matrices !    in LP, in \"Numerical analysis 1997\" (D.F. Griffiths, D.J. Higham and !    G.A. Watson, eds.), Pitman Research Notes in Mathematics 380, (1998), !    Longman, Harlow, pp. 91-110. !  The file contains routines for solving systems with B or its transpose !  which might be of use in association with bqpd. These routines are !  documented below. !  Steepest edge coefficients e(i) are also updated in these routines !  Copyright, University of Dundee (R.Fletcher), January 1998 !  Current version dated 16/04/02 subroutine start_up ( n , nm , nmi , a , la , nk , e , ls , aa , ll , mode , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( 0 : * ), e ( * ), ls ( * ), aa ( * ), ll ( * ) common / noutc / nout common / wsc / kk , ll_ , kkk , lll , mxws , mxlws common / epsc / eps , tol , emin common / sparsec / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 common / factorc / m1 , m2 , mp , mq , lastr , irow common / refactorc / nup , nfreq nfreq = min ( 30 , nfreq ) nup = 0 ns = kk + kkk + 5 * n nt = ll_ + lll + 8 * n + nmi nprof = mxws - ns if ( nprof . le . 0 . or . nt > mxlws ) then write ( nout , * ) 'not enough real (ws) or integer (lws) workspace' write ( nout , * ) 'you give values for mxws and mxlws as' , mxws , mxlws write ( nout , * ) 'minimum values for mxws and mxlws are' , ns , nt ifail = 7 return end if 3 format ( A / ( 20 I5 )) 4 format ( A / ( 5E15 . 7 )) !  set storage map for sparse factors ns = n ns1 = ns + 1 nt = ns + n nt1 = nt + 1 nu = nt + n nu1 = nu + 1 nx = nu + n nx1 = nx + 1 np = nx + n np1 = np + 1 lc = n lc1 = lc + 1 li = lc + n li1 = li + 1 lm = li + nmi lm1 = lm + 1 lp = lm + n lp1 = lp + 1 lq = lp + n lq1 = lq + 1 lr = lq + n lr1 = lr + 1 ls_ = lr + n ls1 = ls_ + 1 lt = ls_ + n lt1 = lt + 1 m = nm - n mp =- 1 mq =- 1 !     write(nout,*)'ls',(ls(ij),ij=1,nk) if ( mode >= 3 ) then call re_order ( n , nm , a , la ( 1 ), la ( la ( 0 )), ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , ifail ) if ( ifail >= 1 ) then !         write(nout,*)'failure in re_order (1)' if ( ifail . eq . 7 ) return mode = 2 goto 1 end if call re_factor ( n , nm , a , la , ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , aa , ifail ) if ( ifail . eq . 7 ) return call check_L ( n , aa , ll ( lp1 ), ifail ) if ( ifail . eq . 1 ) then mode = 2 goto 1 end if if ( nk . eq . n ) return !  reset ls from e do j = 1 , nk i =- ls ( j ) if ( i > 0 ) e ( i ) =- e ( i ) end do j = 0 nk = nmi do i = 1 , nmi if ( e ( i ) /= 0.D0 ) then j = j + 1 if ( e ( i ) > 0.D0 ) then ls ( j ) = i else ls ( j ) =- i e ( i ) =- e ( i ) end if else ls ( nk ) = i nk = nk - 1 end if end do if ( j /= n ) then write ( nout , * ) 'malfunction in reset sequence in start_up' stop end if return end if 1 continue if ( emin . eq . 0.D0 ) then !  set a lower bound on e(i): setting emin=0.D0 will force emin to be recalculated: do this only if mode<3 emin = 1.D0 do i = 1 , nmi - n emin = max ( emin , ailen ( n , a , la , i )) end do emin = 1.D0 / emin end if do i = 1 , n ll ( i ) = i ll ( li + i ) = i e ( i ) = 1.D0 end do do i = n + 1 , nmi ll ( li + i ) = 0 e ( i ) = 0.D0 end do nu_ = 0 if ( mode /= 0 ) then !  shift designated bounds to end and order the resulting rows and columns do j = 1 , nk i = abs ( ls ( j )) if ( i . le . n ) then nn = n - nu_ nu_ = nu_ + 1 call iexch ( ls ( nu_ ), ls ( j )) ii = ll ( li + i ) ll ( ii ) = ll ( nn ) ll ( li + ll ( ii )) = ii ll ( nn ) = i ll ( li + i ) = nn end if end do call order ( n , nu_ , nk , la , ll , ls , ll ( li1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), & aa ( np1 ), nprof , ifail ) if ( ifail > 0 ) return end if call factor ( n , nmi , nu_ , nk , a , la , e , ls , aa ( ns1 ), aa ( nt1 ), aa ( nu1 ), & aa ( nx1 ), ll , ll ( lc1 ), ll ( li1 ), ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), & ll ( ls1 ), aa ( np1 ), nprof , aa , ifail ) if ( ifail > 0 ) return !     write(nout,*)'steepest edge coefficients',(e(ij),ij=1,nm) !     emax=0.D0 !     do i=1,nm !       if(e(i)>0.D0) then !         call eptsol(n,a,la,i,a,aa(ns1),aa(nt1),aa,aa(np1), !    *      ll,ll(lc1),ll(li1),ll(lp1),ll(lq1)) !         ei=xlen(0.D0,aa(ns1),n) !         ei=sqrt(scpr(0.D0,aa(ns1),aa(ns1),n)) !         emax=max(emax,abs(ei-e(i))) !       end if !     end do !     if(emax>=tol) !    *  write(nout,*)'error in steepest edge coefficients =',emax return end subroutine refactor ( n , nm , a , la , aa , ll , ifail ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), aa ( * ), ll ( * ) common / sparsec / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls , ls1 , lt , lt1 common / factorc / m1 , m2 , mp , mq , lastr , irow common / noutc / nout !     write(nout,*)'refactor' m = nm - n call re_order ( n , nm , a , la ( 1 ), la ( la ( 0 )), ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , ifail ) if ( ifail >= 1 ) then !       write(nout,*)'failure in re_order (2)' return end if call re_factor ( n , nm , a , la , ll , ll ( lc1 ), ll ( li1 ), ll ( lm1 ), & ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , aa , ifail ) if ( ifail . eq . 7 ) return call check_L ( n , aa , ll ( lp1 ), ifail ) return end subroutine pivot ( p , q , n , nm , a , la , e , aa , ll , ifail , info ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( 0 : * ), e ( * ), aa ( * ), ll ( * ), info ( * ) common / noutc / nout common / iprintc / iprint common / sparsec / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls , ls1 , lt , lt1 common / factorc / m1 , m2 , mp , mq , lastr , irow common / mxm1c / mxm1 common / refactorc / nup , nfreq common / epsc / eps , tol , emin !     write(nout,*)'pivot: p,q =',p,q ifail = 0 if ( p /= mp ) then call eptsol ( n , a , la , p , a , aa ( ns1 ), aa ( nt1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) if ( p > n ) then e ( p ) = xlen ( 0.D0 , aa ( ns1 + m2 ), m1 ) else e ( p ) = xlen ( 1.D0 , aa ( ns1 + m2 ), m1 ) end if epp = e ( p ) mp = p end if if ( q /= mq ) then call aqsol ( n , a , la , q , a , aa ( nt1 ), aa ( nx1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) mq = q end if !  update steepest edge coefficients tp = aa ( nt + ll ( li + p )) if ( tp . eq . 0.D0 ) tp = eps ep = e ( p ) eq = 2.D0 / ep !     do i=1,m2-1 !       aa(nu+i)=0.D0 !     end do !     do i=m2,n do i = 1 , n aa ( nu + i ) = eq * aa ( ns + i ) end do call aqsol ( n , a , la , - 1 , a , aa ( nu1 ), aa ( nx1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) !     write(nout,*)'row perm',(ll(ij),ij=1,n) !     write(nout,*)'column perm',(ll(lc+ij),ij=m2+1,n) !     write(nout,*)'s =',(aa(ns+ij),ij=1,n) !     write(nout,*)'t =',(aa(nt+ij),ij=1,n) !     write(nout,*)'u =',(aa(nu+ij),ij=1,n) e ( p ) = 0.D0 eq = ep / tp do i = 1 , nm if ( e ( i ) > 0.D0 ) then j = ll ( li + i ) ei = e ( i ) wi = aa ( nt + j ) * eq awi = abs ( wi ) if ( ei >= awi ) then wi = wi / ei e ( i ) = max ( emin , ei * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - aa ( nu + j ) / ei )))) else wi = ei / wi e ( i ) = max ( emin , awi * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - aa ( nu + j ) / ei )))) end if end if end do e ( q ) = max ( emin , abs ( eq )) info ( 1 ) = info ( 1 ) + 1 if ( nup >= nfreq ) then !     if(nup>=30) then !  refactorize L ip = ll ( li + p ) if ( p > n ) then m2 = m2 + 1 qq = ll ( lc + m2 ) ll ( lc + ip ) = qq ll ( li + qq ) = ip ll ( li + p ) = 0 else ll ( ip ) = ll ( m2 ) ll ( li + ll ( ip )) = ip ll ( m2 ) = p ll ( li + p ) = m2 end if if ( q > n ) then ll ( lc + m2 ) = q ll ( li + q ) = m2 m2 = m2 - 1 else iq = ll ( li + q ) ll ( iq ) = ll ( m2 ) ll ( li + ll ( iq )) = iq ll ( m2 ) = q ll ( li + q ) = m2 end if m1 = n - m2 call re_order ( n , nm , a , la ( 1 ), la ( la ( 0 )), ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , ifail ) if ( ifail >= 1 ) then !         write(nout,*)'failure in re_order (3)' return end if call re_factor ( n , nm , a , la , ll , ll ( lc1 ), ll ( li1 ), & ll ( lm1 ), ll ( lp1 ), ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), ll ( lt1 ), aa ( np1 ), & nprof , aa , ifail ) else !  update L call update_L ( p , q , n , nm , a , la , ll , ll ( lc1 ), ll ( li1 ), ll ( lm1 ), ll ( lp1 ), & ll ( lq1 ), ll ( lr1 ), ll ( ls1 ), aa ( np1 ), nprof , aa , aa ( ns1 ), ifail ) end if if ( ifail . eq . 7 ) return mp =- 1 mq =- 1 call check_L ( n , aa , ll ( lp1 ), ifail ) !     write(nout,*)'steepest edge coefficients',(e(ij),ij=1,nm) !     emax=0.D0 !     do i=1,nm !       if(e(i)>0.D0) then !         call eptsol(n,a,la,i,a,aa(ns1),aa(nt1),aa,aa(np1), !    *      ll,ll(lc1),ll(li1),ll(lp1),ll(lq1)) !         ei=xlen(0.D0,aa(ns1),n) !         ei=sqrt(scpr(0.D0,aa(ns1),aa(ns1),n)) !         emax=max(emax,abs(ei-e(i))) !       end if !     end do !     if(emax>=tol) !    *  write(nout,*)'error in steepest edge coefficients =',emax return end subroutine fbsub ( n , jmin , jmax , a , la , q , b , x , ls , aa , ll , save ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical save dimension a ( * ), la ( * ), b ( * ), x ( * ), ls ( * ), aa ( * ), ll ( * ) !  solves a system  B.x=b !  Parameter list !  ************** !   n   number of variables (as for bqpd) !   jmin,jmax  (see description of ls below) !   a,la   specification of QP problem data (as for bqpd) !   q   an integer which, if in the range 1:n+m, specifies that the rhs vector !       b is to be column q of the matrix A of general constraint normals. !       In this case the parameter b is not referenced by fbsub. !       If q=0 then b is taken as the vector given in the parameter b. !   b(n)  must be set to the r.h.s. vector b (but only if q=0) !   x(n+m)  contains the required part of the solution x, set according to the !       index number of that component (in the range 1:n for a simple bound and !       n+1:n+m for a general constraint) !   ls(*)  an index vector, listing the components of x that are required. !       Only the absolute value of the elements of ls are used (this allows !       the possibility of using of the contents of the ls parameter of bqpd). !       Elements of x in the range abs(ls(j)), j=jmin:jmax are set by fbsub. !       These contortions allow bqpd to be independent of the basis matrix code. !   aa(*)  real storage used by the basis matrix code (supply the vector !       ws(lu1) with ws as in the call of bqpd and lu1 as in common/bqpdc/...) !   ll(*)  integer storage used by the basis matrix code (supply the vector !       lws(ll1) with lws as in the call of bqpd and ll1 as in common/bqpdc/...) !   save   indicates if fbsub is to save its copy of the solution for possible !       future use. We suggest that the user only sets save = .false. common / noutc / nout common / sparsec / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 common / factorc / m1 , m2 , mp , mq , lastr , irow !     write(nout,*)'fbsub  q =',q if ( save ) then if ( q /= mq ) then call aqsol ( n , a , la , q , b , aa ( nt1 ), aa ( nx1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) mq = q end if do j = jmin , jmax i = abs ( ls ( j )) x ( i ) = aa ( nt + ll ( li + i )) end do else call aqsol ( n , a , la , q , b , aa ( nu1 ), aa ( nx1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) do j = jmin , jmax i = abs ( ls ( j )) x ( i ) = aa ( nu + ll ( li + i )) end do end if return end subroutine ztg ( n , k , rg , lv , aa , ll ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension rg ( * ), lv ( * ), aa ( * ), ll ( * ) common / sparsec / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls_ , ls1 , lt , lt1 !     print *,'aa =',(aa(nu+i),i=1,18) do j = 1 , k rg ( j ) = aa ( nu + ll ( li + lv ( j ))) end do return end subroutine tfbsub ( n , a , la , p , b , x , aa , ll , ep , save ) implicit double precision ( a - h , r - z ), integer ( i - q ) logical save dimension a ( * ), la ( * ), b ( * ), x ( * ), aa ( * ), ll ( * ) !  solves a system  Bt.x=b !  Parameter list !  ************** !   n   number of variables (as for bqpd) !   a,la   specification of QP problem data (as for bqpd) !   p    an integer which, if in the range 1:n+m, specifies that the rhs vector !        b is a unit vector appropriate to the position of p in the current !        ordering. In this case b is not referenced by tfbsub. !   b(n+m)  If p=0, this must be set to the r.h.s. vector b. Only the components !        of b need be set, according to the index number of each component (in !        the range 1:n for a simple bound and n+1:n+m for a general constraint) !   x(n)  contains the solution x (in natural ordering) !   aa(*)  real storage used by the basis matrix code (supply the vector !       ws(lu1) with ws as in the call of bqpd and lu1 as in common/bqpdc/...) !   ll(*)  integer storage used by the basis matrix code (supply the vector !       lws(ll1) with lws as in the call of bqpd and ll1 as in common/bqpdc/...) !   ep  if p/=0 and save is true, ep contains the l_2 length of x on exit !   save  indicates if tfbsub is to save its copy of the solution for possible !       future use. We suggest that the user only sets save = .false. common / noutc / nout common / sparsec / ns , ns1 , nt , nt1 , nu , nu1 , nx , nx1 , np , np1 , nprof , & lc , lc1 , li , li1 , lm , lm1 , lp , lp1 , lq , lq1 , lr , lr1 , ls , ls1 , lt , lt1 common / factorc / m1 , m2 , mp , mq , lastr , irow !     write(nout,*)'tfbsub  p =',p if ( save ) then if ( p /= mp ) then call eptsol ( n , a , la , p , b , aa ( ns1 ), aa ( nt1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) mp = p end if do i = 1 , n x ( ll ( i )) = aa ( ns + i ) end do if ( p > n ) then ep = xlen ( 0.D0 , aa ( ns1 + m2 ), m1 ) else if ( p > 0 ) then ep = xlen ( 1.D0 , aa ( ns1 + m2 ), m1 ) end if else call eptsol ( n , a , la , p , b , aa ( nu1 ), aa ( nt1 ), aa , aa ( np1 ), & ll , ll ( lc1 ), ll ( li1 ), ll ( lp1 ), ll ( lq1 )) do i = 1 , n x ( ll ( i )) = aa ( nu + i ) end do end if !     write(nout,*)'x =',(x(i),i=1,n) return end subroutine newg common / factorc / m1 , m2 , mp , mq , lastr , irow mq =- 1 return end !******** The following routines are internal to sparseL.f ************** subroutine check_L ( n , d , p , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension d ( * ), p ( * ) common / noutc / nout common / factorc / m1 , nu , mp , mq , lastr , irow common / epsc / eps , tol , emin !     write(nout,*)'check_L' ifail = 1 !     dmin=1.D37 do k = nu + 1 , n !       dmin=min(dmin,abs(d(k))) if ( abs ( d ( k )). le . tol ) return end do !     write(nout,*)'dmin =',dmin !     len=0 !     do i=1,n !       len=len+p(i) !     end do !     write(nout,*)m1*(m1+1)/2,len+m1 !     write(nout,*)'m1 =',m1,'   file length =',len,'   total =',len+m1 ifail = 0 return end subroutine aqsol ( n , a , la , q , b , tn , xn , d , ws , lr , lc , li , pp , qq ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), b ( * ), tn ( * ), xn ( * ), d ( * ), ws ( * ), & lr ( * ), lc ( * ), li ( * ), pp ( * ), qq ( * ) common / noutc / nout common / factorc / m1 , m2 , mp , mq , lastr , irow !     write(nout,*)'aqsol  q =',q if ( q > 0 ) then do i = 1 , n tn ( i ) = 0.D0 end do if ( q . le . n ) then tn ( li ( q )) = 1.D0 else call iscatter ( a , la , q - n , li , tn , n ) end if else if ( q . eq . 0 ) then do i = 1 , n tn ( li ( i )) = b ( i ) end do end if !     write(nout,*)'tn =',(tn(i),i=1,n) do i = n , m2 + 1 , - 1 ir = lr ( i ) pri = pp ( ir ) if ( pri . eq . 0 ) then xn ( i ) = tn ( i ) / d ( i ) else xn ( i ) = ( scpr ( tn ( i ), ws ( qq ( ir ) + 1 ), tn ( i - pri ), pri )) / d ( i ) end if call isaipy ( - xn ( i ), a , la , lc ( i ) - n , tn , n , lr , li ) end do do i = m2 + 1 , n tn ( i ) = xn ( i ) end do !     write(nout,*)'tn =',(tn(i),i=1,n) return end subroutine eptsol ( n , a , la , p , b , sn , tn , d , ws , lr , lc , li , pp , qq ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( * ), b ( * ), sn ( * ), tn ( * ), d ( * ), ws ( * ), & lr ( * ), lc ( * ), li ( * ), pp ( * ), qq ( * ) common / noutc / nout common / iprintc / iprint common / epsc / eps , tol , emin common / factorc / m1 , m2 , mp , mq , lastr , irow !     write(nout,*)'eptsol  p =',p if ( p . eq . 0 ) then do i = 1 , m2 sn ( i ) = b ( lr ( i )) end do do i = m2 + 1 , n sn ( i ) = 0.D0 end do do i = m2 + 1 , n j = lc ( i ) sn ( i ) =- aiscpri ( n , a , la , j - n , sn , - b ( j ), lr , li ) / d ( i ) ir = lr ( i ) pri = pp ( ir ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( qq ( ir ) + 1 ), sn ( i - pri ), pri ) end do else do i = 1 , n sn ( i ) = 0.D0 end do pr = li ( p ) if ( p . le . n ) then if ( pr > m2 ) goto 1 sn ( pr ) = 1.D0 do i = m2 + 1 , n sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , 0.D0 , lr , li ) / d ( i ) ir = lr ( i ) pri = pp ( ir ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( qq ( ir ) + 1 ), sn ( i - pri ), pri ) end do else if ( pr . le . m2 ) goto 1 do i = m2 + 1 , n bi = 0.D0 if ( i . eq . pr ) bi =- 1.D0 sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , bi , lr , li ) / d ( i ) ir = lr ( i ) pri = pp ( ir ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( qq ( ir ) + 1 ), sn ( i - pri ), pri ) end do end if end if !     write(nout,*)'sn =',(sn(i),i=1,n) return 1 continue write ( nout , * ) 'malfunction detected in eptsol: p =' , p stop end subroutine order ( n , nu , nc , la , lr , ls , li , p , q , r , ws , mxws , ifail ) implicit integer ( c - t ) double precision ws dimension la ( 0 : * ), lr ( * ), ls ( * ), li ( * ), p ( * ), q ( * ), r ( * ), ws ( * ) common / noutc / nout !     character star(1000,80) !     write(nout,*)'order' !  spk1 ordering on full matrix ifail = 0 if ( nu . eq . n ) return !  set row and column counts and row-wise data structure nn = n - nu ii = mxws / nn do j = 1 , nn rowj = lr ( j ) p ( rowj ) = ( j - 1 ) * ii r ( rowj ) = 0 end do do j = nn + 1 , n r ( lr ( j )) = 0 end do 1 continue do i = nu + 1 , nc coli = abs ( ls ( i )) li ( coli ) = 0 jp = la ( 0 ) + coli - n do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) if ( li ( rowj ). le . nn ) then li ( coli ) = li ( coli ) + 1 r ( rowj ) = r ( rowj ) + 1 ij = p ( rowj ) + r ( rowj ) if ( ij > mxws ) then ij = mxws ifail = 1 end if ws ( ij ) = dble ( coli ) end if end do end do !  check for no overlaps qrj = 0 do j = 1 , nn rowj = lr ( j ) if ( p ( rowj ) < qrj ) ifail = 1 qrj = p ( rowj ) + r ( rowj ) q ( rowj ) = qrj p ( rowj ) = p ( rowj ) + 1 end do if ( ifail . eq . 1 . or . qrj > mxws ) then qrj = 0 do j = 1 , nn rowj = lr ( j ) p ( rowj ) = qrj qrj = qrj + r ( rowj ) r ( rowj ) = 0 end do if ( qrj > mxws ) then write ( nout , * ) 'not enough space for ws in order:  mxws =' , mxws ifail = 7 return end if ifail = 0 goto 1 end if ifirstc = nu + 1 ifirstr = 1 2 continue !  move zero-column-count columns to lhs and find minimum column count mcc = n do i = ifirstc , nc coli = abs ( ls ( i )) if ( li ( coli ). eq . 0 ) then call iexch ( ls ( i ), ls ( ifirstc )) li ( coli ) = ifirstr - 1 ifirstc = ifirstc + 1 else mcc = min ( mcc , li ( coli )) end if end do !     write(nout,*)'ifirstc,ifirstr,mcc',ifirstc,ifirstr,mcc !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'ls =',(ls(i),i=nu+1,nc) !     write(nout,*)'row counts =',(r(lr(j)),j=1,n) !     write(nout,*)'column counts =',(li(abs(ls(i))),i=nu+1,nc) if ( ifirstc > nc ) goto 4 !  apply tie-break rule tie = 0 do i = ifirstc , nc coli = abs ( ls ( i )) if ( li ( coli ). eq . mcc ) then ti = 0 jp = la ( 0 ) + coli - n do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) if ( li ( rowj ) >= ifirstr ) ti = ti + r ( rowj ) end do if ( ti > tie ) then tie = ti mccc = coli end if end if end do !     write(nout,*)'tie,mccc',tie,mccc !  permute rows of m-c-c column to top and update column counts jp = la ( 0 ) + mccc - n do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) jr = li ( rowj ) if ( jr < ifirstr ) goto 3 if ( jr > nn ) goto 3 lr ( jr ) = lr ( ifirstr ) li ( lr ( jr )) = jr lr ( ifirstr ) = rowj li ( rowj ) = ifirstr ifirstr = ifirstr + 1 do i = p ( rowj ), q ( rowj ) coli = int ( ws ( i )) li ( coli ) = li ( coli ) - 1 end do 3 continue end do goto 2 4 continue !  print star diagram !     if(nc-nu>80 .or. n>1000) stop !     write(nout,*)'spk1 ordering' !     ij=li(abs(ls(nc))) !     do i=1,ij !       do j=1,nc-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,nc-nu !       jp=la(0)+abs(ls(nu+j))-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=1,ij !       write(nout,*)(star(i,j),j=1,nc-nu) !     end do !     write(nout,*)'lr =',(lr(i),i=1,n) !     write(nout,*)'ls =',(ls(i),i=nu+1,nc) !     write(nout,*)'lower profile =',(li(abs(ls(i))),i=nu+1,nc) return end subroutine factor ( n , nm , nu , nc , a , la , e , ls , sn , tn , un , xn , lr , lc , li , & mao , p , q , r , s , ws , mxws , d , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) integer coli , r , s , rowi , rowp , tl , tu dimension a ( * ), la ( 0 : * ), e ( * ), ls ( * ), sn ( * ), tn ( * ), un ( * ), xn ( * ), & lr ( * ), lc ( * ), li ( * ), mao ( * ), p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ), d ( * ) !     character star(1000,80) common / factorc / m1 , m2 , mp , mq , lastr , irow common / iprintc / iprint common / refactorc / nup , nfreq common / epsc / eps , tol , emin common / noutc / nout parameter ( thresh = 1.D-1 ) !  factorize LPA=U when A is rectangular !    p(row) stores the number of stored elements of a natural row !    q(row) stores the base address in ws of a natural row !    r(row) stores the previous row stored in ws (or 0 if the first row in ws) !    s(row) stores the next row stored in ws (or 0 if the last row in ws) !    li(n+*) stores the lower profile of the sparse matrix !    irow stores the natural row number of the initial row stored in ws !    lastr stores the natural row number of the previous row put into ws !     write(nout,*)'factor' nup = 0 lastr = 0 irow = 0 do i = 1 , n p ( i ) = 0 end do m1 = 0 tl = 1 do ii = nu + 1 , nc coli = abs ( ls ( ii )) !       write(nout,*)'coli =',coli tu = li ( coli ) do i = 1 , n tn ( i ) = 0.D0 end do call iscatter ( a , la , coli - n , li , tn , n ) do i = m1 , 1 , - 1 rowi = lr ( i ) pri = p ( rowi ) if ( pri . eq . 0 ) then xn ( i ) = tn ( i ) / d ( i ) else xn ( i ) = ( scpr ( tn ( i ), ws ( q ( rowi ) + 1 ), tn ( i - pri ), pri )) / d ( i ) end if call isaipy ( - xn ( i ), a , la , lc ( i ) - n , tn , n , lr , li ) end do do i = 1 , m1 tn ( i ) = xn ( i ) end do m1p = m1 + 1 !       write(nout,*)'lr =',(lr(i),i=1,n) !       write(nout,*)'tn =',(tn(i),i=1,tu) !  threshold pivot selection call linf ( tu - m1 , tn ( m1p ), z , iz ) if ( z . le . tol ) then li ( coli ) = 0 goto 2 end if zz = max ( tol , z * thresh ) do i = tl , tu q ( lr ( i )) = m1p end do !       write(nout,*)'q =',(q(lr(i)),i=m1p,tu) iz = iz + m1 if ( iz < tl ) then z = 0.D0 qri = m1p do j = m1p , tu tnj = abs ( tn ( j )) if ( tnj >= zz ) then qrj = q ( lr ( j )) if ( qrj . eq . qri ) then if ( tnj > z ) then z = tnj iz = j end if else if ( qrj > qri ) then z = tnj iz = j qri = qrj end if end if end do end if tl = tu + 1 !       write(nout,*)'zz,z,iz,m1,qri',zz,z,iz,m1,qri if ( iz > m1p ) then call rexch ( tn ( m1p ), tn ( iz )) call iexch ( lr ( m1p ), lr ( iz )) li ( lr ( m1p )) = m1p li ( lr ( iz )) = iz end if rowp = lr ( m1p ) !  reset q values qrp = q ( rowp ) do i = m1p + 1 , tu if ( abs ( tn ( i )) > tol ) then rowi = lr ( i ) if ( qrp < q ( rowi )) q ( rowi ) = qrp end if end do tnp = tn ( m1p ) do i = 1 , n sn ( i ) = 0.D0 end do sn ( m1p ) = 1.D0 do i = 1 , m1 sn ( i ) =- aiscpri ( n , a , la , lc ( i ) - n , sn , 0.D0 , lr , li ) / d ( i ) rowi = lr ( i ) pri = p ( rowi ) if ( pri > 0 ) call mysaxpy ( sn ( i ), ws ( q ( rowi ) + 1 ), sn ( i - pri ), pri ) end do !       write(nout,*)'sn =',(sn(i),i=1,m1) !  update steepest edge coefficients ep = e ( rowp ) e ( rowp ) = 0.D0 eq = 2.D0 / ep do i = 1 , n un ( i ) = eq * sn ( i ) end do do i = m1 , 1 , - 1 rowi = lr ( i ) pri = p ( rowi ) if ( pri . eq . 0 ) then xn ( i ) = un ( i ) / d ( i ) else xn ( i ) = ( scpr ( un ( i ), ws ( q ( rowi ) + 1 ), un ( i - pri ), pri )) / d ( i ) end if call isaipy ( - xn ( i ), a , la , lc ( i ) - n , un , n , lr , li ) end do do i = 1 , m1 un ( i ) = xn ( i ) end do !       write(nout,*)'un =',(un(i),i=1,n) eq = ep / tnp do i = 1 , nm if ( e ( i ) > 0.D0 ) then j = li ( i ) ei = e ( i ) wi = tn ( j ) * eq awi = abs ( wi ) if ( ei >= awi ) then wi = wi / ei e ( i ) = max ( emin , ei * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - un ( j ) / ei )))) else wi = ei / wi e ( i ) = max ( emin , awi * sqrt ( max ( 0.D0 , 1.D0 + wi * ( wi - un ( j ) / ei )))) end if end if end do e ( coli ) = max ( emin , abs ( eq )) do j = qrp , m1 if ( abs ( sn ( j )) > tol ) goto 1 end do j = m1p 1 continue pri = m1p - j if ( pri > 0 ) then call newslot ( rowp , pri , lastr , irow , p , q , r , s , ws , mxws , i , ifail ) if ( ifail > 0 ) return p ( rowp ) = pri i = q ( rowp ) do j = j , m1 i = i + 1 ws ( i ) = sn ( j ) end do end if m1 = m1p ls ( m1 ) = ls ( ii ) lc ( m1 ) = coli li ( coli ) = m1 d ( m1 ) = tnp 2 continue end do !  complete ls and reorder lr, lc and d do i = m1 + 1 , n ls ( i ) = lr ( i ) end do j = n do i = 1 , nm if ( e ( i ). eq . 0.D0 ) then j = j + 1 ls ( j ) = i end if end do m2 = n - m1 do i = n , m2 + 1 , - 1 lc ( i ) = lc ( i - m2 ) li ( lc ( i )) = i lr ( i ) = lr ( i - m2 ) li ( lr ( i )) = i d ( i ) = d ( i - m2 ) end do do i = 1 , m2 lr ( i ) = ls ( m1 + i ) li ( lr ( i )) = i end do !  reset mao ilast = n ii = ilast do i = ilast , m2 + 1 , - 1 mao ( i ) = ilast ii = min ( ii , i - p ( lr ( i ))) if ( ii . eq . i ) ilast = i - 1 end do !     write(nout,*)'PAQ factors:  m1 =',m1 !     write(nout,*)'d =',(d(ij),ij=m2+1,n) !     do j=m2+1,n !       rowp=lr(j) !       if(p(rowp)/=0) then !         write(nout,*)'L(',rowp,')', !    *      (ws(k),k=q(rowp)+1,q(rowp)+p(rowp)) !       end if !     end do !  print star diagram !     write(nout,*)'factored ordering:  m1 =',m1 !     if(m1>80 .or. n>1000) stop !     do i=1,n !       do j=1,m1 !         star(i,j)=' ' !       end do !     end do !     do j=1,m1 !       jp=la(0)+lc(m2+j)-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=m2+1,n !       write(nout,*)(star(i,j),j=1,m1) !     end do !     write(nout,*)'ls =',(ls(j),j=1,n) !     write(nout,*)'s.e. coeffs =',(e(i),i=1,nm) !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'lc =',(lc(j),j=m2+1,n) !     write(nout,*)'mao =',(mao(j),j=m2+1,n) !     call checkout(n,a,la,lr,lc,li,p,q,r,s,ws,mxws,d) return end subroutine re_order ( n , nm , a , la , point , lr , lc , li , mao , p , q , r , s , & t , ws , mxws , ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) dimension a ( * ), la ( * ), point ( 0 : * ), lr ( * ), lc ( * ), li ( * ), mao ( * ), & p ( * ), q ( * ), r ( * ), s ( * ), t ( * ), ws ( * ) common / factorc / m1 , nu , mp , mq , lastr , irow common / noutc / nout logical backtrack !     character star(1000,80) !  print star diagram !     if(n-nu>80 .or. n>1000) stop !     write(nout,*)'initial ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !     write(nout,*)'re_order' if ( nu . eq . n ) then ifail = 0 return end if m = nm - n !  transversal search do iq = nu + 1 , n backtrack = . false . istack = nu inode = iq nodec = lc ( inode ) nodec_n = nodec - n lap = point ( nodec_n + 1 ) - point ( nodec_n ) !       write(nout,*)'column node =',nodec,'  look-ahead rows =', !    *    (la(j),j=point(nodec_n),point(nodec_n)+lap-1) !  look-ahead loop 1 continue lap = lap - 1 nextr = la ( point ( nodec_n ) + lap ) inext = li ( nextr ) if ( inext >= iq ) goto 4 if ( lap > 0 ) goto 1 li ( nodec ) = 0 2 continue !  reassignment depth first search t ( inode ) = point ( nodec_n + 1 ) - point ( nodec_n ) !       write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *    (la(j),j=point(nodec_n),point(nodec_n)+t(inode)-1) 3 continue !  examine successor nodes if ( t ( inode ). eq . 0 ) then if ( istack . eq . nu ) then ifail = 1 !           ifail=iq !           write(nout,*)'exit: ifail =',iq return end if istack = istack - 1 backtrack = . true . if ( istack . eq . nu ) then inode = iq else inode = mao ( istack ) end if !         write(nout,*)'backtrack to node at address =',inode nodec = lc ( inode ) nodec_n = nodec - n !         write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *      (la(j),j=point(nodec_n),point(nodec_n)+t(inode)-1) goto 3 end if t ( inode ) = t ( inode ) - 1 nextr = la ( point ( nodec_n ) + t ( inode )) inext = li ( nextr ) if ( inext . le . nu ) goto 3 if ( t ( inext ) >= 0 ) goto 3 !  extend depth first search !       write(nout,*)'nextr,inext',nextr,inext inode = inext !       write(nout,*)'put node address on stack' istack = istack + 1 mao ( istack ) = inode !       write(nout,*)'stack =',(mao(j),j=nu+1,istack) nodec = lc ( inode ) nodec_n = nodec - n lap = li ( nodec ) if ( lap . eq . 0 ) goto 2 !       write(nout,*)'column node =',nodec,'  look-ahead rows =', !    *    (la(j),j=point(nodec_n),point(nodec_n)+lap-1) goto 1 4 continue !       write(nout,*)'new assignment found in row',nextr !       write(nout,*)'istack,inext,nextr',istack,inext,nextr !       if(istack>nu) write(nout,*)'stack =',(mao(j),j=nu+1,istack) li ( nodec ) = lap !  perform row permutation lr ( inext ) = lr ( iq ) li ( lr ( inext )) = inext inode = iq do i = nu + 1 , istack inext = mao ( i ) lr ( inode ) = lr ( inext ) li ( lr ( inode )) = inode inode = inext end do lr ( inode ) = nextr li ( nextr ) = inode !       write(nout,*)'lr =',(lr(j),j=nu+1,n) !       write(nout,*)'look-ahead lengths =',(li(lc(j)),j=nu+1,iq) t ( iq ) =- 1 if ( backtrack . or . istack > nu + 1 ) then do i = nu + 1 , iq - 1 t ( i ) =- 1 end do end if do i = 1 , n if ( li ( i ) > n ) then write ( nout , * ) 'iq =' , iq stop end if end do end do !     write(nout,*)'transversal found' !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !  print star diagram !     if(n-nu>80 .or. n>1000) stop !     write(nout,*)'transversal ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !  tarjan ordering do i = 1 , n q ( i ) = 0 r ( i ) = 0 end do !  reset li and pair off columns with rows do i = nu + 1 , n nodec = lc ( i ) li ( nodec ) = i t ( lr ( i )) = nodec s ( i ) = 0 end do do i = nu + 1 , n noder = lr ( i ) nodec = t ( noder ) lc ( noder ) = point ( nodec - n + 1 ) - point ( nodec - n ) li ( nodec ) =- 1 end do ifath = nu istack = n + 1 !  tarjan loop 10 continue istack = istack - 1 inode = istack noder = lr ( inode ) if ( lc ( noder ). eq . 0 ) then write ( nout , * ) 'malfunction: zero length' stop end if nodec = t ( noder ) 11 continue li ( nodec ) = lc ( noder ) mao ( inode ) = istack !       write(nout,*)'put new node',noder,' on stack' !       write(nout,*)'active part of lr =',(lr(j),j=ifath+1,n) !       write(nout,*)'ifath,istack =',ifath,istack !       write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *    (la(j),j=point(nodec-n),point(nodec-n)+li(nodec)-1) 12 continue if ( li ( nodec ). eq . 0 ) then !           write(nout,*)'backtrack to previous nodes' 13 continue if ( inode . eq . n ) goto 14 inext = inode + 1 nextr = lr ( inext ) if ( mao ( inode ) < mao ( inext )) goto 14 inode = inext noder = nextr nodec = t ( noder ) if ( li ( nodec ). eq . 0 ) goto 13 !           write(nout,*)'stack =',(lr(j),j=istack,n) !           write(nout,*)'lengths =',(li(t(lr(j))),j=istack,n) !           write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *        (la(j),j=point(nodec-n),point(nodec-n)+li(nodec)-1) goto 12 end if !  examine successors of current node li ( nodec ) = li ( nodec ) - 1 nextr = la ( point ( nodec - n ) + li ( nodec )) inext = li ( nextr ) if ( inext . le . ifath ) goto 12 q ( nextr ) = q ( nextr ) + 1 nextc = t ( nextr ) !         write(nout,*)'nextc,nextr,inext',nextc,nextr,inext if ( li ( nextc ) >= 0 ) then mx = mao ( inext ) if ( mao ( inode ) >= mx ) goto 12 do j = istack , n if ( mao ( j ). eq . mx ) goto 12 mao ( j ) = mx end do write ( nout , * ) 'malfunction' stop end if nodec = nextc noder = nextr istack = istack - 1 inode = istack lr ( inext ) = lr ( inode ) li ( lr ( inext )) = inext lr ( inode ) = noder li ( noder ) = inode goto 11 14 continue !       write(nout,*)'strong component identified' !       write(nout,*)'active part of lr =',(lr(j),j=ifath+1,n) !       write(nout,*)'ifath,istack,inode =',ifath,istack,inode,n !  shift forward strong component inext = istack - 1 ir = inode - inext do j = istack , inode mao ( j ) = lr ( j ) end do do j = inext + ir , ifath + 1 + ir , - 1 lr ( j ) = lr ( j - ir ) li ( lr ( j )) = j end do mx = ifath + ir iq = inext - ifath ifath = ifath + 1 do j = ifath , mx lr ( j ) = mao ( j + iq ) li ( lr ( j )) = j mao ( j ) = mx end do istack = inode + 1 ifath = mx !       write(nout,*)'active part of lr =',(lr(j),j=ifath+1,n) !       write(nout,*)'ifath,istack =',ifath,istack if ( istack . le . n ) then inode = istack noder = lr ( inode ) nodec = t ( noder ) nodec_n = nodec - n !         write(nout,*)'column node =',nodec,'  unfathomed rows =', !    *      (la(j),j=point(nodec-n),point(nodec-n)+li(nodec)-1) goto 12 end if if ( ifath < n ) goto 10 !  end of tarjan process !  reset lc and li do i = nu + 1 , n lc ( i ) = t ( lr ( i )) li ( lc ( i )) = i end do !     write(nout,*)'mao =',(mao(j),j=nu+1,n) !     write(nout,*)'q =',(q(j),j=1,n) !     write(nout,*)'lr =',(lr(j),j=1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !     write(nout,*)'li =',(li(j),j=1,n+m) !  print star diagram !     if(n-nu>80 .or. n>1000) stop !     write(nout,*)'tarjan ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !  set up pointers for row-wise sparse structure p ( 1 ) = 1 do i = 1 , n - 1 p ( i + 1 ) = p ( i ) + q ( i ) q ( i ) = p ( i ) - 1 end do if ( p ( n ) + q ( n ) > mxws ) then ifail = 7 return end if q ( n ) = p ( n ) - 1 i = nu + 1 20 continue if ( i . eq . mao ( i )) then t ( i ) = i else !  spk1 ordering on tarjan block !  set row and column counts do inode = i , mao ( i ) nodec = lc ( inode ) do j = point ( nodec - n ), point ( nodec - n + 1 ) - 1 noder = la ( j ) if ( li ( noder ) >= i ) then q ( noder ) = q ( noder ) + 1 ws ( q ( noder )) = dble ( nodec ) s ( inode ) = s ( inode ) + 1 end if end do end do !       print *,'r-c counts: i =',i,'   mao(i) =',mao(i) !       print *,'q =',(q(j),j=i,mao(i)) !       print *,'s =',(s(j),j=i,mao(i)) !  find minimum-column-count column mcc = n do inode = i , mao ( i ) noder = lr ( inode ) r ( noder ) = q ( noder ) - p ( noder ) + 1 mcc = min ( mcc , s ( inode )) end do !     write(nout,*)'i,mao(i),mcc',i,mao(i),mcc !     write(nout,*)'p =',(p(lr(j)),j=i,mao(i)) !     write(nout,*)'q =',(q(lr(j)),j=i,mao(i)) !     write(nout,*)'r =',(r(lr(j)),j=i,mao(i)) !     write(nout,*)'s =',(s(j),j=i,mao(i)) !  check for fully dense block if ( mcc > mao ( i ) - i ) then do inode = i , mao ( i ) t ( inode ) = mao ( i ) end do goto 22 end if !  determine spk1 ordering ifirstr = i ifirstc = i 21 continue !  apply tie-break rule tie = 0 do inode = ifirstc , mao ( i ) if ( s ( inode ). eq . mcc ) then nodec = lc ( inode ) - n ti = 0 do j = point ( nodec ), point ( nodec + 1 ) - 1 noder = la ( j ) if ( li ( noder ) >= ifirstr ) ti = ti + r ( noder ) end do if ( ti > tie ) then tie = ti mccc = nodec end if end if end do !       write(nout,*)'tie,mccc',tie,mccc+n !  permute rows of m-c-c column to top and update column counts do j = point ( mccc ), point ( mccc + 1 ) - 1 noder = la ( j ) ir = li ( noder ) if ( ir >= ifirstr ) then lr ( ir ) = lr ( ifirstr ) li ( lr ( ir )) = ir lr ( ifirstr ) = noder li ( noder ) = ifirstr ifirstr = ifirstr + 1 do ir = p ( noder ), q ( noder ) inode = li ( int ( ws ( ir ))) s ( inode ) = s ( inode ) - 1 end do end if end do !       write(nout,*)'s =',(s(ij),ij=i,mao(i)) !       write(nout,*)'lr =',(lr(ij),ij=i,mao(i)) !  move zero-column-count columns to lhs and find minimum column count mcc = n do inode = ifirstc , mao ( i ) if ( s ( inode ). eq . 0 ) then nodec = lc ( inode ) lc ( inode ) = lc ( ifirstc ) li ( lc ( inode )) = inode lc ( ifirstc ) = nodec li ( nodec ) = ifirstc s ( inode ) = s ( ifirstc ) t ( ifirstc ) = ifirstr - 1 ifirstc = ifirstc + 1 else mcc = min ( mcc , s ( inode )) end if end do !       write(nout,*)'lc =',(lc(ij),ij=i,mao(i)) !       write(nout,*)'ifirstc,mcc',ifirstc,mcc if ( ifirstc < mao ( i )) goto 21 end if 22 continue i = mao ( i ) + 1 if ( i . le . n ) goto 20 !  print star diagram !     if(n-nu>80 .or. n>1000) stop !     write(nout,*)'tarjan + spk1 ordering' !     do i=1,n !       do j=1,n-nu !         star(i,j)=' ' !       end do !     end do !     do j=1,n-nu !       ilp=lc(nu+j)-n !       do i=point(ilp),point(ilp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,n-nu) !     end do !     write(nout,*)'lr =',(lr(j),j=nu+1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !     write(nout,*)'lower profile =',(t(j),j=nu+1,n) ifail = 0 return end subroutine re_factor ( n , nm , a , la , lr , lc , li , mao , p , q , r , s , & t , ws , mxws , d , ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) dimension a ( * ), la ( 0 : * ), lr ( * ), lc ( * ), li ( * ), mao ( * ), & p ( * ), q ( * ), r ( * ), s ( * ), t ( * ), d ( * ), ws ( * ) !     character star(1000,80) common / factorc / m1 , nu , mp , mq , lastr , irow common / iprintc / iprint common / refactorc / nup , nfreq common / epsc / eps , tol , emin common / noutc / nout double precision thresh , tol parameter ( thresh = 1.D-1 ) !  factorize LPA=U !    p(row) stores the number of stored elements of a natural row !    q(row) stores the base address in ws of a natural row !    r(row) stores the previous row stored in ws (or 0 if the first row in ws) !    s(row) stores the next row stored in ws (or 0 if the last row in ws) !    t(*) stores the lower profile of the sparse matrix !    irow stores the natural row number of the initial row stored in ws !    lastr stores the natural row number of the previous row put into ws !     write(nout,*)'re_factor' nup = 0 m = nm - n lastr = 0 irow = 0 do i = 1 , n p ( i ) = 0 end do if ( m1 . eq . 0 ) return i = nu + 1 1 continue if ( i . eq . mao ( i )) then d ( i ) = aij ( lr ( i ), lc ( i ) - n , a , la ) if ( d ( i ). eq . 0.D0 ) d ( i ) = eps !       write(nout,*)'row,col,d(i) =',lr(i),lc(i),d(i) else !       write(nout,*)'lc =',(lc(j),j=i,mao(i)) do inode = i , mao ( i ) - 1 nodec = lc ( inode ) - n im = inode - 1 !  form L.a_q z = 0. !         write(nout,*)'inode,t(inode)',inode,t(inode) do j = inode , t ( inode ) rowj = lr ( j ) prj = p ( rowj ) if ( prj > 0 ) then d ( j ) = aiscpri2 ( n , a , la , rowj , nodec , ws ( q ( rowj ) + 1 ), 1.D0 , im , & prj , li ) else d ( j ) = aij ( rowj , nodec , a , la ) end if z = max ( z , abs ( d ( j ))) end do !         write(nout,*)'d =',(d(ij),ij=inode,t(inode)) !  threshold pivot selection zz = z * thresh z = 0.D0 pri = n do j = inode , t ( inode ) dj = abs ( d ( j )) if ( dj >= zz ) then prj = p ( lr ( j )) if ( prj . eq . pri ) then if ( dj > z ) then z = dj iz = j end if else if ( prj < pri ) then z = dj iz = j pri = prj end if end if end do !       write(nout,*)'zz,z,iz,pri',zz,z,iz,pri if ( iz > inode ) then !  pivot interchange call rexch ( d ( inode ), d ( iz )) call iexch ( lr ( inode ), lr ( iz )) li ( lr ( iz )) = iz li ( lr ( inode )) = inode end if if ( d ( inode ). eq . 0.D0 ) d ( inode ) = eps !  update L qri = q ( lr ( inode )) zz =- d ( inode ) do j = inode + 1 , t ( inode ) z = d ( j ) / zz rowj = lr ( j ) prj = p ( rowj ) qrj = q ( rowj ) !  find space available in-situ in ws if ( prj . eq . 0 ) then len = 0 else if ( s ( rowj ). eq . 0 ) then len = mxws - qrj else len = q ( s ( rowj )) - qrj end if if ( abs ( z ). le . tol ) then !  special case of a zero multiplier if ( prj . eq . 0 ) goto 2 len_ = prj + 1 if ( len_ > len ) then call newslot ( rowj , len_ , lastr , irow , p , q , r , s , ws , mxws , qrj , & ifail ) if ( ifail > 0 ) return qrj_ = q ( rowj ) do k = 1 , prj ws ( qrj_ + k ) = ws ( qrj + k ) end do ws ( qrj_ + len_ ) = z else ws ( qrj + len_ ) = z end if p ( rowj ) = len_ goto 2 end if len_ = max ( pri , prj ) + 1 if ( len_ > len . or . pri > prj ) then !  create a new slot and use saxpyz ... call newslot ( rowj , len_ , lastr , irow , p , q , r , s , ws , mxws , qrj , & ifail ) if ( ifail > 0 ) return qrj_ = q ( rowj ) len = prj - pri if ( len >= 0 ) then do k = 1 , len ws ( qrj_ + k ) = ws ( qrj + k ) end do len = len + 1 call saxpyz ( z , ws ( qri + 1 ), ws ( qrj + len ), ws ( qrj_ + len ), & len_ - len ) else len =- len do k = 1 , len ws ( qrj_ + k ) = z * ws ( qri + k ) end do len = len + 1 call saxpyz ( z , ws ( qri + len ), ws ( qrj + 1 ), ws ( qrj_ + len ), & len_ - len ) end if ws ( qrj_ + len_ ) = z else !  ... else saxpy in-situ if ( pri > 0 ) & call mysaxpy ( z , ws ( qri + 1 ), ws ( qrj + prj - pri + 1 ), pri ) ws ( qrj + len_ ) = z end if p ( rowj ) = len_ !           do rj=1,n !             if(p(rj)/=0) then !               write(nout,*)'storage for row',rj,'  p,q,r,s =', !    *            p(rj),q(rj),r(rj),s(rj) !             end if !           end do 2 continue end do !         write(nout,*)'lr =',(lr(j),j=i,mao(i)) !         do j=i,mao(i) !           rowj=lr(j) !           if(p(rowj)/=0) then !             write(nout,*)'L(',rowj,')', !    *          (ws(k),k=q(rowj)+1,q(rowj)+p(rowj)) !           end if !         end do end do inode = mao ( i ) noder = lr ( inode ) pri = p ( noder ) if ( pri > 0 ) then d ( inode ) = aiscpri2 ( n , a , la , noder , lc ( inode ) - n , ws ( q ( noder ) + 1 ), & 1.D0 , inode - 1 , pri , li ) else d ( inode ) = aij ( noder , lc ( inode ) - n , a , la ) end if if ( d ( inode ). eq . 0.D0 ) d ( inode ) = eps end if i = mao ( i ) + 1 if ( i . le . n ) goto 1 !     write(nout,*)'PAQ factors:  nu =',nu !     write(nout,*)'column perm =',(lc(j),j=nu+1,n) !     write(nout,*)'row perm =',(lr(j),j=nu+1,n) !     write(nout,*)'d =',(d(ij),ij=nu+1,n) !     do j=nu+1,n !       rowj=lr(j) !       if(p(rowj)/=0) then !         write(nout,*)'L(',rowj,')', !    *      (ws(k),k=q(rowj)+1,q(rowj)+p(rowj)) !       end if !     end do !     call checkout(n,a,la,lr,lc,li,p,q,r,s,ws,mxws,d) !  print star diagram !     if(m1>80 .or. n>1000) stop !     write(nout,*)'factored tarjan + spk1 ordering:  nu =',nu !     do i=1,n !       do j=1,m1 !         star(i,j)=' ' !       end do !     end do !     do j=1,m1 !       jp=la(0)+lc(nu+j)-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,m1) !     end do !     write(nout,*)'lr =',(lr(j),j=nu+1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) mp =- 1 mq =- 1 ifail = 0 return end function aiscpri2 ( n , a , la , rowi , coli , ws , di , im , pri , li ) implicit double precision ( a - h , o - z ) dimension a ( * ), la ( 0 : * ), ws ( * ), li ( * ) integer rowi , coli , rowj , pri aiscpri2 = 0.D0 jp = la ( 0 ) + coli do j = la ( jp ), la ( jp + 1 ) - 1 rowj = la ( j ) if ( rowj . eq . rowi ) then aiscpri2 = aiscpri2 + di * a ( j ) else ir = li ( rowj ) - im if ( ir > 0 ) goto 1 ir = ir + pri if ( ir > 0 ) aiscpri2 = aiscpri2 + ws ( ir ) * a ( j ) end if 1 continue end do return end subroutine update_L ( pp , qq , n , nm , a , la , lr , lc , li , mao , p , q , r , s , & ws , mxws , d , sn , ifail ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension a ( * ), la ( 0 : * ), lr ( * ), lc ( * ), li ( * ), mao ( * ), & p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ), d ( * ), sn ( * ) !     character star(1000,80) double precision l11 , l21 integer r , s , rowim , rowi , rowj , rrj common / factorc / m1 , nu , mp , mq , lastr , irow common / refactorc / nup , nfreq common / iprintc / iprint common / epsc / eps , tol , emin common / noutc / nout parameter ( thresh = 1.D-1 , growth = 1.D1 ) !     write(nout,*)'update_L:  p,q =',pp,qq nup = nup + 1 if ( qq > n ) then ilast = nu jp = la ( 0 ) + qq - n do j = la ( jp ), la ( jp + 1 ) - 1 ip = li ( la ( j )) if ( ip > nu ) ilast = max ( ilast , mao ( ip )) end do qqq = qq else !  row flma procedure to remove row qq (includes qq amongst the unit vectors) iq = li ( qq ) if ( iq . le . nu ) goto 99 ilast = mao ( iq ) l11 = 1.D0 u11 = d ( iq ) ss =- sn ( iq ) nu = nu + 1 do i = iq , nu + 1 , - 1 lr ( i ) = lr ( i - 1 ) li ( lr ( i )) = i sn ( i ) = sn ( i - 1 ) d ( i ) = d ( i - 1 ) end do lr ( nu ) = qq li ( qq ) = nu !  update mao do j = iq - 1 , nu , - 1 if ( mao ( j ) < ilast ) goto 5 end do j = nu - 1 5 continue do j = j , nu , - 1 mao ( j + 1 ) = mao ( j ) + 1 end do prq = p ( qq ) if ( prq > 0 ) qrq = q ( qq ) do i = iq + 1 , ilast im = i - 1 rowi = lr ( i ) pri = p ( rowi ) u22 = d ( i ) if ( prq > 0 ) then u12 = aiscpri2 ( n , a , la , qq , lc ( i ) - n , ws ( qrq + 1 ), l11 , im , prq , li ) else u12 = l11 * aij ( qq , lc ( i ) - n , a , la ) end if if ( abs ( u12 ). le . tol ) u12 = 0.D0 if ( pri > 0 ) then qri = q ( rowi ) is = im - iq ii = pri - is if ( ii . le . 0 ) then l21 = 0. else l21 = ws ( qri + ii ) if ( abs ( l21 ). le . tol ) l21 = 0.D0 if ( ii . eq . 1 ) then call trim_ ( rowi , pri , qri , q , ws ) if ( pri . eq . 0 ) call erase ( rowi , lastr , irow , r , s ) if ( s ( rowi ). eq . 0 ) then qr_ = mxws else qr_ = q ( s ( rowi )) end if if ( qri + pri >= qr_ ) then call r_shift ( ws ( qri ), pri , 1 ) qri = qri - 1 q ( rowi ) = qri end if else pri = pri - 1 call r_shift ( ws ( qri + ii ), is , 1 ) end if end if p ( rowi ) = pri else l21 = 0.D0 end if rr =- l21 / l11 del = rr * u12 + u22 test = abs ( rr ) * max ( abs ( u11 ), abs ( u22 )) !         write(nout,*)'l11,l21,u11,u12,u22,del,test', !    *      l11,l21,u11,u12,u22,del,test is = pri - prq if ( is < 0 ) test = test * growth if ( u12 . eq . 0.D0 . and . is > 0 ) test = test * thresh !           write(nout,*)'rowi,pri,qri =',rowi,pri,qri !           write(nout,*)'rowq,prq,qrq =',qq,prq,qrq !           write(nout,*)'j,p(j),q(j),r(j),s(j)   irow =',irow !           do j=1,n !             if(p(j)/=0) write(nout,*)j,p(j),q(j),r(j),s(j) !           end do !           write(nout,*)'rowq =',(ws(qrq+ij),ij=1,prq) !           write(nout,*)'rowi =',(ws(qri+ij),ij=1,pri) if ( abs ( del ). le . test ) then !  no-perm operation for row flma !           write(nout,*)'no-perm operation for row flma' if ( is > 0 ) then pr_ = prq prq = pri + 1 call newslot ( qq , prq , lastr , irow , p , q , r , s , ws , mxws , qr_ , ifail ) if ( ifail > 0 ) return qrq = q ( qq ) qri = q ( rowi ) call r_shift ( ws ( qrq + 1 ), pri , qri - qrq ) call mysaxpy ( rr , ws ( qr_ + 1 ), ws ( qri + is + 1 ), pr_ ) else if ( prq . eq . 0 ) then call erase ( rowi , lastr , irow , r , s ) p ( rowi ) = 0 call newslot ( qq , 1 , lastr , irow , p , q , r , s , ws , mxws , qr_ , ifail ) if ( ifail > 0 ) return prq = 1 qrq = q ( qq ) else is =- is do j = 1 , is ws ( qrq + j ) = rr * ws ( qrq + j ) end do if ( pri > 0 ) then call saxpyx ( rr , ws ( qrq + is + 1 ), ws ( qri + 1 ), pri ) else call newslot ( rowi , 1 , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qri = q ( rowi ) qrq = q ( qq ) end if if ( abs ( ws ( qrq + 1 )). le . tol ) call trim_ ( qq , prq , qrq , q , ws ) !  rename qq as rowi and vice-versa if ( qri < qrq ) then if ( s ( rowi ). eq . qq ) then r ( qq ) = r ( rowi ) r ( rowi ) = qq s ( rowi ) = s ( qq ) s ( qq ) = rowi else call iexch ( r ( qq ), r ( rowi )) call iexch ( s ( qq ), s ( rowi )) r ( s ( qq )) = qq s ( r ( rowi )) = rowi end if if ( r ( qq ) > 0 ) then s ( r ( qq )) = qq else irow = qq end if if ( s ( rowi ) > 0 ) r ( s ( rowi )) = rowi else if ( s ( qq ). eq . rowi ) then r ( rowi ) = r ( qq ) r ( qq ) = rowi s ( qq ) = s ( rowi ) s ( rowi ) = qq else call iexch ( r ( rowi ), r ( qq )) call iexch ( s ( rowi ), s ( qq )) r ( s ( rowi )) = rowi s ( r ( qq )) = qq end if if ( r ( rowi ) > 0 ) then s ( r ( rowi )) = rowi else irow = rowi end if if ( s ( qq ) > 0 ) r ( s ( qq )) = qq end if call iexch ( pri , prq ) call iexch ( qri , qrq ) call iexch ( q ( rowi ), q ( qq )) if ( pri . eq . 0 ) call erase ( rowi , lastr , irow , r , s ) prq = prq + 1 end if end if p ( rowi ) = pri p ( qq ) = prq ws ( qrq + prq ) = 1.D0 d ( i ) = rr * u11 u11 = u22 l11 = l21 else !  perm operation for row flma !           write(nout,*)'perm operation for row flma' if ( rr /= 0.D0 ) then if ( is >= 0 ) then if ( prq > 0 ) then call mysaxpy ( rr , ws ( qrq + 1 ), ws ( qri + is + 1 ), prq ) if ( abs ( ws ( qri + 1 )). le . tol ) call trim_ ( rowi , pri , qri , q , ws ) if ( pri . eq . 0 ) call erase ( rowi , lastr , irow , r , s ) end if is = pri - prq else pr_ = pri pri = prq call newslot ( rowi , pri , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrq = q ( qq ) qri = q ( rowi ) is =- is do j = 1 , is ws ( qri + j ) = rr * ws ( qrq + j ) end do call saxpyz ( rr , ws ( qrq + is + 1 ), ws ( qr_ + 1 ), ws ( qri + is + 1 ), pr_ ) is = 0 end if end if p ( rowi ) = pri if ( u12 /= 0.D0 ) then u12 =- u12 / del if ( is > 0 ) then pr_ = prq prq = pri + 1 call newslot ( qq , prq , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrq = q ( qq ) qri = q ( rowi ) do j = 1 , is ws ( qrq + j ) = u12 * ws ( qri + j ) end do call saxpyz ( u12 , ws ( qri + is + 1 ), ws ( qr_ + 1 ), ws ( qrq + is + 1 ), pr_ ) ws ( qrq + prq ) = u12 goto 7 else if ( pri > 0 ) then is =- is call mysaxpy ( u12 , ws ( qri + 1 ), ws ( qrq + is + 1 ), pri ) if ( abs ( ws ( qrq + 1 )). le . tol ) then call trim_ ( qq , prq , qrq , q , ws ) if ( prq . eq . 0 ) call erase ( qq , lastr , irow , r , s ) p ( qq ) = prq end if end if end if end if if ( prq > 0 . or . u12 /= 0.D0 ) then if ( prq . eq . 0 ) then len = 0 else if ( s ( qq ). eq . 0 ) then len = mxws - qrq else len = q ( s ( qq )) - qrq end if if ( len . eq . prq ) then call newslot ( qq , prq + 1 , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrq = q ( qq ) qri = q ( rowi ) call r_shift ( ws ( qrq + 1 ), prq , qr_ - qrq ) end if prq = prq + 1 ws ( qrq + prq ) = u12 end if 7 continue p ( rowi ) = pri p ( qq ) = prq d ( i ) = del u11 = u11 * u22 / del call iexch ( lc ( i ), lc ( im )) end if !           write(nout,*)'rowi,pri,qri =',rowi,pri,qri !           write(nout,*)'rowq,prq,qrq =',qq,prq,qrq !           write(nout,*)'j,p(j),q(j),r(j),s(j)   irow =',irow !           do j=1,n !             if(p(j)/=0) write(nout,*)j,p(j),q(j),r(j),s(j) !           end do !           write(nout,*)'rowq* =',(ws(qrq+ij),ij=1,prq) !           write(nout,*)'rowi* =',(ws(qri+ij),ij=1,pri) end do if ( prq > 0 ) then !         write(nout,*)'ss,l11,ilast,n,prq',ss,l11,ilast,n,prq !         write(nout,*)'sn =',(sn(ij),ij=nu+1,n) call mysaxpy ( ss / l11 , ws ( qrq + 1 ), sn ( ilast - prq + 1 ), prq ) call erase ( qq , lastr , irow , r , s ) p ( qq ) = 0 end if qqq = lc ( ilast ) do i = ilast , nu + 1 , - 1 lc ( i ) = lc ( i - 1 ) li ( lc ( i )) = i end do !       if(pp.le.n) then !         ip=li(pp) !         write(nout,*)'check sn' !         do i=nu+1,ilast !           nodec=lc(i) !           u12=aiscpri2(n,a,la,pp,lc(i)-n,sn(nu+1),1.D0,ilast, !             ilast-nu,li) !           if(abs(u12)>tol) write(nout,*)'error,nodec =',u12,nodec !         end do !       end if !       write(nout,*)'intermediate PAQ factors:  new q =',qqq !       write(nout,*)'lr =',(lr(j),j=nu+1,n) !       write(nout,*)'lc =',(lc(j),j=nu+1,n) !       write(nout,*)'d =',(d(ij),ij=nu+1,n) !       do j=nu+1,n !         rowj=lr(j) !         if(p(rowj)/=0) then !           write(nout,*)'L(',rowj,')', !    *        (ws(k),k=q(rowj)+1,q(rowj)+p(rowj)) !         end if !       end do !       call checkout(n,a,la,lr,lc,li,p,q,r,s,ws,mxws,d) end if ip = li ( pp ) if ( pp > n ) then li ( pp ) = 0 if ( pp . eq . qqq ) goto 30 if ( ip . le . nu ) goto 99 iout = ip rowim = lr ( ip ) prim = p ( rowim ) if ( prim > 0 ) qrim = q ( rowim ) else if ( ip > nu . or . p ( pp ) > 0 ) goto 99 lr ( ip ) = lr ( nu ) li ( lr ( ip )) = ip !  check for growth in sn !       write(nout,*)'sn =',(sn(i),i=nu+1,n) iout = ilast i = nu + 1 if ( i > ilast ) goto 13 11 continue do j = i , mao ( i ) if ( abs ( sn ( j )) > growth ) then iout = i - 1 goto 13 end if end do i = mao ( i ) + 1 if ( i . le . ilast ) goto 11 13 continue do j = nu + 1 , iout if ( abs ( sn ( j )) > tol ) goto 14 end do j = iout + 1 14 continue rowim = pp prim = iout - j + 1 if ( prim > 0 ) then call newslot ( pp , prim , lastr , irow , p , q , r , s , ws , mxws , qr_ , ifail ) if ( ifail > 0 ) return p ( pp ) = prim qrim = q ( pp ) ii = qrim do j = j , iout ii = ii + 1 ws ( ii ) = sn ( j ) end do end if do i = nu , iout - 1 lr ( i ) = lr ( i + 1 ) li ( lr ( i )) = i lc ( i ) = lc ( i + 1 ) li ( lc ( i )) = i d ( i ) = d ( i + 1 ) end do lr ( iout ) = pp li ( pp ) = iout !       write(nout,*)'lr =',(lr(ij),ij=nu,iout) !       write(nout,*)'lc =',(lc(ij),ij=nu,iout-1) !       if(prim>0) write(nout,*)'L(',pp,') =',(ws(qrim+j),j=1,prim) nu = nu - 1 end if !     write(nout,*)'iout,ilast,rowim,prim =',iout,ilast,rowim,prim !  column flma operations to restore L to triangular form iswap = 0 do i = iout + 1 , ilast im = i - 1 lc ( im ) = lc ( i ) li ( lc ( im )) = im rowi = lr ( i ) pri = p ( rowi ) !       if(pri>0) write(nout,*)'L(',rowi,') =',(ws(q(rowi)+j),j=1,pri) u22 = d ( i ) if ( prim > 0 ) then u12 = aiscpri2 ( n , a , la , rowim , lc ( i ) - n , ws ( qrim + 1 ), 1.D0 , im - 1 , prim , & li ) if ( abs ( u12 ). le . tol ) u12 = 0.D0 else u12 = aij ( rowim , lc ( i ) - n , a , la ) end if if ( pri > 0 ) then !         write(nout,*)'pri,iswap',pri,iswap qri = q ( rowi ) ii = pri - iswap if ( ii . le . 0 ) then l21 = 0.D0 else l21 = ws ( qri + ii ) if ( abs ( l21 ). le . tol ) l21 = 0.D0 if ( ii . eq . 1 ) then call trim_ ( rowi , pri , qri , q , ws ) if ( pri . eq . 0 ) call erase ( rowi , lastr , irow , r , s ) if ( s ( rowi ). eq . 0 ) then qr_ = mxws else qr_ = q ( s ( rowi )) end if if ( qri + pri >= qr_ ) then call r_shift ( ws ( qri ), pri , 1 ) qri = qri - 1 q ( rowi ) = qri end if else pri = pri - 1 call r_shift ( ws ( qri + ii ), iswap , 1 ) end if p ( rowi ) = pri !           write(nout,*)'rowi =',(ws(qri+ij),ij=1,pri) end if else l21 = 0.D0 end if del = u22 - l21 * u12 test = abs ( u12 ) * max ( 1.D0 , abs ( l21 )) !       write(nout,*)'l21,u12,u22,del,test',l21,u12,u22,del,test is = pri - prim if ( is > 0 ) test = growth * test if ( l21 . eq . 0.D0 . and . is < 0 ) test = thresh * test !         write(nout,*)'rowim,prim,qrim =',rowim,prim,qrim !         write(nout,*)'rowi,pri,qri =',rowi,pri,qri !         write(nout,*)'j,p(j),q(j),r(j),s(j)   irow =',irow !         do j=1,n !           if(p(j)/=0) write(nout,*)j,p(j),q(j),r(j),s(j) !         end do !         write(nout,*)'rowim =',(ws(qrim+ij),ij=1,prim) !         write(nout,*)'rowi =',(ws(qri+ij),ij=1,pri) if ( abs ( del ). le . test ) then !  no-perm operation for column flma !         write(nout,*)'no-perm operation for column flma' rr =- u22 / u12 l21 = l21 + rr if ( abs ( l21 ). le . tol ) l21 = 0.D0 if ( is >= 0 ) then if ( prim > 0 ) then call mysaxpy ( rr , ws ( qrim + 1 ), ws ( qri + is + 1 ), prim ) if ( abs ( ws ( qri + 1 )). le . tol ) call trim_ ( rowi , pri , qri , q , ws ) if ( pri . eq . 0 ) then call erase ( rowi , lastr , irow , r , s ) p ( rowi ) = 0 end if end if if ( pri > 0 . or . l21 /= 0.D0 ) then if ( pri . eq . 0 ) then len = 0 else if ( s ( rowi ). eq . 0 ) then len = mxws - qri else len = q ( s ( rowi )) - qri end if if ( len . eq . pri ) then call newslot ( rowi , pri + 1 , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrim = q ( rowim ) qri = q ( rowi ) call r_shift ( ws ( qri + 1 ), pri , qr_ - qri ) end if pri = pri + 1 ws ( qri + pri ) = l21 end if else pr_ = pri pri = prim + 1 call newslot ( rowi , pri , lastr , irow , p , q , r , s , ws , mxws , qr_ , ifail ) ! if ( ifail > 0 ) return qrim = q ( rowim ) qri = q ( rowi ) is =- is do j = 1 , is ws ( qri + j ) = rr * ws ( qrim + j ) end do call saxpyz ( rr , ws ( qrim + is + 1 ), ws ( qr_ + 1 ), ws ( qri + is + 1 ), pr_ ) ws ( qri + pri ) = l21 end if !           write(nout,*)'rowim,prim,qrim =',rowim,prim,qrim !           write(nout,*)'rowi,pri,qri =',rowi,pri,qri !           write(nout,*)'j,p(j),q(j),r(j),s(j)   irow =',irow !           do j=1,n !             if(p(j)/=0) write(nout,*)j,p(j),q(j),r(j),s(j) !           end do !           write(nout,*)'rowim* =',(ws(qrim+ij),ij=1,prim) !           write(nout,*)'rowi* =',(ws(q(rowi)+ij),ij=1,p(rowi)) p ( rowi ) = pri rowim = rowi prim = pri qrim = qri d ( im ) = u12 !  perform accumulated cyclic permutation in subsequent rows if ( iswap > 0 ) then do j = i + 1 , ilast rowj = lr ( j ) prj = p ( rowj ) is = prj - j + i if ( is > 0 ) then qrj = q ( rowj ) if ( is > iswap ) then ii = is - iswap l21 = ws ( qrj + ii ) call r_shift ( ws ( qrj + ii ), iswap , 1 ) ws ( qrj + is ) = l21 if ( abs ( ws ( qrj + 1 )). le . tol ) call trim_ ( rowj , prj , qrj , q , ws ) if ( prj . eq . 0 ) call erase ( rowj , lastr , irow , r , s ) else prj = prj + 1 rrj = r ( rowj ) if ( rrj . eq . 0 ) then len = qrj else len = qrj - q ( rrj ) - p ( rrj ) end if if ( len > 0 ) then call r_shift ( ws ( qrj ), is , 1 ) ws ( qrj + is ) = 0.D0 qrj = qrj - 1 q ( rowj ) = qrj else call newslot ( rowj , prj , lastr , irow , p , q , r , s , ws , mxws , & qr_ , ifail ) if ( ifail > 0 ) return qrj = q ( rowj ) qrim = q ( rowim ) call r_shift ( ws ( qrj + 1 ), is , qr_ - qrj ) ws ( qrj + is + 1 ) = 0.D0 call r_shift ( ws ( qrj + is + 2 ), j - i , qr_ - qrj - 1 ) end if end if p ( rowj ) = prj !               write(nout,*)'L(',rowj,')* =',(ws(qrj+ij),ij=1,prj) end if end do end if iswap = 0 else !  perm operation for column flma !         write(nout,*)'perm operation for column flma' rr =- l21 if ( rr /= 0.D0 ) then if ( is >= 0 ) then if ( prim > 0 ) then call mysaxpy ( rr , ws ( qrim + 1 ), ws ( qri + is + 1 ), prim ) if ( abs ( ws ( qri + 1 )). le . tol ) call trim_ ( rowi , pri , qri , q , ws ) if ( pri . eq . 0 ) call erase ( rowi , lastr , irow , r , s ) end if is = pri - prim else pr_ = pri pri = prim call newslot ( rowi , pri , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrim = q ( rowim ) qri = q ( rowi ) is =- is do j = 1 , is ws ( qri + j ) = rr * ws ( qrim + j ) end do call saxpyz ( rr , ws ( qrim + is + 1 ), ws ( qr_ + 1 ), ws ( qri + is + 1 ), pr_ ) is = 0 end if end if p ( rowi ) = pri if ( u12 /= 0.D0 ) then u12 =- u12 / del if ( is > 0 ) then pr_ = prim prim = pri + 1 call newslot ( rowim , prim , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrim = q ( rowim ) qri = q ( rowi ) do j = 1 , is ws ( qrim + j ) = u12 * ws ( qri + j ) end do call saxpyz ( u12 , ws ( qri + is + 1 ), ws ( qr_ + 1 ), ws ( qrim + is + 1 ), pr_ ) ws ( qrim + prim ) = u12 goto 27 else if ( pri > 0 ) then is =- is call mysaxpy ( u12 , ws ( qri + 1 ), ws ( qrim + is + 1 ), pri ) if ( abs ( ws ( qrim + 1 )). le . tol ) then call trim_ ( rowim , prim , qrim , q , ws ) if ( prim . eq . 0 ) call erase ( rowim , lastr , irow , r , s ) p ( rowim ) = prim end if end if end if end if if ( prim > 0 . or . u12 /= 0.D0 ) then if ( prim . eq . 0 ) then len = 0 else if ( s ( rowim ). eq . 0 ) then len = mxws - qrim else len = q ( s ( rowim )) - qrim end if if ( len . eq . prim ) then call newslot ( rowim , prim + 1 , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) if ( ifail > 0 ) return qrim = q ( rowim ) qri = q ( rowi ) call r_shift ( ws ( qrim + 1 ), prim , qr_ - qrim ) end if prim = prim + 1 ws ( qrim + prim ) = u12 end if 27 continue p ( rowim ) = prim p ( rowi ) = pri !           write(nout,*)'rowim,prim,qrim =',rowim,prim,qrim !           write(nout,*)'rowi,pri,qri =',rowi,pri,qri !           write(nout,*)'j,p(j),q(j),r(j),s(j)   irow =',irow !           do j=1,n !             if(p(j)/=0) write(nout,*)j,p(j),q(j),r(j),s(j) !           end do !           write(nout,*)'rowim* =',(ws(qrim+ij),ij=1,prim) !           write(nout,*)'rowi* =',(ws(q(rowi)+ij),ij=1,p(rowi)) d ( im ) = del call iexch ( lr ( i ), lr ( i - 1 )) call iexch ( li ( lr ( i )), li ( lr ( i - 1 ))) iswap = iswap + 1 end if end do lc ( ilast ) = qqq li ( qqq ) = ilast !     write(nout,*)'rowim* =',(ws(qrim+ij),ij=1,prim) !     write(nout,*)'ilast,prim,qrim',ilast,prim,qrim if ( prim > 0 ) then d ( ilast ) = aiscpri2 ( n , a , la , rowim , qqq - n , ws ( qrim + 1 ), 1.D0 , ilast - 1 , & prim , li ) else d ( ilast ) = aij ( rowim , qqq - n , a , la ) end if !  reset mao iout = ilast do i = ilast , nu + 1 , - 1 mao ( i ) = ilast iout = min ( iout , i - p ( lr ( i ))) if ( iout . eq . i ) ilast = i - 1 end do 30 continue m1 = n - nu !     write(nout,*)'PAQ factors:  nu =',nu !     write(nout,*)'d =',(d(ij),ij=nu+1,n) !     do j=nu+1,n !       rowj=lr(j) !       if(p(rowj)/=0) then !         write(nout,*)'L(',rowj,')', !    *      (ws(k),k=q(rowj)+1,q(rowj)+p(rowj)) !       end if !     end do !     call checkout(n,a,la,lr,lc,li,p,q,r,s,ws,mxws,d) !  print star diagram !     if(m1>80 .or. n>1000) stop !     write(nout,*)'updated ordering:  nu =',nu !     do i=1,n !       do j=1,m1 !         star(i,j)=' ' !       end do !     end do !     do j=1,m1 !       jp=la(0)+lc(nu+j)-n !       do i=la(jp),la(jp+1)-1 !         star(li(la(i)),j)='*' !       end do !     end do !     do i=nu+1,n !       write(nout,*)(star(i,j),j=1,m1) !     end do !     write(nout,*)'lr =',(lr(j),j=nu+1,n) !     write(nout,*)'lc =',(lc(j),j=nu+1,n) !     write(nout,*)'mao =',(mao(j),j=nu+1,n) return 99 continue write ( nout , * ) 'malfunction in update_L:  p,q =' , pp , qq stop end subroutine newslot ( row , len , lastr , irow , p , q , r , s , ws , mxws , qr_ , & ifail ) implicit double precision ( a - h , u - z ), integer ( i - t ) parameter ( igap = 10 ) dimension p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ) common / noutc / nout !     write(nout,*)'newslot: row =',row,'   len =',len !     write(nout,*)'irow,lastr,mxws =',irow,lastr,mxws ifail = 0 if ( lastr . eq . 0 ) then if ( mxws < len ) then write ( nout , * ) 'insufficient space available for profile' ifail = 7 else irow = row q ( row ) = 0 r ( row ) = 0 s ( row ) = 0 lastr = row end if return end if igp = igap 1 continue len_ = len + igp thisr = lastr 2 continue qrow = q ( thisr ) + p ( thisr ) nextr = s ( thisr ) !     write(nout,*)'thisr,nextr,qrow,p(thisr),len_', !    *  thisr,nextr,qrow,p(thisr),len_ if ( nextr /= 0 ) then if ( q ( nextr ) >= qrow + len_ ) then !  free slot after this row goto 4 else thisr = nextr if ( thisr /= lastr ) goto 2 end if else if ( mxws - qrow >= len_ ) then !  free slot at end of ws goto 4 else if ( q ( irow ) >= len_ ) then !  free slot at beginning of ws qrow = 0 thisr = 0 nextr = irow irow = row igp = 0 goto 4 end if thisr = irow if ( thisr /= lastr ) goto 2 end if !  no free space: try minimum value of len if ( igp > 0 ) then igp = 0 goto 1 end if !  compress ws thisr = irow qrow = 0 3 continue call r_shift ( ws ( qrow + 1 ), p ( thisr ), q ( thisr ) - qrow ) q ( thisr ) = qrow qrow = qrow + p ( thisr ) if ( s ( thisr ) /= 0 ) then thisr = s ( thisr ) goto 3 end if if ( mxws < qrow + len_ ) then write ( nout , * ) 'insufficient space available for profile' write ( nout , * ) 'mxws,qrow,len_' , mxws , qrow , len_ ifail = 7 return end if !  insert at end of compressed file nextr = 0 4 continue qr_ = q ( row ) q ( row ) = qrow + igp if ( p ( row ) > 0 ) then if ( r ( row ). eq . thisr . or . s ( row ). eq . nextr ) return !  insert after row thisr and take out old row call erase ( row , lastr , irow , r , s ) end if lastr = row r ( row ) = thisr if ( thisr > 0 ) s ( thisr ) = row s ( row ) = nextr if ( nextr > 0 ) r ( nextr ) = row i = 0 return end subroutine erase ( row , lastr , irow , r , s ) !  remove slot for row from the data file implicit integer ( i - s ) dimension r ( * ), s ( * ) common / noutc / nout !     write(nout,*)'erase: row,irow,lastr =',row,irow,lastr if ( r ( row ). eq . 0 ) then if ( s ( row ). eq . 0 ) then irow = 0 lastr = 0 return end if irow = s ( row ) r ( irow ) = 0 else if ( s ( row ). eq . 0 ) then s ( r ( row )) = 0 else s ( r ( row )) = s ( row ) r ( s ( row )) = r ( row ) end if if ( row . eq . lastr ) lastr = irow return end subroutine trim_ ( rowi , pri , qri , q , ws ) !  trim leading zeros off slot for row i implicit double precision ( a - h , s - z ), integer ( i - r ) dimension q ( * ), ws ( * ) common / epsc / eps , tol , emin 1 continue qri = qri + 1 pri = pri - 1 if ( pri . eq . 0 ) return if ( abs ( ws ( qri + 1 )). le . tol ) goto 1 q ( rowi ) = qri return end subroutine checkout ( n , a , la , lr , lc , li , p , q , r , s , ws , mxws , d ) implicit double precision ( a - h , r - z ), integer ( i - q ) integer r , s , rowj , thisr dimension a ( * ), la ( * ), lr ( * ), lc ( * ), li ( * ), p ( * ), q ( * ), r ( * ), s ( * ), ws ( * ), & d ( * ) common / factorc / m1 , nu , mp , mq , lastr , irow common / noutc / nout common / epsc / eps , tol , emin !  check indexing do j = 1 , nu if ( p ( lr ( j )) /= 0 ) then write ( nout , * ) 'p(lr(j))/=0' goto 11 end if end do np = 0 do i = nu + 1 , n if ( p ( lr ( i )) > 0 ) np = np + 1 end do if ( irow > 0 ) then if ( r ( irow ) /= 0 ) then write ( nout , * ) 'r(irow)/=0' goto 11 end if thisr = irow 1 continue if ( p ( thisr ). le . 0 ) then write ( nout , * ) 'p(thisr).le.0' goto 11 end if np = np - 1 nextr = s ( thisr ) if ( nextr . eq . 0 ) then if ( q ( thisr ) + p ( thisr ) > mxws ) then write ( nout , * ) 'q(thisr)+p(thisr)>mxws' goto 11 end if else if ( r ( nextr ) /= thisr ) then write ( nout , * ) 'r(nextr)/=thisr' goto 11 end if if ( nextr /= s ( thisr )) then write ( nout , * ) 'nextr/=s(thisr)' goto 11 end if if ( q ( thisr ) + p ( thisr ) > q ( nextr )) then write ( nout , * ) 'q(thisr)+p(thisr)>q(nextr)' goto 11 end if thisr = nextr goto 1 end if end if if ( np /= 0 ) then write ( nout , * ) 'np/=0' goto 11 end if last = 0 emax = 0.D0 length = 0 do inode = nu + 1 , n nodec = lc ( inode ) !  form L.a_q rowj = lr ( inode ) prj = p ( rowj ) length = length + prj if ( prj < 0 ) then write ( nout , * ) 'prj<0' goto 11 else if ( prj . eq . 0 ) then e = abs ( aij ( rowj , nodec - n , a , la ) - d ( inode )) else e = abs ( d ( inode ) - aiscpri2 ( n , a , la , rowj , nodec - n , ws ( q ( rowj ) + 1 ), & 1.D0 , inode - 1 , prj , li )) end if !       if(e>tol) write(nout,*)'error =',e, !    *    '  inode,nodec,rowj =',inode,nodec,rowj emax = max ( emax , e ) do j = inode + 1 , n rowj = lr ( j ) prj = p ( rowj ) if ( prj > 0 ) then e = abs ( aiscpri2 ( n , a , la , rowj , nodec - n , ws ( q ( rowj ) + 1 ), 1.D0 , j - 1 , & prj , li )) else e = abs ( aij ( rowj , nodec - n , a , la )) end if !         if(e>tol) write(nout,*)'error =',e, !    *      '  inode,nodec,j,rowj =',inode,nodec,j,rowj emax = max ( emax , e ) end do end do write ( nout , * ) 'checkout:  m1 =' , m1 , '  file length =' , length if ( emax > tol ) write ( nout , * ) 'error =' , emax return 11 continue write ( nout , * ) 'thisr,nextr =' , thisr , nextr write ( nout , * ) 'i,p(i),q(i),r(i),s(i):  irow =' , irow do i = 1 , n if ( p ( i ) /= 0 ) write ( nout , * ) i , p ( i ), q ( i ), r ( i ), s ( i ) end do stop end","tags":"","loc":"sourcefile/sparsel.f90.html"},{"title":"glcpd.f90 – filterSD","text":"Contents Subroutines glcpd stmap check Source Code glcpd.f90 Source Code !Christen this file glcpd.f !ut here >>>>>>>>>>>>>>>>> !  Copyright (C) 2010 Roger Fletcher !  Current version dated 27 March 2013 !  THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC !  LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM !  CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT subroutine glcpd ( n , m , k , kmax , maxg , a , la , x , bl , bu , f , fmin , g , r , w , e , ls , & alp , lp , mlp , peq , ws , lws , cws , v , nv , rgtol , m0de , ifail , mxgr , iprint , nout ) implicit double precision ( a - h , r - z ), integer ( i - q ) !  This routine finds a KT point for the General LCP (Linearly Constrained !  Problem) !       minimize    f(x) !       subject to  l <= [I : A]t.x <= u                  (t = transpose) !  where f(x) is a given function of n variables x, to be determined. !  Lower and upper bound constraints on the variables x and the linear !  functions At.x may be supplied, where A is an n*m matrix. !  A recursive form of an active set method is used, using Wolfe's method to !  resolve degeneracy. A limited memory reduced gradient sweep method is used !  for minimization in the null space, so usually the KT point is a local !  minimizer. Matrix information is made available and processed by calls to !  external subroutines. Details of these are given in an auxiliary file !  named either 'denseL.f' or 'schurQR.f'. (schurQR.f is a more recent !  replacement for the file sparseL.f) !  parameter list  (variables in a line starting with C must be set on entry) !  ************** !  n     number of variables !  m     number of general constraints (columns of A) !  k     dimension of the null space obtained by eliminating the active !        constraints (only to be set if mode>=2). The number of constraints in !        the active set is n-k !  kmax  maximum value of k (kmax <= n) !  maxg  max number of reduced gradient vectors stored in sweep method: !        (1 < maxg <= kmax+1 when kmax>0), typically maxg = min(6,kmax+1) !  a(*)  storage of reals associated with A. This storage may be provided !        in either dense or sparse format. Refer to either denseA.f or sparseA.f !        for information on how to set a(*) and la(*). The vector c referred to !        in these files should be set to the zero vector. !  la(*) storage of integers associated with c and A !  x(n)  contains the vector of variables. Initially an estimate of the solution !        must be set, replaced by the solution (if it exists) on exit. !  bl(n+m)  vector of lower bounds for variables and general constraints !  bu(n+m)  vector of upper bounds (use numbers less than about 1.e30, and !        where possible supply realistic bounds on the x variables) !  f     returns the value of f(x) when x is a feasible solution !        Otherwise f stores the sum of constraint infeasibilities !  fmin  set a strict lower bound on f(x) (used to identify an unbounded LCP) !  g(n)  returns the gradient vector of f(x) when x is feasible !  r(n+m) workspace: stores constraint residuals (or multipliers if the !        constraint is active). The sign convention is such that these are !        nonnegative at a solution (except multipliers of equality constraints) !  w(n+m) workspace: stores denominators for ratio tests !  e(n+m) stores steepest-edge normalization coefficients: if mode>2 then !        information in this vector from a previous call should not be changed. !        (In mode 3 these values provide approximate coefficients) !  ls(n+m) stores indices of the active constraints in locations 1:n and of !        the inactive constraints in locations n+1:n+m. The simple bounds !        on the variables are indexed by 1:n and the general constraints by !        n+1:n+m. The sign of ls(j) indicates whether the lower bound (+) or !        the upper bound (-) of constraint ls(j) is currently significant. !        Within the set of active constraints, locations 1:peq store the indices !        of any equality constraints, locations peq+1:n-k store the indices of !        any inequality constraints, and locations n-k+1:n store the indices of !        any free variables (variables not on a bound, which are used to !        parametrise the null space: ls(j) is always positive in this range) !          If mode>=2, the first n-k elements of ls must be set on entry !  alp(mlp) workspace associated with recursion !  lp(mlp)  list of pointers to recursion information in ls !  mlp   maximum number of levels of recursion allowed (mlp>2: typically !        mlp=50 would usually be adequate but mlp=m is an upper bound) !  peq   pointer to the end of equality constraint indices in ls !  ws(*) real workspace for gdotx (see below), qlcpd and denseL.f (or schurQR.f) !          Set the total number in mxws (see \"Common\" below). !  lws(*) integer workspace for gdotx, qlcpd and denseL.f (or schurQR.f). !          Set the total number in mxlws (see \"Common\" below). !        The storage maps for ws and lws are set by the routine stmap below !  cws(*) character workspace (if any) needed by funct !  v(maxg) set nv estimates of the eigenvalues of the reduced Hessian of f(x) !          (for example from a previous run of glcpd). Set nv=1 and v(1)=1.D0 !          in absence of other information. New values of v are left on exit !  nv    Number of estimates in v !  rgtol required accuracy in the reduced gradient l2 norm: it is advisable not !        to seek too high accuracy - rgtol may be increased by the code if it !        is deemed to be too small, see the definition of sgnf below !  m0de  mode of operation (larger numbers imply extra information): !          0 = cold start (no other information available, takes simple !                bounds for the initial active set) !          1 = as 0 but includes all equality constraints in initial active set !          2 = user sets n-k active constraint indices in ls(j), j=1,..,n-k. !                For a general constraint the sign of ls(j) indicates which !                bound to use. For a simple bound the current value of x is used !          3 = takes active set and other information from a previous call. !                Steepest edge weights are approximated using previous values. !          4 = as 3 but it is also assumed that columns of A are unchanged !                so that factors of the basis matrix stored in ws and lws are !                valid (changes in f(x) and the vectors l and u are allowed) !        A local copy (mode) of m0de is made and may be changed by glcpd !  ifail   outcome of the process !              0 = solution obtained !              1 = unbounded problem (f(x)<fmin has occurred: note grad is not !                    evaluated in this case) !              2 = bl(i) > bu(i) for some i !              3 = infeasible problem detected in Phase 1 !              4 = line search cannot improve f (possibly increase rgtol) !              5 = mxgr gradient calls exceeded (this test is only carried !                    out at the start of each iteration) !              6 = incorrect setting of m, n, kmax, maxg, mlp, m0de or tol !              7 = not enough space in ws or lws !              8 = not enough space in lp (increase mlp) !              9 = dimension of reduced space too large (increase kmax) !             10 = maximum number of unsuccessful restarts taken !            >10= possible use by later sparse matrix codes !  mxgr  maximum number of gradient calls !  iprint  switch for diagnostic printing (0 = off, 1 = summary, !                 2 = scalar information, 3 = verbose) !  nout  channel number for output !  Storage Allocation !  ****************** !  User information about the lengths of ws and lws is supplied to glcpd in !    common/wsc/kk,ll,kkk,lll,mxws,mxlws !  kk and ll refer to the lengths of ws and lws needed by the user subroutines. !  kkk and lll are the numbers of locations used by glcpd and are set by glcpd. !  The rest of ws and lws is used by the files denseL.f or schurQR.f !  mxws and mxlws must be set to the total lengths of ws and lws available: a !  message will be given if more storage is needed. !  User subroutines !  **************** !  The user must provide two subroutines as follows !      subroutine funct(n,x,f,ws,lws,cws) !      implicit double precision (a-h,o-z) !      dimension x(*),ws(*),lws(*) !      character cws(*) !      ... !      statements to compute f(x) from x !      ... !      return !      end !      subroutine grad(n,x,g,ws,lws,cws) !      implicit double precision (a-h,o-z) !      dimension x(*),ws(*),lws(*) !      character cws(*) !      ... !      statements to compute grad.f(x) in g from x (the user !      may assume that a call of grad immediately follows one !      of funct with the same vector x.) !      ... !      return !      end !  The parameters ws, lws and cws in the above subroutines enables data to be !  passed from the user's calling program to these subroutines !  Tolerances, accuracy and diagnostics !  ************************************ !  glcpd uses tolerance and accuracy information stored in !     common/epsc/eps,tol,emin !     common/repc/sgnf,nrep,npiv,nres !     common/refactorc/mc,mxmc !     common/infoc/rgnorm,vstep,iter,npv,nfn,ngr !  eps must be set to the machine precision (unit round-off) and tol is a !  tolerance such that numbers whose absolute value is less than tol are !  truncated to zero. This tolerance strategy in the code assumes that the !  problem is well-scaled. The parameter sgnf is used to measure the maximum !  allowable relative error in gradient values. If at any stage the accuracy !  requirement rgtol < sgnf*rgnorm then rgtol is increased to sgnf*rgnorm !    The code allows one or more refinement steps after the !  calculation has terminated, to improve the accuracy of the solution, !  and a fixed number nrep of such repeats is allowed. However the code !  terminates without further repeats if no more than npiv pivots are taken. !    In case of any breakdown, the code is restarted in mode 0. !  The maximum number of unsuccessful restarts allowed is set in nres. !    The basis matrix may be refactorised on occasions, for example to prevent !  build-up of round-off in the factors or (when using schurQR.f) to limit !  the growth in the Schur complement. The maximum interval between !  refactorizations (or size of Schur complement) is set in mxmc. !    Default values are set in block data but can be reset by the user. !    infoc returns information about the progress of the method: rgnorm is the !  norm of the reduced gradient on exit, and vstep is the length of the vertical !  step in the warm start process. iter is the total number of iterations taken, !  npv is the number of pivots, nfn is the number of function evaluations, and !  ngr is the number of gradient evaluations. parameter ( ainfty = 1.D100 ) dimension a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), g ( * ), r ( * ), w ( * ), e ( * ), ls ( * ), & alp ( * ), lp ( * ), ws ( * ), lws ( * ), v ( * ) character cws ( * ) character ( len = 32 ) spaces common / lcpdc / na , na1 , nb , nb1 , krg , krg1 , kr , kr1 , & ka , ka1 , kb , kb1 , kc , kc1 , kd , kd1 , ke , ke1 , lu1 , ll1 common / epsc / eps , t0l , emin !     common/epsc/eps,tol,emin common / infoc / rgnorm , vstep , iter , npv , nfn , ngr common / repc / sgnf , nrep , npiv , nres common / wsc / kk , ll , kkk , lll , mxws , mxlws common / refactorc / mc , mxmc common / alphac / alpha , rp , pj , qqj , qqj1 logical plus 1 format ( A , 15 I5 ) 2 format ( A , 6E15 . 7 ) 3 format ( A / ( 15 I5 )) 4 format ( A / ( 5E15 . 7 )) 5 format (( 6E15 . 7 )) 6 format ( A , I5 , 2E15 . 7 ) spaces = '         ' mode = m0de tol = t0l iter = 0 npv = 0 if ( m < 0 . or . n . le . 0 . or . mlp < 2 . or . mode < 0 . or . mode > 4 . or . & kmax < 0 . or . ( kmax > 0 . and . maxg . le . 1 ) . or . tol . le . 0.D0 ) then ifail = 6 return end if rgt0l = rgtol n1 = n + 1 nm = n + m nmi = nm nfn = 0 ngr = 0 nv0 = nv if ( iprint >= 3 ) then write ( nout , 1000 ) 'lower bounds' ,( bl ( i ), i = 1 , nm ) write ( nout , 1000 ) 'upper bounds' ,( bu ( i ), i = 1 , nm ) end if irep = 0 ires = 0 do i = 1 , nm t = bu ( i ) - bl ( i ) if ( t <- tol ) then print * , 'i,bl(i),bu(i)' , i , bl ( i ), bu ( i ) ifail = 2 return else if ( t . le . tol ) then bl ( i ) = 5.D-1 * ( bl ( i ) + bu ( i )) bu ( i ) = bl ( i ) end if end do vmax = 0.D0 do i = 1 , n x ( i ) = min ( bu ( i ), max ( bl ( i ), x ( i ))) vmax = max ( vmax , bu ( i ) - bl ( i )) end do if ( mode . le . 2 ) then call stmap ( n , nm , kmax , maxg ) if ( mode == 0 ) then nk = 0 else if ( mode == 1 ) then !  collect equality c/s nk = 0 do i = 1 , nm if ( bu ( i ) == bl ( i )) then nk = nk + 1 ls ( nk ) = i end if end do !         write(nout,*)'number of eqty c/s =',nk else nk = n - k end if end if !  restarts loop 7 continue lp ( 1 ) = nm lev = 1 if ( mode . le . 3 ) then !  set up factors of basis matrix and permutation vectors ifail = mode call start_up ( n , nm , nmi , a , la , nk , e , ls , ws ( lu1 ), lws ( ll1 ), mode , ifail ) if ( ifail > 0 ) return end if 8 continue peq = 0 ig = 0 !  refinement step loop mpiv = iter + npiv ninf = 0 do i = 1 , n g ( i ) = 0.D0 end do if ( mode > 0 ) then call warm_start ( n , nm , a , la , x , bl , bu , r , ls , ws ( lu1 ), & lws ( ll1 ), ws ( na1 ), vstep ) !       print *,'vstep,vmax',vstep,vmax if ( vstep > 2.D0 * vmax ) then mpiv = 0 mode = 0 nk = 0 do i = 1 , n x ( i ) = min ( bu ( i ), max ( bl ( i ), x ( i ))) end do goto 7 end if if ( vstep > tol ) mpiv = 0 end if k = 0 !  collect free variables do j = n , 1 , - 1 i = abs ( ls ( j )) if ( i . le . n . and . x ( i ) > bl ( i ) . and . x ( i ) < bu ( i )) then call iexch ( ls ( j ), ls ( n - k )) k = k + 1 end if end do if ( mode == 0 ) then do j = 1 , n - k i = ls ( j ) if ( x ( i ) == bu ( i )) ls ( j ) =- i end do lp ( 1 ) = n goto 9 end if phase = 0 !  move inactive general c/s to the end do j = nm , n1 , - 1 i = abs ( ls ( j )) if ( i > n ) then call iexch ( ls ( j ), ls ( lp ( 1 ))) lp ( 1 ) = lp ( 1 ) - 1 end if end do call residuals ( n , n1 , lp ( 1 ), a , la , x , bl , bu , r , ls , f , g , ninf ) if ( ninf > 0 ) then gnorm = sqrt ( dble ( ninf )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) goto 15 end if 9 continue !  enter phase 1 phase = 1 !  collect active equality c/s do j = 1 , n - k i = abs ( ls ( j )) if ( bu ( i ) == bl ( i )) then peq = peq + 1 call iexch ( ls ( j ), ls ( peq )) end if end do call residuals ( n , lp ( 1 ) + 1 , nm , a , la , x , bl , bu , r , ls , f , g , ninf ) lp ( 1 ) = nm if ( ninf > 0 ) then gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) goto 15 end if 10 continue phase = 2 if ( iprint >= 1 ) write ( nout , * ) 'FEASIBILITY OBTAINED at level 1' n_inf = 0 call funct ( n , x , f , ws , lws , cws ) nfn = nfn + 1 if ( f < fmin ) goto 75 call grad ( n , x , g , ws , lws , cws ) ngr = ngr + 1 !     write(nout,4)'x =',(x(i),i=1,n) !     write(nout,4)'g =',(g(i),i=1,n) call newg gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) alpha = 1.D0 ig = 0 if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f goto 16 !  start of major iteration 15 continue if ( iprint >= 1 ) then if ( ninf == 0 ) then if ( k > 0 ) then !           write(nout,'(''pivots ='',I5, !    *        ''  level = 1    f ='',E16.8,''   k ='',I4)')npv,f,k write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8,''   rg ='',E12.4, ''  k ='',I4)' ) npv , f , rgnorm , k else write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f end if else if ( phase == 0 ) then write ( nout , '(''pivots ='',I5,''  level = 1    f ='', E16.8,''   ninfb ='',I4)' ) npv , f , ninf else write ( nout , '(''pivots ='',I5,''  level = 1    f ='', E16.8,''   ninf ='',I4)' ) npv , f , ninf end if end if 16 continue !  calculate multipliers !     print 4,'gradient =',(g(i),i=1,n) do i = 1 , nm w ( i ) = 0.D0 end do call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) call signst ( n , r , w , ls ) !  opposite bound or reset multiplier loop 20 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) !       write(nout,1000)'steepest edge coefficients', !    *    (e(abs(ls(j))),j=1,n) if ( peq > 0 . or . k > 0 ) write ( nout , 1 ) & '# active equality c/s and free variables = ' , peq , k end if !     call check(n,lp(1),nmi,kmax,g,a,la,x,bl,bu,r,ls,ws(nb1),f, !    *  ws,lws,cws,ninf,peq,k,1,p,rp) 21 continue call optest ( peq + 1 , n - k , r , e , ls , rp , pj ) if ( phase == 0 ) then !  possibly choose an active general c/s to relax (marked by rp>0) t =- 1.D1 * rp do 13 j = 1 , n i = abs ( ls ( j )) if ( i . le . n ) goto 13 if ( bu ( i ) == bl ( i ) . and . r ( i ) < 0.D0 ) then r ( i ) =- r ( i ) ls ( j ) =- ls ( j ) end if if ( r ( i ) / e ( i ). le . t ) goto 13 rp = r ( i ) t = rp / e ( i ) pj = j 13 continue end if if ( ig == 0 ) then gg = 0.D0 do j = n - k + 1 , n i = ls ( j ) gg = gg + r ( i ) ** 2 end do rgnorm = sqrt ( gg ) end if !     print 2,'rgtol,rgnorm,rp',rgtol,rgnorm,rp 25 continue if ( rgnorm . le . rgtol . and . abs ( rp ). le . gtol ) then !  allow for changes to norm(g) gnorm = sqrt ( scpr ( 0.D0 , g , g , n )) gtol = sgnf * gnorm rgtol = max ( rgt0l , gtol ) end if if ( iprint == 3 ) print 2 , 'gtol,rgtol,rgnorm,rp' , gtol , rgtol , rgnorm , rp if (( rgnorm . le . rgtol . and . abs ( rp ). le . gtol ) . or . ngr > mxgr ) then !  optimal at current level: first tidy up x do j = peq + 1 , n - k i = abs ( ls ( j )) if ( i . le . n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do do i = 1 , n x ( i ) = max ( min ( x ( i ), bu ( i )), bl ( i )) end do do j = n1 , nm i = abs ( ls ( j )) if ( r ( i ). le . tol . and . i . le . n ) then r ( i ) = 0.D0 if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do if ( ngr > mxgr ) then ifail = 5 return end if if ( iprint >= 2 ) then write ( nout , * ) 'OPTIMAL at level 1' if ( iprint >= 3 ) then !           write(nout,1000)'x variables',(x(i),i=1,n) write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , nm ) end if end if irep = irep + 1 if ( irep . le . nrep . and . iter > mpiv ) then if ( iprint >= 1 ) write ( nout , * ) 'refinement step #' , irep mode = 4 goto 8 end if if ( iprint >= 2 . and . nrep > 0 ) & write ( nout , * ) 'total number of restarts =' , ires if ( ninf > 0 ) then ifail = 3 return end if nv = nv0 ifail = 0 return end if if ( rgnorm >= abs ( rp )) then !  ignore the multiplier of c/s p and set up or continue SD steps p = 0 else p = abs ( ls ( pj )) if ( iprint >= 2 ) print 1 , 'CHOOSE p =' , p rp = r ( p ) call iexch ( ls ( pj ), ls ( n - k )) pj = n - k ig = 0 end if !     if(k==0 .or. p>n) then if ( p > 0 ) then !  compute +/- Steepest Edge (SE) search direction s in an(.) call tfbsub ( n , a , la , p , ws ( na1 ), ws ( na1 ), ws ( lu1 ), lws ( ll1 ), & e ( p ),. true .) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( ls ( pj ) < 0 ) rp =- rp if ( rp * r ( p ). le . 0.D0 ) then r ( p ) = 0.D0 goto 21 end if if ( abs ( rp - r ( p )) > 5.D-1 * max ( abs ( rp ), abs ( r ( p )))) then !       if(abs(rp-r(p))>1.D-1*gnorm) then print 2 , '1rp,r(p),rp-r(p)' , rp , r ( p ), rp - r ( p ) goto 98 end if snorm = e ( p ) plus = ls ( pj ) >= 0. eqv . rp < 0.D0 f0 = f ig = 0 else if ( ig == 0 ) then !  start up the limited memory sweep method !         if(p>0) then !  transfer c/s p into Z !           if(ls(pj)<0) then !             r(p)=-r(p) !             ls(pj)=-ls(pj) !           end if !           k=k+1 !           gg=gg+r(p)**2 !         end if ig = 1 ngv = 1 f0 = f ws ( kb1 ) = gg rgnorm = sqrt ( gg ) !         print 2,'initial rg =',(r(ls(j)),j=n-k+1,n) if ( k * ngv > kmax * maxg ) then ifail = 9 return end if call store_rg ( k , ig , ws ( krg1 ), r , ls ( n - k + 1 )) end if !  compute Steepest Descent (SD) search direction s = -Z.rg in an(.) call zprod ( k , n , a , la , ws ( na1 ), r , w , ls , ws ( lu1 ), lws ( ll1 )) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( abs ( gg + rp ) > 5.D-1 * max ( gg , abs ( rp ))) then !       if(abs(gg+rp)>1.D-2*max(gg,abs(rp))) then print 2 , 'gg,rp,gg+rp' , gg , rp , gg + rp goto 98 end if snorm = sqrt ( scpr ( 0.D0 , ws ( na1 ), ws ( na1 ), n )) plus = . true . end if !     print 4,'s (or -s if .not.plus) =',(ws(i),i=na1,na+n) !  form At.s and denominators call form_Ats ( n1 , lp ( 1 ), n , plus , a , la , ws ( na1 ), w , ls , snorm * tol ) !  return from degeneracy code 30 continue if ( iprint >= 3 ) then write ( nout , 1000 ) 'x variables' ,( x ( i ), i = 1 , n ) write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , lp ( 1 )) write ( nout , 1000 ) 'denominators' ,( w ( abs ( ls ( j ))), j = n1 , lp ( 1 )) end if 40 continue !  level 1 ratio tests amax = ainfty qj = 0 qj1 = 0 do 41 j = n - k + 1 , n i = ls ( j ) if ( i . le . 0 ) print * , 'i.le.0' if ( i . le . 0 ) goto 98 si = ws ( na + i ) if ( si == 0.D0 ) goto 41 t = abs ( si ) !       if(t.le.tol) goto 41 if ( si > 0.D0 . eqv . plus ) then z = bu ( i ) - x ( i ) if ( abs ( z ) < tol ) then z = 0.D0 x ( i ) = bu ( i ) else z = z / t end if else z = x ( i ) - bl ( i ) if ( abs ( z ) < tol ) then z = 0.D0 x ( i ) = bl ( i ) else z = z / t end if end if if ( z > amax ) goto 41 amax = z qj = j 41 continue if ( ig == 0 . and . rp < 0.D0 . and . bu ( p ) - bl ( p ) < amax ) then amax = bu ( p ) - bl ( p ) qj = pj end if if ( ninf > 0 ) then alpha1 = ainfty do 42 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi == 0.D0 ) goto 42 ri = r ( i ) if ( wi > 0.D0 ) then if ( ri < 0.D0 ) goto 42 z = ( ri + tol ) / wi else if ( ri < 0.D0 ) then z = ri / wi if ( z < alpha1 ) then alpha1 = z qj1 = j end if end if z = ( bl ( i ) - bu ( i ) + ri - tol ) / wi end if if ( z >= amax ) goto 42 amax = z qj = j 42 continue if ( qj1 > 0 . and . alpha1 . le . amax ) then !  find feasible step that zeros most infeasible c/s do 43 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi >= 0.D0 ) goto 43 ri = r ( i ) if ( ri < 0.D0 ) then z = ri / wi if ( z > alpha1 . and . z . le . amax ) then alpha1 = z qj1 = j end if end if 43 continue amax = alpha1 qj = qj1 else qj1 = 0 end if else do 44 j = n1 , lp ( 1 ) i = abs ( ls ( j )) wi = w ( i ) if ( wi == 0.D0 ) goto 44 ri = r ( i ) if ( wi > 0.D0 ) then z = ( ri + tol ) / wi else z = ( bl ( i ) - bu ( i ) + ri - tol ) / wi end if if ( z >= amax ) goto 44 amax = z qj = j 44 continue end if q = abs ( ls ( qj )) if ( iprint >= 2 . and . q /= p . and . qj > n ) & write ( nout , * ) 'q,r(q),w(q) =' , q , r ( q ), w ( q ) if ( qj > n . and . qj1 == 0 ) then if ( w ( q ) > 0.D0 ) then amax = r ( q ) / w ( q ) else amax = ( bl ( q ) - bu ( q ) + r ( q )) / w ( q ) end if end if if ( amax == 0.D0 . and . rp . le . 0.D0 ) then alpha = 0.D0 !  potential degeneracy block at level 1 if ( p == 0 ) goto 65 if ( bu ( q ) == bl ( q )) goto 70 plev = n do j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( r ( i ) == 0.D0 ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) if ( bu ( i ) > bl ( i )) r ( i ) = 1.D0 end if end do if ( plev > n1 ) then lp ( 2 ) = plev lev = 2 alp ( 1 ) = f f = 0.D0 qj = pj q = p if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,''     level = 2'', ''    f ='',E16.8)' ) npv , f goto 86 end if qj = n1 r ( q ) = 0.D0 !       print *,'only one degenerate c/s' goto 70 end if if ( ninf > 0 ) then alpha = amax if ( plus ) then call mysaxpy ( alpha , ws ( na1 ), x , n ) else call mysaxpy ( - alpha , ws ( na1 ), x , n ) end if else !  take a Ritz value off the stack !       print 4,'Ritz values =',(v(i),i=1,nv) if ( nv > 0 . and . v ( nv ) > 0.D0 ) then alpha = min ( 1.D0 / v ( nv ), amax ) nv = nv - 1 else alpha = amax nv = 0 end if !  line search alphar = amax alphal = 0.D0 dalpha = alpha fi = f fr = ainfty ggo = gg gs = rp gsi = gs !       print 2,'f0,fi,gsi,amax =',f0,fi,gsi,amax 51 continue !  calculate new x if ( plus ) then call saxpyz ( alpha , ws ( na1 ), x , ws ( nb1 ), n ) else call saxpyz ( - alpha , ws ( na1 ), x , ws ( nb1 ), n ) end if call funct ( n , ws ( nb1 ), fp , ws , lws , cws ) if ( fp < fmin ) goto 75 nfn = nfn + 1 df = f - fp !  check for lack of improvement if ( fp >= f0 ) then !         print 2,'alphal,alpha,fp =',alphal,alpha,fp if ( dalpha < 1.D-10 . and . df <- dalpha * gs ) then !           print *,'alpha too small' if ( alphal > 0.D0 ) goto 52 ifail = 4 return end if fr = fp alphar = alpha z = 5.D-1 / ( 1.D0 + df / ( gs * dalpha )) !         print 2,'df,z =',df,z dalpha = dalpha * max ( 1.D-1 , z ) alpha = alphal + dalpha nv = 0 goto 51 end if f = fp call grad ( n , ws ( nb1 ), g , ws , lws , cws ) ngr = ngr + 1 !       print 4,'new g =',(g(i),i=1,n) call newg gps = scpr ( 0.D0 , g , ws ( na1 ), n ) if (. not . plus ) gps =- gps !       print 2,'fp,gps',fp,gps !       print 2,'alphal,alpha,alphar',alphal,alpha,alphar !  check for non-positive curvature if ( alpha < amax . and . ( gps . le . gsi . or . ( gps < 2 5.D-2 * gsi . and . & ( alphal > 0.D0 . or . fr < ainfty )))) then !       if(alpha<amax .and. gps.le.gsi) then alphal = alpha if ( fr == ainfty ) then alpha = min ( alpha * 5.D0 , amax ) dalpha = alpha - alphal else dalpha = alphar - alpha z = max ( 2.D-1 , 5.D-1 / ( 1.D0 + ( f - fr ) / ( gps * dalpha ))) dalpha = dalpha * z alpha = min ( alpha + dalpha , amax ) end if gs = gps nv = 0 goto 51 end if !  end of line search 52 continue do i = 1 , n x ( i ) = ws ( nb + i ) end do if ( ig == 0 ) goto 60 ig1 = ig + 1 if ( ig1 > maxg ) ig1 = 1 call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) !       print 4,'new rg =',(w(ls(j)),j=n-k+1,n) if ( ngv < maxg ) ngv = ngv + 1 if ( k * ngv > kmax * maxg ) then ifail = 9 return end if call store_rg ( k , ig1 , ws ( krg1 ), w , ls ( n - k + 1 )) gpg = 0.D0 gg = 0.D0 do j = n - k + 1 , n i = ls ( j ) gpg = gpg + r ( i ) * w ( i ) gg = gg + w ( i ) ** 2 end do rgnorm = sqrt ( gg ) !       print 2,'gpg,gg',gpg,gg !       print 2,'f =',f call signst ( n , r , w , ls ) ws ( ka + ig ) = 1.D0 / alpha ws ( kb + ig1 ) = gg ws ( kc + ig ) = gpg if ( nv == 0 . or . gg > ggo ) then !  compute new Ritz values if ( ngv == 0 ) then nv = 1 v ( 1 ) = 1.D0 / alpha else nv = min ( ngv - 1 , k ) if ( nv . le . 0 ) print 1 , 'ngv,k,ig,nv =' , ngv , k , ig , nv if ( nv . le . 0 ) goto 98 !           print 1,'ngv,k,ig,nv =',ngv,k,ig,nv !           print 4,'G =',(ws(krg+i),i=1,k*ngv) !           print 4,'a =',(ws(ka+i),i=1,ngv) !           print 4,'b =',(ws(kb+i),i=1,ngv+1) !           print 4,'c =',(ws(kc+i),i=1,ngv) call formR ( nv , k , ig , maxg , ws ( ka1 ), ws ( kb1 ), ws ( kc1 ), ws ( kd1 ), & ws ( ke1 ), ws ( krg1 ), ws ( kr1 )) !           call checkT(nv,maxg,ws(kr1),ws(ke1),ws(kd1)) call formT ( nv , maxg , ws ( kr1 ), v , ws ( ke1 )) !           print 4,'T matrix',(v(i),i=1,nv) !             if(nv>1) print 5,(ws(ke+i),i=1,nv-1) call trid ( v , ws ( ke1 ), nv ) !           print 4,'eigenvalues of T',(v(i),i=1,nv) call insort ( nv , v ) !           print 4,'sorted eigenvalues of T',(v(i),i=1,nv) end if nv0 = nv f0 = f end if ig = ig1 end if 60 continue if ( alpha > 0.D0 ) then !  update r for inactive c/s iter = iter + 1 if ( ninf > 0 ) then n_inf = 0 ff = f f = 0.D0 do 61 j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( w ( i ) == 0.D0 ) then if ( r ( i ) >= 0.D0 ) goto 61 n_inf = n_inf + 1 f = f - r ( i ) goto 61 end if ri = r ( i ) - alpha * w ( i ) if ( abs ( ri ). le . tol ) ri = 0.D0 if ( r ( i ) < 0.D0 ) then if ( ri >= 0.D0 ) then !  remove contribution to gradient if ( i > n ) then call saipy ( sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , g , n ) else g ( i ) = 0.D0 end if else n_inf = n_inf + 1 f = f - ri end if end if if ( w ( i ) < 0.D0 ) then ro = ( bu ( i ) - bl ( i )) - ri if ( abs ( ro ). le . tol ) ro = 0.D0 if ( ro < ri ) then ri = ro ls ( j ) =- ls ( j ) end if end if if ( ri == 0.D0 . and . i . le . n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if r ( i ) = ri 61 continue if ( n_inf /= ninf ) then call iexch ( ninf , n_inf ) call newg !         else if(f>=ff) then else if ( f >= eps * ff + ff ) then goto 98 end if else n_inf = 0 do 62 j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( w ( i ) == 0.D0 ) goto 62 ri = r ( i ) - alpha * w ( i ) if ( w ( i ) < 0.D0 ) then ro = ( bu ( i ) - bl ( i )) - ri if ( ro < ri ) then ri = ro w ( i ) =- w ( i ) ls ( j ) =- ls ( j ) end if end if if ( ri . le . tol ) then ri = 0.D0 if ( i . le . n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end if r ( i ) = ri 62 continue end if end if if ( alpha < amax ) then if ( ig > 0 ) then !  continue limited memory SD iterations if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8,''   rg ='',E12.4, ''  k ='',I4)' ) npv , f , rgnorm , k if ( alpha > 0.D0 ) goto 20 print * , 'alpha.le.0' goto 98 end if !  Cauchy step with SE iteration k = k + 1 if ( p . le . n ) then ls ( pj ) = p goto 15 end if !  case p>n: find best inactive simple bound to replace p in ls(pj) t = 0.D0 do j = n1 , lp ( 1 ) i = abs ( ls ( j )) if ( i . le . n ) then ti = abs ( ws ( na + i )) if ( ti > t ) then t = ti qj = j end if end if end do if ( t . le . snorm * tol ) then print * , 'no suitable simple bound available' goto 98 end if q = abs ( ls ( qj )) ls ( qj ) = q if ( iprint >= 2 ) write ( nout , 1 ) 'New free variable' , q goto 70 end if 65 continue if ( iprint >= 2 ) & write ( nout , * ) 'New active c/s:  alpha =' , alpha , '   q =' , q if ( ig > 0 ) then !  case alpha=amax and SD step: find best free variable to relax k = k - 1 if ( qj . le . n ) then !  case: q is a free variable if ( ws ( na + q ) > 0.D0 ) ls ( qj ) =- q call iexch ( ls ( qj ), ls ( n - k )) ig = 0 if ( n_inf > 0 . and . ninf == 0 ) goto 10 goto 15 end if call fbsub ( n , n - k , n , a , la , q , w , w , ls , ws ( lu1 ), lws ( ll1 ),. false .) !       print 4,'w(n-k:n) =',(w(ls(j)),j=n-k,n) t = 0.D0 do j = n - k , n i = ls ( j ) ti = abs ( w ( i )) / e ( i ) if ( ti > t ) then t = ti pj = j end if end do if ( t . le . tol ) then print * , 'no suitable free variable to relax' goto 98 end if p = ls ( pj ) call iexch ( ls ( pj ), ls ( n - k )) pj = n - k if ( iprint >= 2 ) write ( nout , * ) 'relax free variable' , p end if !  return from degeneracy with an equality c/s 70 continue if ( qj /= pj ) then !  pivot interchange if ( iprint >= 2 ) write ( nout , * ) 'replace' , p , ' by' , q if ( p == 0 ) print * , 'p==0' if ( p == 0 ) goto 98 call pivot ( p , q , n , nmi , a , la , e , ws ( lu1 ), lws ( ll1 ), ifail , npv ) if ( ifail >= 1 ) then !         if(ifail>=2) return if ( ifail == 7 ) return if ( iprint >= 1 ) write ( nout , * ) 'failure detected in pivot (1)' !         print *,'r(q),w(q),q',r(q),w(q),q goto 98 end if if ( rp > 0.D0 ) then if ( phase > 0 ) print * , 'phase =' , phase call iexch ( ls ( pj ), ls ( qj )) call iexch ( ls ( lp ( 1 )), ls ( qj )) lp ( 1 ) = lp ( 1 ) - 1 if ( ninf > 0 ) goto 15 goto 9 end if if ( ig > 0 ) then ri = x ( p ) - bl ( p ) ro = bu ( p ) - x ( p ) if ( ro < ri ) then ri = ro ls ( pj ) =- p end if if ( ri . le . tol ) ri = 0.D0 r ( p ) = ri ig = 0 else rpu = max ( bu ( p ) - bl ( p ) - alpha , 0.D0 ) if ( alpha . le . rpu ) then rpu = alpha else ls ( pj ) =- ls ( pj ) end if if ( abs ( rpu ). le . tol ) rpu = 0.D0 r ( p ) = rpu end if !       print 2,'r(p)',r(p) call iexch ( ls ( pj ), ls ( qj )) if ( phase > 0 . and . bu ( q ) == bl ( q )) then peq = peq + 1 call iexch ( ls ( pj ), ls ( peq )) end if if ( ninf == 0 ) then if ( phase == 0 ) goto 9 if ( phase == 1 ) goto 10 end if goto 15 end if !  opposite bound comes active if ( ninf == 0 ) then if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8)' ) npv , f else if ( phase == 0 ) then if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8,''   ninfb ='',I4)' ) & npv , f , ninf else if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5, ''  level = 1    f ='',E16.8,''   ninf ='',I4)' ) & npv , f , ninf end if ls ( pj ) =- ls ( pj ) if ( ninf == 0 . or . ninf /= n_inf ) goto 16 r ( p ) =- rp goto 20 !  unbounded solution case 75 continue irep = irep + 1 if ( irep . le . nrep . and . iter > mpiv ) then mode = 4 if ( iprint >= 1 ) write ( nout , * ) & 'unbounded solution identified: refinement step #' , irep goto 8 end if ifail = 1 !  tidy up x do i = 1 , n x ( i ) = max ( min ( x ( i ), bu ( i )), bl ( i )) end do do j = n1 , nm i = abs ( ls ( j )) if ( r ( i ) == 0.D0 . and . i . le . n ) then if ( ls ( j ) >= 0 ) then x ( i ) = bl ( i ) else x ( i ) = bu ( i ) end if end if end do nv = nv0 return !  recursive code for resolving degeneracy (Wolfe's method) 80 continue !  calculate multipliers call fbsub ( n , 1 , n , a , la , 0 , g , w , ls , ws ( lu1 ), lws ( ll1 ),. true .) call signst ( n , r , w , ls ) !  reset multiplier loop 82 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) !       write(nout,1000)'steepest edge coefficients', !    *    (e(abs(ls(j))),j=1,n) if ( peq > 0 . or . k > 0 ) write ( nout , 1 ) & '# active equality c/s and free variables = ' , peq , k end if 84 continue call optest ( peq + 1 , n - k , r , e , ls , rp , pj ) if ( - rp . le . gtol ) then if ( iprint >= 2 ) write ( nout , * ) 'return to level 1' lev = 1 f = alp ( 1 ) do j = n1 , lp ( 2 ) r ( abs ( ls ( j ))) = 0.D0 end do lev = 1 if ( rp == 0.D0 . and . phase > 0 ) goto 25 goto 20 end if call iexch ( ls ( pj ), ls ( n - k )) pj = n - k plus = ls ( pj ) >= 0 p = abs ( ls ( pj )) rp = r ( p ) !  compute search direction s in an(.) call tfbsub ( n , a , la , p , ws ( na1 ), ws ( na1 ), ws ( lu1 ), lws ( ll1 ), & e ( p ),. true .) rp = scpr ( 0.D0 , ws ( na1 ), g , n ) if ( ls ( pj ) < 0 ) rp =- rp if ( rp * r ( p ). le . 0.D0 ) then r ( p ) = 0.D0 goto 84 end if if ( abs ( rp - r ( p )) > 5.D-1 * max ( abs ( rp ), abs ( r ( p )))) then !       if(abs(rp-r(p))>1.D-1*gnorm) then print 2 , '2rp,r(p),rp-r(p)' , rp , r ( p ), rp - r ( p ) goto 98 end if snorm = e ( p ) !  form At.s and denominators call form_Ats ( n1 , lp ( lev ), n , plus , a , la , ws ( na1 ), w , ls , snorm * tol ) 86 continue if ( iprint >= 3 ) then write ( nout , 1001 ) 'residual vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = n1 , lp ( lev )) write ( nout , 1000 ) 'denominators' ,( w ( abs ( ls ( j ))), j = n1 , lp ( lev )) end if 88 continue !  ratio test at higher levels alpha = ainfty qj = 0 do 90 j = n1 , lp ( lev ) i = abs ( ls ( j )) wi = w ( i ) if ( wi . le . 0.D0 ) goto 90 if ( r ( i ) < 0.D0 ) goto 90 z = ( r ( i ) + tol ) / wi if ( z >= alpha ) goto 90 alpha = z qj = j 90 continue if ( qj == 0 ) then do j = n1 , lp ( lev ) i = abs ( ls ( j )) w ( i ) = min ( w ( i ), 0.D0 ) r ( i ) = 0.D0 end do call form_Ats ( lp ( lev ) + 1 , lp ( lev - 1 ), n , plus , a , la , ws ( na1 ), & w , ls , snorm * tol ) lev = lev - 1 f = alp ( lev ) if ( iprint >= 2 ) write ( nout , * ) 'UNBOUNDED:   p =' , p , & '   return to level' , lev if ( lev > 1 ) goto 86 if ( iprint >= 3 ) then write ( nout , 1001 ) 'costs vector and indices' , & ( ls ( j ), r ( abs ( ls ( j ))), j = 1 , n ) if ( peq > 0 . or . k > 0 ) print 1 , & '# active equality c/s and free variables = ' , peq , k end if !       call check(n,lp(1),nmi,kmax,g,a,la,x,bl,bu,r,ls,ws(nb1),f, !    *    ws,lws,cws,ninf,peq,k,1,p,rp) goto 30 end if q = abs ( ls ( qj )) alpha = r ( q ) / w ( q ) ff = f + alpha * rp if ( iprint >= 2 ) then write ( nout , * ) 'alpha =' , alpha , '   p =' , p , '   q =' , q write ( nout , 2 ) 'r(p),r(q),w(q) =' , r ( p ), r ( q ), w ( q ) end if !  test for equality c/s if ( bu ( q ) == bl ( q )) then do j = n1 , lp ( 2 ) r ( abs ( ls ( j ))) = 0.D0 end do lev = 1 f = alp ( 1 ) alpha = 0.D0 if ( iprint >= 2 ) write ( nout , * ) 'EQTY:   p =' , p , '   q =' , q , & '   return to level 1' goto 70 end if if ( alpha == 0.D0 ) then !  potential degeneracy block at level lev if ( lev + 2 > mlp ) then ifail = 8 return end if r ( q ) = 0.D0 plev = n do j = n1 , lp ( lev ) i = abs ( ls ( j )) if ( r ( i ) == 0.D0 ) then plev = plev + 1 call iexch ( ls ( j ), ls ( plev )) if ( bu ( i ) > bl ( i )) r ( i ) = 1.D0 end if end do if ( plev > n1 ) then lev = lev + 1 lp ( lev ) = plev alp ( lev ) = f f = 0.D0 if ( iprint >= 2 ) write ( nout , * ) 'degeneracy: increase level to ' , lev if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,A,''level ='',I2, ''    f ='',E16.8)' ) npv , spaces (: 3 * lev - 1 ), lev , f goto 86 end if qj = n1 end if iter = iter + 1 if ( iprint >= 2 ) write ( nout , * ) 'replace' , p , ' by' , q call pivot ( p , q , n , nmi , a , la , e , ws ( lu1 ), lws ( ll1 ), ifail , npv ) if ( ifail >= 1 ) then !       if(ifail>=2) return if ( ifail == 7 ) return !       call iexch(ls(pj),ls(qj)) if ( iprint >= 1 ) write ( nout , * ) 'failure detected in pivot (2)' !       print *,'r(q),w(q),q',r(q),w(q),q goto 98 end if !  update r and f do j = n1 , lp ( lev ) i = abs ( ls ( j )) ri = r ( i ) - alpha * w ( i ) if ( abs ( ri ). le . tol ) ri = 0.D0 r ( i ) = ri end do f = ff !  exchange a constraint r ( p ) = alpha if ( r ( p ). le . tol ) r ( p ) = 0.D0 call iexch ( ls ( pj ), ls ( qj )) if ( iprint >= 1 ) write ( nout , '(''pivots ='',I5,A,''level ='',I2, ''    f ='',E16.8)' ) npv , spaces (: 3 * lev - 1 ), lev , f goto 80 !  restart sequence 98 continue do i = 1 , n x ( i ) = min ( bu ( i ), max ( bl ( i ), x ( i ))) end do nk = peq do j = peq + 1 , n - k i = abs ( ls ( j )) if ( i > n ) then nk = nk + 1 ls ( nk ) = ls ( j ) end if end do k = n - nk mode = 2 ires = ires + 1 if ( iprint >= 1 ) write ( nout , * ) 'major restart #' , ires tol = 1.D1 * tol if ( ires . le . nres ) goto 7 ifail = 10 return 1000 format ( a / ( e16 . 5 , 4e16 . 5 )) 1001 format ( a / ( i4 , 1 x , e12 . 5 , 4 ( i4 , 1 x , e12 . 5 ))) !1000 format(a/(e18.8,3e19.8)) !1001 format(a/(i3,1x,e14.8,3(i4,1x,e14.8))) end !     block data defaults !     implicit double precision (a-h,o-z) !     common/epsc/eps,tol,emin !     common/repc/sgnf,nrep,npiv,nres !     common/refactorc/mc,mxmc !     common/wsc/kk,ll,kkk,lll,mxws,mxlws !     data  eps,    tol,   emin, sgnf, nrep, npiv, nres, mxmc, kk, ll !    * /1111.D-19, 1.D-12, 0.D0, 1.D-8,  2,    3,   2,   500,   0,  0/ !     end subroutine stmap ( n , nm , kmax , maxg ) !  set storage map for workspace in glcpd and auxiliary routines implicit double precision ( a - h , r - z ), integer ( i - q ) common / wsc / kk , ll , kkk , lll , mxws , mxlws common / lcpdc / na , na1 , nb , nb1 , krg , krg1 , kr , kr1 , & ka , ka1 , kb , kb1 , kc , kc1 , kd , kd1 , ke , ke1 , lu1 , ll1 !  double precision storage (ws) !  locations 1:kk are user workspace for funct and grad !  scratch slots of length n+m and n na = kk na1 = kk + 1 nb = na + nm nb1 = nb + 1 !  workspace of length kmax*maxg for reduced gradient vectors krg = nb + n krg1 = krg + 1 !  a slot of length maxg*(maxg+1)/2 and 5 slots of length maxg for sweep method kr = krg + kmax * maxg kr1 = kr + 1 ka = kr + maxg * ( maxg + 1 ) / 2 ka1 = ka + 1 kb = ka + maxg kb1 = kb + 1 kc = kb + maxg kc1 = kc + 1 kd = kc + maxg kd1 = kd + 1 ke = kd + maxg ke1 = ke + 1 !  remaining space for use by denseL.f or schurQR.f lu1 = ke1 + maxg !  total number of double precision locations required by glcpd kkk = nm + n + maxg * ( maxg + 1 ) / 2 + maxg * ( kmax + 5 ) !  integer storage (lws) !  locations 1:ll are user workspace for funct and grad !  number of integer locations required by glcpd lll = 0 !  remaining space for use by denseL.f or schurQR.f ll1 = ll + 1 return end subroutine check ( n , nm , nmi , kmax , g , a , la , x , bl , bu , r , ls , an , f , & ws , lws , cws , ninf , peq , k , lev , p , alp2 ) implicit double precision ( a - h , r - z ), integer ( i - q ) dimension g ( * ), a ( * ), la ( * ), x ( * ), bl ( * ), bu ( * ), r ( * ), ls ( * ), & an ( * ), ws ( * ), lws ( * ) character cws ( * ) common / noutc / nout common / epsc / eps , tol , emin !     if(lev==2) then !       do i=1,n !         an(i)=g(i) !       end do !       e=alp2*sign(1.D0,dble(p)) !       i=abs(p) !       if(i.le.n) then !         an(i)=an(i)-e !       else !         call saipy(-e,a,la,i-n,an,n) !       end if !        goto 1 !     end if j = nmi * ( nmi + 1 ) / 2 do i = 1 , nmi j = j - abs ( ls ( i )) end do if ( j /= 0 ) write ( nout , * ) 'indexing error' if ( j /= 0 ) stop do j = 1 , peq i = abs ( ls ( j )) if ( bu ( i ) > bl ( i )) then write ( nout , * ) 'non-equality constraint i =' , i stop end if end do do j = n - k + 1 , n i = ls ( j ) if ( i . le . 0 . or . i > n ) then write ( nout , * ) 'faulty free variable: i, j =' , i , j stop end if end do e = 0.D0 do j = n + 1 , nm i = abs ( ls ( j )) if ( i . le . n ) then s = x ( i ) else s = aiscpr ( n , a , la , i - n , x , 0.D0 ) end if if ( ls ( j ) > 0 ) then !         print *,'i,s,r(i),bl(i)',i,s,r(i),bl(i) s = r ( i ) - s + bl ( i ) else s = r ( i ) + s - bu ( i ) end if if ( abs ( s ). le . tol * max ( 1.D0 , abs ( r ( i )))) s = 0.D0 if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do if ( e > tol ) write ( nout , * ) 'residual error at level 1 = ' , e , ie !     if(e>tol) stop if ( e > 1.D-6 ) stop if ( ninf == 0 ) then call funct ( n , x , ff , ws , lws , cws ) call grad ( n , x , an , ws , lws , cws ) else do i = 1 , n an ( i ) = 0.D0 end do ff = 0.D0 do j = n + 1 , nm i = abs ( ls ( j )) if ( r ( i ) < 0.D0 ) then ff = ff - r ( i ) if ( i > n ) then call saipy ( - sign ( 1.D0 , dble ( ls ( j ))), a , la , i - n , an , n ) else an ( i ) = an ( i ) - sign ( 1.D0 , dble ( ls ( j ))) end if end if end do end if gnm = sqrt ( scpr ( 0.D0 , an , an , n )) if ( lev == 1 . and . max ( abs ( f ), abs ( ff )) < 1.D20 ) then e = abs ( ff - f ) if ( e > tol * max ( 1.D0 , abs ( f ))) write ( nout , * ) 'function error = ' , e , & '   f(x) =' , ff !     if(e>tol) stop !       if(e>tol*max(1.D0,abs(f))) print 4,'x =',(x(j),j=1,n) if ( e > tol * max ( 1.D0 , abs ( f ))) stop end if 1 continue e = 0.D0 do j = 1 , n !       write(nout,*)'an =',(an(i),i=1,n) i = abs ( ls ( j )) s = sign ( 1.D0 , dble ( ls ( j ))) if ( i . le . n ) then !         print *,'i,s,r(i)',i,s,r(i) an ( i ) = an ( i ) - s * r ( i ) if ( j > n - k ) then s = max ( 0.D0 , bl ( i ) - x ( i ), x ( i ) - bu ( i )) else if ( ls ( j ) > 0 ) then s = x ( i ) - bl ( i ) else s = bu ( i ) - x ( i ) end if else !         print *,'i,s,r(i)',i,s,r(i) call saipy ( - s * r ( i ), a , la , i - n , an , n ) if ( ls ( j ) > 0 ) then s = aiscpr ( n , a , la , i - n , x , - bl ( i )) else s =- aiscpr ( n , a , la , i - n , x , - bu ( i )) end if end if if ( abs ( s ) > e ) then e = abs ( s ) ie = i end if end do if ( e > tol ) write ( nout , * ) 'residual error at level 2 = ' , e , ie !     if(e>tol) stop !     if(e>1.D-6) print 4,'x =',(x(i),i=1,n) if ( e > 1.D-6 ) stop e = 0.D0 do j = 1 , n if ( abs ( an ( j )) > e ) then e = abs ( an ( j )) ie = ls ( j ) je = j end if end do if ( e > gnm * tol ) write ( nout , * ) 'KT condition error = ' , e , je , ie , gnm !     if(e>gnm*tol) write(nout,4)'KT cond_n errors = ',(an(i),i=1,n) !     if(e>gnm*tol) stop if ( e > 1.D-4 ) stop 2 format ( A , 5E15 . 7 ) 4 format ( A / ( 5E15 . 6 )) return end","tags":"","loc":"sourcefile/glcpd.f90.html"},{"title":"aiscpr – filterSD","text":"function aiscpr(n, a, la, i, x, b) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b Return Value real Called by proc~~aiscpr~~CalledByGraph proc~aiscpr aiscpr proc~check1 check1 proc~check1->proc~aiscpr proc~funct funct proc~funct->proc~aiscpr proc~form_ats form_Ats proc~form_ats->proc~aiscpr proc~checkq checkq proc~checkq->proc~aiscpr proc~setfg2 setfg2 proc~checkq->proc~setfg2 proc~check check proc~check->proc~aiscpr proc~check->proc~funct proc~setfg2->proc~aiscpr proc~checkg checkg proc~checkg->proc~funct proc~glcpd glcpd proc~glcpd->proc~funct proc~qlcpd qlcpd proc~qlcpd->proc~setfg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpr.html"},{"title":"daiscpr – filterSD","text":"function daiscpr(n, a, la, i, x, b) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b Return Value double precision Contents None","tags":"","loc":"proc/daiscpr.html"},{"title":"aiscpri – filterSD","text":"function aiscpri(n, a, la, i, x, b, lr, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li Return Value real Called by proc~~aiscpri~~CalledByGraph proc~aiscpri aiscpri proc~eptsol0 eptsol0 proc~eptsol0->proc~aiscpri proc~factor factor proc~factor->proc~aiscpri proc~eptsol~2 eptsol proc~eptsol~2->proc~aiscpri proc~eptsol eptsol proc~eptsol->proc~aiscpri proc~eptsol->proc~eptsol0 proc~factor~2 factor proc~factor~2->proc~aiscpri proc~eptsol~3 eptsol proc~eptsol~3->proc~aiscpri proc~updatese updateSE proc~updatese->proc~eptsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri.html"},{"title":"daiscpri – filterSD","text":"function daiscpri(n, a, la, i, x, b, lr, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li Return Value double precision Contents None","tags":"","loc":"proc/daiscpri.html"},{"title":"aiscpri1 – filterSD","text":"function aiscpri1(n, a, la, i, x, b, lr, li, m1) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li integer :: m1 Return Value real Called by proc~~aiscpri1~~CalledByGraph proc~aiscpri1 aiscpri1 proc~r_flma r_flma proc~r_flma->proc~aiscpri1 proc~c_flma c_flma proc~c_flma->proc~aiscpri1 proc~checkout~2 checkout proc~checkout~2->proc~aiscpri1 proc~eptsol~2 eptsol proc~eptsol~2->proc~aiscpri1 proc~eptsol~2->proc~c_flma proc~pivot~2 pivot proc~pivot~2->proc~aiscpri1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri1.html"},{"title":"ailen – filterSD","text":"function ailen(n, a, la, i) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i Return Value real Called by proc~~ailen~~CalledByGraph proc~ailen ailen proc~start_up~2 start_up proc~start_up~2->proc~ailen proc~start_up start_up proc~start_up->proc~ailen proc~start_up~3 start_up proc~start_up~3->proc~ailen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ailen.html"},{"title":"aij – filterSD","text":"function aij(i, j, a, la) Arguments Type Intent Optional Attributes Name integer :: i integer :: j real :: a integer :: la Return Value real Called by proc~~aij~~CalledByGraph proc~aij aij proc~update_l update_L proc~update_l->proc~aij proc~checkout~3 checkout proc~checkout~3->proc~aij proc~re_factor~3 re_factor proc~re_factor~3->proc~aij proc~checkd checkd proc~checkd->proc~aij proc~re_factor re_factor proc~re_factor->proc~aij proc~checkout checkout proc~checkout->proc~aij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aij.html"},{"title":"saipy – filterSD","text":"subroutine saipy(s, a, la, i, y, n) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n Called by proc~~saipy~~CalledByGraph proc~saipy saipy proc~setfg2 setfg2 proc~setfg2->proc~saipy proc~checkq checkq proc~checkq->proc~setfg2 proc~qlcpd qlcpd proc~qlcpd->proc~setfg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/saipy.html"},{"title":"msaipy – filterSD","text":"subroutine msaipy(s, a, la, i, y, n) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n Contents None","tags":"","loc":"proc/msaipy.html"},{"title":"isaipy – filterSD","text":"subroutine isaipy(s, a, la, i, y, n, lr, li) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n integer :: lr integer :: li Contents None","tags":"","loc":"proc/isaipy.html"},{"title":"isaipy1 – filterSD","text":"subroutine isaipy1(s, a, la, i, y, n, lr, li, m1) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n integer :: lr integer :: li integer :: m1 Contents None","tags":"","loc":"proc/isaipy1.html"},{"title":"iscatter – filterSD","text":"subroutine iscatter(a, la, i, li, an, n) Arguments Type Intent Optional Attributes Name real :: a integer :: la integer :: i integer :: li real :: an integer :: n Called by proc~~iscatter~~CalledByGraph proc~iscatter iscatter proc~aqsol0 aqsol0 proc~aqsol0->proc~iscatter proc~factor factor proc~factor->proc~iscatter proc~re_factor~2 re_factor proc~re_factor~2->proc~iscatter proc~aqsol~2 aqsol proc~aqsol~2->proc~iscatter proc~aqsol aqsol proc~aqsol->proc~iscatter proc~aqsol->proc~aqsol0 proc~factor~2 factor proc~factor~2->proc~iscatter proc~aqsol~3 aqsol proc~aqsol~3->proc~iscatter proc~updatese updateSE proc~updatese->proc~aqsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iscatter.html"},{"title":"iunscatter – filterSD","text":"subroutine iunscatter(a, la, i, li, an, n) Arguments Type Intent Optional Attributes Name real :: a integer :: la integer :: i integer :: li real :: an integer :: n Called by proc~~iunscatter~~CalledByGraph proc~iunscatter iunscatter proc~re_factor~2 re_factor proc~re_factor~2->proc~iunscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iunscatter.html"},{"title":"setaij – filterSD","text":"subroutine setaij(aij, i, j, a, la) Arguments Type Intent Optional Attributes Name real :: aij integer :: i integer :: j real :: a integer :: la Contents None","tags":"","loc":"proc/setaij.html"},{"title":"cscale – filterSD","text":"subroutine cscale(n, m, a, la, x, bl, bu, s, menu, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: a integer :: la real :: x real :: bl real :: bu real :: s integer :: menu integer :: ifail Contents None","tags":"","loc":"proc/cscale.html"},{"title":"modify – filterSD","text":"subroutine modify(n, m, sigma, s, a, la, maxa, iws) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: sigma real :: s real :: a integer :: la integer :: maxa integer :: iws Contents None","tags":"","loc":"proc/modify.html"},{"title":"restore – filterSD","text":"subroutine restore(n, m, a, la) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: a integer :: la Contents None","tags":"","loc":"proc/restore.html"},{"title":"extend_la – filterSD","text":"subroutine extend_la(n, m, la, lax) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: la integer :: lax Contents None","tags":"","loc":"proc/extend_la.html"},{"title":"extend_a – filterSD","text":"subroutine extend_a(n, m, a, la, ax, lax, s, sigma) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: a integer :: la real :: ax integer :: lax real :: s real :: sigma Contents None","tags":"","loc":"proc/extend_a.html"},{"title":"optest – filterSD","text":"subroutine optest(jmin, jmax, r, e, ls, rp, pj) Arguments Type Intent Optional Attributes Name integer :: jmin integer :: jmax real :: r real :: e integer :: ls real :: rp real :: pj Called by proc~~optest~~CalledByGraph proc~optest optest proc~glcpd glcpd proc~glcpd->proc~optest proc~qlcpd qlcpd proc~qlcpd->proc~optest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/optest.html"},{"title":"form_Ats – filterSD","text":"subroutine form_Ats(jmin, jmax, n, plus, a, la, an, w, ls, tol) Arguments Type Intent Optional Attributes Name integer :: jmin integer :: jmax integer :: n logical :: plus real :: a integer :: la real :: an real :: w integer :: ls real :: tol Calls proc~~form_ats~~CallsGraph proc~form_ats form_Ats proc~aiscpr aiscpr proc~form_ats->proc~aiscpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/form_ats.html"},{"title":"zprod – filterSD","text":"subroutine zprod(k, n, a, la, an, r, w, ls, aa, ll) Arguments Type Intent Optional Attributes Name integer :: k integer :: n real :: a integer :: la real :: an real :: r real :: w integer :: ls real :: aa integer :: ll Calls proc~~zprod~~CallsGraph proc~zprod zprod proc~tfbsub tfbsub proc~zprod->proc~tfbsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/zprod.html"},{"title":"signst – filterSD","text":"subroutine signst(n, r, w, ls) Arguments Type Intent Optional Attributes Name integer :: n real :: r real :: w integer :: ls Called by proc~~signst~~CalledByGraph proc~signst signst proc~glcpd glcpd proc~glcpd->proc~signst proc~l1sold l1sold proc~l1sold->proc~signst proc~qlcpd qlcpd proc~qlcpd->proc~signst Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/signst.html"},{"title":"warm_start – filterSD","text":"subroutine warm_start(n, nm, a, la, x, bl, bu, b, ls, aa, ll, an, vstep) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: x real :: bl real :: bu real :: b integer :: ls real :: aa integer :: ll real :: an real :: vstep Calls proc~~warm_start~~CallsGraph proc~warm_start warm_start proc~linf linf proc~warm_start->proc~linf proc~tfbsub tfbsub proc~warm_start->proc~tfbsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks epsc noutc iprintc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint","tags":"","loc":"proc/warm_start.html"},{"title":"residuals – filterSD","text":"subroutine residuals(n, jmin, jmax, a, la, x, bl, bu, r, ls, f, g, ninf) Arguments Type Intent Optional Attributes Name integer :: n integer :: jmin integer :: jmax real :: a integer :: la real :: x real :: bl real :: bu real :: r integer :: ls real :: f real :: g integer :: ninf Contents Common Blocks epsc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/residuals.html"},{"title":"store_rg – filterSD","text":"subroutine store_rg(k, ig, G, r, ls) Arguments Type Intent Optional Attributes Name integer :: k integer :: ig real :: G real :: r integer :: ls Contents None","tags":"","loc":"proc/store_rg.html"},{"title":"trid – filterSD","text":"subroutine trid(d, e, n) Arguments Type Intent Optional Attributes Name real :: d real :: e integer :: n Contents None","tags":"","loc":"proc/trid.html"},{"title":"formR – filterSD","text":"subroutine formR(nv, k, ig, maxg, a, b, c, d, e, G, R) Arguments Type Intent Optional Attributes Name integer :: nv integer :: k integer :: ig integer :: maxg real :: a real :: b real :: c real :: d real :: e real :: G real :: R Calls proc~~formr~~CallsGraph proc~formr formR proc~scpr scpr proc~formr->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/formr.html"},{"title":"formT – filterSD","text":"subroutine formT(n, nmax, R, d, e) Arguments Type Intent Optional Attributes Name integer :: n integer :: nmax real :: R real :: d real :: e Contents None","tags":"","loc":"proc/formt.html"},{"title":"insort – filterSD","text":"subroutine insort(nv, v) Arguments Type Intent Optional Attributes Name integer :: nv real :: v Called by proc~~insort~~CalledByGraph proc~insort insort proc~glcpd glcpd proc~glcpd->proc~insort proc~qlcpd qlcpd proc~qlcpd->proc~insort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/insort.html"},{"title":"checkT – filterSD","text":"subroutine checkT(n, nmax, R, a, d) Arguments Type Intent Optional Attributes Name integer :: n integer :: nmax real :: R real :: a real :: d Calls proc~~checkt~~CallsGraph proc~checkt checkT t t proc~checkt->t proc~rtsol rtsol proc~checkt->proc~rtsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/checkt.html"},{"title":"l1sold – filterSD","text":"subroutine l1sold(n, m, k, kmax, maxg, a, la, x, bl, bu, f, g, r, w, e, ls, alp, lp, mlp, peq, ws, lws, cws, v, nv, rgtol, ifail, iprint, nout) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: k integer :: kmax integer :: maxg real :: a integer :: la real :: x real :: bl real :: bu real :: f real :: g real :: r real :: w real :: e integer :: ls real :: alp integer :: lp integer :: mlp real :: peq real :: ws integer :: lws character :: cws (*) real :: v integer :: nv real :: rgtol integer :: ifail integer :: iprint integer :: nout Calls proc~~l1sold~~CallsGraph proc~l1sold l1sold proc~newg newg proc~l1sold->proc~newg proc~optest1 optest1 proc~l1sold->proc~optest1 4 4 proc~l1sold->4 proc~signst signst proc~l1sold->proc~signst proc~scpr scpr proc~l1sold->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks lcpdc epsc infoc repc wsc refactorc alphac Common Blocks common /lcpdc/ Type Attributes Name Initial integer :: na integer :: na1 integer :: nb integer :: nb1 integer :: krg integer :: krg1 integer :: kr integer :: kr1 integer :: ka integer :: ka1 integer :: kb integer :: kb1 integer :: kc integer :: kc1 integer :: kd integer :: kd1 integer :: ke integer :: ke1 integer :: lu1 integer :: ll1 common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /infoc/ Type Attributes Name Initial real :: vstep integer :: iter integer :: npv integer :: nfn integer :: ngr common /repc/ Type Attributes Name Initial real :: sgnf integer :: nrep integer :: npiv integer :: nres common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /alphac/ Type Attributes Name Initial real :: alpha real :: rp real :: pj real :: qqj real :: qqj1","tags":"","loc":"proc/l1sold.html"},{"title":"optest1 – filterSD","text":"subroutine optest1(peq, k, n, bl, bu, r, e, ls, rp, pj) Arguments Type Intent Optional Attributes Name real :: peq integer :: k integer :: n real :: bl real :: bu real :: r real :: e integer :: ls real :: rp real :: pj Called by proc~~optest1~~CalledByGraph proc~optest1 optest1 proc~l1sold l1sold proc~l1sold->proc~optest1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/optest1.html"},{"title":"check1 – filterSD","text":"subroutine check1(n, nm, nmi, k, kmax, g, a, la, x, bl, bu, r, ls, lp, an, f, ws, lws, cws, lev, p, alp2) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nmi integer :: k integer :: kmax real :: g real :: a integer :: la real :: x real :: bl real :: bu real :: r integer :: ls integer :: lp real :: an real :: f real :: ws integer :: lws character :: cws (*) integer :: lev real :: p real :: alp2 Calls proc~~check1~~CallsGraph proc~check1 check1 proc~aiscpr aiscpr proc~check1->proc~aiscpr proc~scpr scpr proc~check1->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/check1.html"},{"title":"filterSD – filterSD","text":"subroutine filterSD(n, m, x, al, f, fmin, cstype, bl, bu, ws, lws, v, nv, maxa, maxla, maxu, maxiu, kmax, maxg, rho, htol, rgtol, maxit, iprint, nout, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: x real :: al real :: f real :: fmin character :: cstype (*) real :: bl real :: bu real :: ws integer :: lws real :: v integer :: nv integer :: maxa integer :: maxla integer :: maxu integer :: maxiu integer :: kmax integer :: maxg real :: rho real :: htol real :: rgtol integer :: maxit integer :: iprint integer :: nout integer :: ifail Contents Common Blocks wsc defaultc functc Common Blocks common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /defaultc/ Type Attributes Name Initial real :: ainfty real :: ubd integer :: mlp integer :: mxf common /functc/ Type Attributes Name Initial real :: fxd real :: alc integer :: m_ integer :: iph integer :: last1 integer :: next1 integer :: nx integer :: nx1 integer :: nal integer :: nal1 integer :: naal integer :: naal1 integer :: nxd integer :: nxd1 integer :: ncx integer :: ncx1 integer :: ncxd integer :: ncxd1 integer :: nla1","tags":"","loc":"proc/filtersd.html"},{"title":"filter_SD – filterSD","text":"subroutine filter_SD(n, f, fmin, cstype, bl, bu, ws, lws, v, nv, maxa, kmax, maxg, d, dl, du, g, r, w, e, ls, alp, lp, filh, filf, rho, htol, rgtol, maxit, iprint, nout, ifail) Arguments Type Intent Optional Attributes Name integer :: n real :: f real :: fmin character :: cstype (*) real :: bl real :: bu real :: ws integer :: lws real :: v integer :: nv integer :: maxa integer :: kmax integer :: maxg real :: d real :: dl real :: du real :: g real :: r real :: w real :: e integer :: ls real :: alp integer :: lp real :: filh real :: filf real :: rho real :: htol real :: rgtol integer :: maxit integer :: iprint integer :: nout integer :: ifail Calls proc~~filter_sd~~CallsGraph proc~filter_sd filter_SD proc~testfil testfil proc~filter_sd->proc~testfil proc~scpr scpr proc~filter_sd->proc~scpr proc~iexch iexch proc~filter_sd->proc~iexch proc~addfil addfil proc~filter_sd->proc~addfil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks defaultc epsc repc functc infoc ngrc statsc Common Blocks common /defaultc/ Type Attributes Name Initial real :: ainfty real :: ubd integer :: mlp integer :: mxf common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /repc/ Type Attributes Name Initial real :: sgnf integer :: nrep integer :: npiv integer :: nres common /functc/ Type Attributes Name Initial real :: fxd real :: alc integer :: m integer :: iph integer :: last1 integer :: next1 integer :: nx integer :: nx1 integer :: nal integer :: nal1 integer :: naal integer :: naal1 integer :: nxd integer :: nxd1 integer :: ncx integer :: ncx1 integer :: ncxd integer :: ncxd1 integer :: nla1 common /infoc/ Type Attributes Name Initial real :: rgnorm real :: vstep integer :: iter integer :: npv integer :: nfn integer :: ngr common /ngrc/ Type Attributes Name Initial integer :: mxgr common /statsc/ Type Attributes Name Initial real :: dnorm real :: h real :: hJt real :: hJ integer :: ipeq integer :: k integer :: itn integer :: nft integer :: ngt","tags":"","loc":"proc/filter_sd.html"},{"title":"testfil – filterSD","text":"subroutine testfil(h, f, filh, filf, nfil1, nfil, ifail) Arguments Type Intent Optional Attributes Name real :: h real :: f real :: filh real :: filf integer :: nfil1 integer :: nfil integer :: ifail Called by proc~~testfil~~CalledByGraph proc~testfil testfil proc~filter_sd filter_SD proc~filter_sd->proc~testfil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/testfil.html"},{"title":"addfil – filterSD","text":"subroutine addfil(h, f, filh, filf, nfil1, nfil, mxf, ifail) Arguments Type Intent Optional Attributes Name real :: h real :: f real :: filh real :: filf integer :: nfil1 integer :: nfil integer :: mxf integer :: ifail Called by proc~~addfil~~CalledByGraph proc~addfil addfil proc~filter_sd filter_SD proc~filter_sd->proc~addfil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addfil.html"},{"title":"funct – filterSD","text":"subroutine funct(n, d, phi, ws, lws, cstype) Arguments Type Intent Optional Attributes Name integer :: n real :: d real :: phi real :: ws integer :: lws character :: cstype (*) Calls proc~~funct~~CallsGraph proc~funct funct proc~aiscpr aiscpr proc~funct->proc~aiscpr proc~scpr scpr proc~funct->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~funct~~CalledByGraph proc~funct funct proc~checkg checkg proc~checkg->proc~funct proc~glcpd glcpd proc~glcpd->proc~funct proc~check check proc~check->proc~funct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks defaultc functc Common Blocks common /defaultc/ Type Attributes Name Initial real :: ainfty real :: ubd integer :: mlp integer :: mxf common /functc/ Type Attributes Name Initial real :: fxd real :: alc integer :: m integer :: iph integer :: last1 integer :: next1 integer :: nx integer :: nx1 integer :: nal integer :: nal1 integer :: naal integer :: naal1 integer :: nxd integer :: nxd1 integer :: ncx integer :: ncx1 integer :: ncxd integer :: ncxd1 integer :: nla1","tags":"","loc":"proc/funct.html"},{"title":"grad – filterSD","text":"subroutine grad(n, d, g, ws, lws, cstype) Arguments Type Intent Optional Attributes Name integer :: n real :: d real :: g real :: ws integer :: lws character :: cstype (*) Called by proc~~grad~~CalledByGraph proc~grad grad proc~checkg checkg proc~checkg->proc~grad proc~glcpd glcpd proc~glcpd->proc~grad proc~check check proc~check->proc~grad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks defaultc functc maxac Common Blocks common /defaultc/ Type Attributes Name Initial real :: ainfty real :: ubd integer :: mlp integer :: mxf common /functc/ Type Attributes Name Initial real :: fxd real :: alc integer :: m integer :: iph integer :: last1 integer :: next1 integer :: nx integer :: nx1 integer :: nal integer :: nal1 integer :: naal integer :: naal1 integer :: nxd integer :: nxd1 integer :: ncx integer :: ncx1 integer :: ncxd integer :: ncxd1 integer :: nla1 common /maxac/ Type Attributes Name Initial integer :: maxa","tags":"","loc":"proc/grad.html"},{"title":"checkd – filterSD","text":"subroutine checkd(n, m, x, al, ws, lws, maxa, maxla, maxu, maxiu, mxws, mxlws, tol) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: x real :: al real :: ws integer :: lws integer :: maxa integer :: maxla integer :: maxu integer :: maxiu integer :: mxws integer :: mxlws real :: tol Calls proc~~checkd~~CallsGraph proc~checkd checkd proc~aij aij proc~checkd->proc~aij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/checkd.html"},{"title":"scpr – filterSD","text":"function scpr(a, x, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x real :: y integer :: n Return Value real Called by proc~~scpr~~CalledByGraph proc~scpr scpr proc~aqsol aqsol proc~aqsol->proc~scpr proc~qtprod Qtprod proc~aqsol->proc~qtprod proc~aqsol0 aqsol0 proc~aqsol->proc~aqsol0 proc~rsol rsol proc~aqsol->proc~rsol proc~ailen~2 ailen proc~ailen~2->proc~scpr proc~glcpd glcpd proc~glcpd->proc~scpr proc~funct funct proc~glcpd->proc~funct proc~checkq checkq proc~checkq->proc~scpr proc~setfg2 setfg2 proc~checkq->proc~setfg2 proc~tfbsub~2 tfbsub proc~tfbsub~2->proc~scpr proc~filter_sd filter_SD proc~filter_sd->proc~scpr proc~factor factor proc~factor->proc~scpr proc~updateqr updateQR proc~updateqr->proc~scpr proc~re_factor~2 re_factor proc~re_factor~2->proc~scpr proc~aiscpr~2 aiscpr proc~aiscpr~2->proc~scpr proc~factor~2 factor proc~factor~2->proc~scpr proc~qtprod->proc~scpr proc~check1 check1 proc~check1->proc~scpr proc~funct->proc~scpr proc~aqsol~2 aqsol proc~aqsol~2->proc~scpr proc~pivot~2 pivot proc~pivot~2->proc~scpr proc~l1sold l1sold proc~l1sold->proc~scpr proc~aqsol0->proc~scpr proc~formr formR proc~formr->proc~scpr proc~check check proc~check->proc~scpr proc~check->proc~funct proc~qlcpd qlcpd proc~qlcpd->proc~scpr proc~qlcpd->proc~setfg2 proc~setfg2->proc~scpr proc~aqsol~3 aqsol proc~aqsol~3->proc~scpr proc~rsol->proc~scpr proc~checkg checkg proc~checkg->proc~funct proc~updatese updateSE proc~updatese->proc~aqsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/scpr.html"},{"title":"xlen – filterSD","text":"function xlen(a, x, n) Arguments Type Intent Optional Attributes Name real :: a real :: x integer :: n Return Value real Called by proc~~xlen~~CalledByGraph proc~xlen xlen proc~eptsol eptsol proc~eptsol->proc~xlen proc~tfbsub~3 tfbsub proc~tfbsub~3->proc~xlen proc~pivot~3 pivot proc~pivot~3->proc~xlen proc~updatese updateSE proc~updatese->proc~eptsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xlen.html"},{"title":"rsol – filterSD","text":"subroutine rsol(n, nn, nmax, R, b) Arguments Type Intent Optional Attributes Name integer :: n integer :: nn integer :: nmax real :: R real :: b Calls proc~~rsol~~CallsGraph proc~rsol rsol proc~scpr scpr proc~rsol->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rsol~~CalledByGraph proc~rsol rsol proc~aqsol aqsol proc~aqsol->proc~rsol proc~updatese updateSE proc~updatese->proc~aqsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rsol.html"},{"title":"rtsol – filterSD","text":"subroutine rtsol(n, nn, nmax, R, b) Arguments Type Intent Optional Attributes Name integer :: n integer :: nn integer :: nmax real :: R real :: b Called by proc~~rtsol~~CalledByGraph proc~rtsol rtsol proc~eptsol eptsol proc~eptsol->proc~rtsol proc~checkt checkT proc~checkt->proc~rtsol proc~updatese updateSE proc~updatese->proc~eptsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rtsol.html"},{"title":"Qprod – filterSD","text":"subroutine Qprod(n, nmax, Q, x, b) Arguments Type Intent Optional Attributes Name integer :: n integer :: nmax real :: Q real :: x real :: b Called by proc~~qprod~~CalledByGraph proc~qprod Qprod proc~eptsol eptsol proc~eptsol->proc~qprod proc~updatese updateSE proc~updatese->proc~eptsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/qprod.html"},{"title":"Qtprod – filterSD","text":"subroutine Qtprod(n, nmax, Q, x, b) Arguments Type Intent Optional Attributes Name integer :: n integer :: nmax real :: Q real :: x real :: b Calls proc~~qtprod~~CallsGraph proc~qtprod Qtprod proc~scpr scpr proc~qtprod->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~qtprod~~CalledByGraph proc~qtprod Qtprod proc~aqsol aqsol proc~aqsol->proc~qtprod proc~updatese updateSE proc~updatese->proc~aqsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/qtprod.html"},{"title":"brots – filterSD","text":"subroutine brots(n, nmax, k, kk, R, v) Arguments Type Intent Optional Attributes Name integer :: n integer :: nmax integer :: k integer :: kk real :: R real :: v Contents None","tags":"","loc":"proc/brots.html"},{"title":"frots – filterSD","text":"subroutine frots(nr, nc, nmax, R, v) Arguments Type Intent Optional Attributes Name integer :: nr integer :: nc integer :: nmax real :: R real :: v Contents None","tags":"","loc":"proc/frots.html"},{"title":"angle – filterSD","text":"subroutine angle(a, b, cos, sin) Arguments Type Intent Optional Attributes Name real :: a real :: b real :: cos real :: sin Contents None","tags":"","loc":"proc/angle.html"},{"title":"rot – filterSD","text":"subroutine rot(n, a, b, cos, sin) Arguments Type Intent Optional Attributes Name integer :: n real :: a real :: b real :: cos real :: sin Contents None","tags":"","loc":"proc/rot.html"},{"title":"mysaxpy – filterSD","text":"subroutine mysaxpy(a, x, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x real :: y integer :: n Contents None","tags":"","loc":"proc/mysaxpy.html"},{"title":"saxpys – filterSD","text":"subroutine saxpys(a, x, is, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x integer :: is real :: y integer :: n Contents None","tags":"","loc":"proc/saxpys.html"},{"title":"saxpyx – filterSD","text":"subroutine saxpyx(a, x, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x real :: y integer :: n Contents None","tags":"","loc":"proc/saxpyx.html"},{"title":"saxpyz – filterSD","text":"subroutine saxpyz(a, x, y, z, n) Arguments Type Intent Optional Attributes Name real :: a real :: x real :: y real :: z integer :: n Contents None","tags":"","loc":"proc/saxpyz.html"},{"title":"saxpyi – filterSD","text":"subroutine saxpyi(a, x, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x real :: y integer :: n Contents None","tags":"","loc":"proc/saxpyi.html"},{"title":"linf – filterSD","text":"subroutine linf(n, x, z, iz) Arguments Type Intent Optional Attributes Name integer :: n real :: x real :: z integer :: iz Called by proc~~linf~~CalledByGraph proc~linf linf proc~warm_start warm_start proc~warm_start->proc~linf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/linf.html"},{"title":"r_shift – filterSD","text":"subroutine r_shift(r, n, k) Arguments Type Intent Optional Attributes Name real :: r integer :: n integer :: k Contents None","tags":"","loc":"proc/r_shift.html"},{"title":"ishift – filterSD","text":"subroutine ishift(l, n, k) Arguments Type Intent Optional Attributes Name integer :: l integer :: n integer :: k Contents None","tags":"","loc":"proc/ishift.html"},{"title":"rexch – filterSD","text":"subroutine rexch(a, b) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b Contents None","tags":"","loc":"proc/rexch.html"},{"title":"vexch – filterSD","text":"subroutine vexch(a, b, n) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b integer :: n Called by proc~~vexch~~CalledByGraph proc~vexch vexch proc~permop permop proc~permop->proc~vexch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vexch.html"},{"title":"iexch – filterSD","text":"subroutine iexch(i, j) Arguments Type Intent Optional Attributes Name integer :: i integer :: j Called by proc~~iexch~~CalledByGraph proc~iexch iexch proc~filter_sd filter_SD proc~filter_sd->proc~iexch proc~glcpd glcpd proc~glcpd->proc~iexch proc~update_l update_L proc~update_l->proc~iexch proc~qlcpd qlcpd proc~qlcpd->proc~iexch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iexch.html"},{"title":"checkg – filterSD","text":"subroutine checkg(n, x, h, a, b, user, iuser, cuser, tol) Arguments Type Intent Optional Attributes Name integer :: n real :: x real :: h real :: a real :: b real :: user integer :: iuser character :: cuser (*) real :: tol Calls proc~~checkg~~CallsGraph proc~checkg checkg proc~funct funct proc~checkg->proc~funct proc~grad grad proc~checkg->proc~grad proc~aiscpr aiscpr proc~funct->proc~aiscpr proc~scpr scpr proc~funct->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/checkg.html"},{"title":"aiscpri2 – filterSD","text":"function aiscpri2(n, a, la, rowi, coli, ws, di, im, pri, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: rowi integer :: coli real :: ws real :: di integer :: im integer :: pri integer :: li Return Value real Called by proc~~aiscpri2~~CalledByGraph proc~aiscpri2 aiscpri2 proc~checkout checkout proc~checkout->proc~aiscpri2 proc~re_factor re_factor proc~re_factor->proc~aiscpri2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri2.html"},{"title":"start_up – filterSD","text":"subroutine start_up(n, nm, nmi, a, la, nk, e, ls, aa, ll, mode, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nmi real :: a integer :: la integer :: nk real :: e integer :: ls real :: aa integer :: ll integer :: mode integer :: ifail Calls proc~~start_up~~CallsGraph proc~start_up start_up proc~ailen ailen proc~start_up->proc~ailen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc wsc epsc schurc factorc refactorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll_ integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /schurc/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: neb integer :: neb1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 integer :: nq integer :: nq1 integer :: nr integer :: nr1 integer :: ny integer :: ny1 integer :: nz integer :: nz1 integer :: lv integer :: lv1 integer :: le integer :: le1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc","tags":"","loc":"proc/start_up.html"},{"title":"refactor – filterSD","text":"subroutine refactor(n, nm, a, la, aa, ll, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: aa integer :: ll integer :: ifail Contents Common Blocks schurc factorc noutc Common Blocks common /schurc/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: neb integer :: neb1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 integer :: nq integer :: nq1 integer :: nr integer :: nr1 integer :: ny integer :: ny1 integer :: nz integer :: nz1 integer :: lv integer :: lv1 integer :: le integer :: le1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/refactor.html"},{"title":"pivot – filterSD","text":"subroutine pivot(p, q, n, nm, a, la, e, aa, ll, ifail, npv) Arguments Type Intent Optional Attributes Name real :: p real :: q integer :: n integer :: nm real :: a integer :: la real :: e real :: aa integer :: ll integer :: ifail integer :: npv Contents Common Blocks noutc iprintc schurc factorc mxm1c refactorc epsc pqc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint common /schurc/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: neb integer :: neb1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 integer :: nq integer :: nq1 integer :: nr integer :: nr1 integer :: ny integer :: ny1 integer :: nz integer :: nz1 integer :: lv integer :: lv1 integer :: le integer :: le1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /mxm1c/ Type Attributes Name Initial integer :: mxm1 common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /pqc/ Type Attributes Name Initial real :: pc real :: qr integer :: lmp","tags":"","loc":"proc/pivot.html"},{"title":"fbsub – filterSD","text":"subroutine fbsub(n, jmin, jmax, a, la, q, b, x, ls, aa, ll, save) Arguments Type Intent Optional Attributes Name integer :: n integer :: jmin integer :: jmax real :: a integer :: la real :: q real :: b real :: x integer :: ls real :: aa integer :: ll logical :: save Contents Common Blocks noutc schurc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /schurc/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: neb integer :: neb1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 integer :: nq integer :: nq1 integer :: nr integer :: nr1 integer :: ny integer :: ny1 integer :: nz integer :: nz1 integer :: lv integer :: lv1 integer :: le integer :: le1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/fbsub.html"},{"title":"ztg – filterSD","text":"subroutine ztg(n, k, rg, lv, aa, ll) Arguments Type Intent Optional Attributes Name integer :: n integer :: k real :: rg integer :: lv real :: aa integer :: ll Contents Common Blocks schurc Common Blocks common /schurc/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: neb integer :: neb1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 integer :: nq integer :: nq1 integer :: nr integer :: nr1 integer :: ny integer :: ny1 integer :: nz integer :: nz1 integer :: lv_ integer :: lv1 integer :: le integer :: le1","tags":"","loc":"proc/ztg.html"},{"title":"tfbsub – filterSD","text":"subroutine tfbsub(n, a, la, p, b, x, aa, ll, ep, save) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b real :: x real :: aa integer :: ll real :: ep logical :: save Called by proc~~tfbsub~~CalledByGraph proc~tfbsub tfbsub proc~zprod zprod proc~zprod->proc~tfbsub proc~warm_start warm_start proc~warm_start->proc~tfbsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc schurc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /schurc/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: neb integer :: neb1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 integer :: nq integer :: nq1 integer :: nr integer :: nr1 integer :: ny integer :: ny1 integer :: nz integer :: nz1 integer :: lv integer :: lv1 integer :: le integer :: le1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/tfbsub.html"},{"title":"newg – filterSD","text":"subroutine newg() Arguments None Called by proc~~newg~~CalledByGraph proc~newg newg proc~glcpd glcpd proc~glcpd->proc~newg proc~l1sold l1sold proc~l1sold->proc~newg proc~qlcpd qlcpd proc~qlcpd->proc~newg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/newg.html"},{"title":"check_L – filterSD","text":"subroutine check_L(n, d, p, ifail) Arguments Type Intent Optional Attributes Name integer :: n real :: d real :: p integer :: ifail Contents Common Blocks noutc factorc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/check_l.html"},{"title":"aqsol – filterSD","text":"subroutine aqsol(n, a, la, q, Q_, R, EB, z, t, u, x, d, ws, lr, lc, li, lv, le, pp, qq) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: q double precision :: Q_ real :: R real :: EB real :: z real :: t real :: u real :: x real :: d real :: ws integer :: lr integer :: lc integer :: li integer :: lv integer :: le real :: pp real :: qq Calls proc~~aqsol~~CallsGraph proc~aqsol aqsol proc~qtprod Qtprod proc~aqsol->proc~qtprod proc~aqsol0 aqsol0 proc~aqsol->proc~aqsol0 proc~rsol rsol proc~aqsol->proc~rsol proc~scpr scpr proc~aqsol->proc~scpr proc~iscatter iscatter proc~aqsol->proc~iscatter proc~qtprod->proc~scpr proc~aqsol0->proc~scpr proc~aqsol0->proc~iscatter proc~rsol->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aqsol~~CalledByGraph proc~aqsol aqsol proc~updatese updateSE proc~updatese->proc~aqsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc refactorc pqc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /pqc/ Type Attributes Name Initial real :: pc real :: qr integer :: lmp","tags":"","loc":"proc/aqsol.html"},{"title":"aqsol0 – filterSD","text":"subroutine aqsol0(n, a, la, q, tn, xn, d, ws, lr, lc, li, pp, qq) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: q real :: tn real :: xn real :: d real :: ws integer :: lr integer :: lc integer :: li real :: pp real :: qq Calls proc~~aqsol0~~CallsGraph proc~aqsol0 aqsol0 proc~scpr scpr proc~aqsol0->proc~scpr proc~iscatter iscatter proc~aqsol0->proc~iscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aqsol0~~CalledByGraph proc~aqsol0 aqsol0 proc~aqsol aqsol proc~aqsol->proc~aqsol0 proc~updatese updateSE proc~updatese->proc~aqsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/aqsol0.html"},{"title":"eptsol – filterSD","text":"subroutine eptsol(n, a, la, p, b, Q_, R, EB, y, s, u, x, d, ws, lr, lc, li, lv, le, pp, qq, ep) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b double precision :: Q_ real :: R real :: EB real :: y real :: s real :: u real :: x real :: d real :: ws integer :: lr integer :: lc integer :: li integer :: lv integer :: le real :: pp real :: qq real :: ep Calls proc~~eptsol~~CallsGraph proc~eptsol eptsol proc~eptsol0 eptsol0 proc~eptsol->proc~eptsol0 proc~qprod Qprod proc~eptsol->proc~qprod proc~xlen xlen proc~eptsol->proc~xlen proc~aiscpri aiscpri proc~eptsol->proc~aiscpri proc~rtsol rtsol proc~eptsol->proc~rtsol proc~eptsol0->proc~aiscpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eptsol~~CalledByGraph proc~eptsol eptsol proc~updatese updateSE proc~updatese->proc~eptsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks epsc factorc refactorc pqc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /pqc/ Type Attributes Name Initial real :: pc real :: qr integer :: lmp","tags":"","loc":"proc/eptsol.html"},{"title":"eptsol0 – filterSD","text":"subroutine eptsol0(n, a, la, p, b, sn, d, ws, lr, lc, li, pp, qq) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b real :: sn real :: d real :: ws integer :: lr integer :: lc integer :: li real :: pp real :: qq Calls proc~~eptsol0~~CallsGraph proc~eptsol0 eptsol0 proc~aiscpri aiscpri proc~eptsol0->proc~aiscpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eptsol0~~CalledByGraph proc~eptsol0 eptsol0 proc~eptsol eptsol proc~eptsol->proc~eptsol0 proc~updatese updateSE proc~updatese->proc~eptsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks epsc factorc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/eptsol0.html"},{"title":"order – filterSD","text":"subroutine order(n, nu, nc, la, lr, ls, li, p, q, r, ws, mxws, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nu integer :: nc integer :: la integer :: lr integer :: ls integer :: li real :: p real :: q real :: r double precision :: ws integer :: mxws integer :: ifail Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/order.html"},{"title":"factor – filterSD","text":"subroutine factor(n, nm, nu, nc, a, la, e, ls, sn, tn, un, xn, lr, lc, li, mao, p, q, r, s, ws, mxws, d, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nu integer :: nc real :: a integer :: la real :: e integer :: ls real :: sn real :: tn real :: un real :: xn integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q integer :: r integer :: s real :: ws integer :: mxws real :: d integer :: ifail Calls proc~~factor~~CallsGraph proc~factor factor proc~newslot newslot proc~factor->proc~newslot proc~aiscpri aiscpri proc~factor->proc~aiscpri proc~scpr scpr proc~factor->proc~scpr proc~iscatter iscatter proc~factor->proc~iscatter proc~erase erase proc~newslot->proc~erase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc iprintc refactorc epsc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /iprintc/ Type Attributes Name Initial integer :: iprint common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/factor.html"},{"title":"re_order – filterSD","text":"subroutine re_order(n, nm, a, la, point, lr, lc, li, mao, p, q, r, s, t, ws, mxws, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: point integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q real :: r real :: s real :: t real :: ws integer :: mxws integer :: ifail Contents Common Blocks factorc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/re_order.html"},{"title":"re_factor – filterSD","text":"subroutine re_factor(n, nm, a, la, lr, lc, li, mao, p, q, r, s, t, ws, mxws, d, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q real :: r real :: s real :: t real :: ws integer :: mxws real :: d integer :: ifail Calls proc~~re_factor~~CallsGraph proc~re_factor re_factor proc~newslot newslot proc~re_factor->proc~newslot proc~aiscpri2 aiscpri2 proc~re_factor->proc~aiscpri2 proc~aij aij proc~re_factor->proc~aij proc~erase erase proc~newslot->proc~erase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc iprintc refactorc epsc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /iprintc/ Type Attributes Name Initial integer :: iprint common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /epsc/ Type Attributes Name Initial real :: eps double precision :: tol real :: emin common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/re_factor.html"},{"title":"updateSE – filterSD","text":"subroutine updateSE(p, q, n, nm, a, la, e, Q_, R, EB, y, z, s, t, u, x, d, ws, lr, lc, li, pp, qq, lm, lv, le, ifail) Arguments Type Intent Optional Attributes Name integer :: p integer :: q integer :: n integer :: nm real :: a integer :: la real :: e real :: Q_ real :: R real :: EB real :: y real :: z real :: s real :: t real :: u real :: x real :: d real :: ws integer :: lr integer :: lc integer :: li integer :: pp integer :: qq integer :: lm integer :: lv integer :: le integer :: ifail Calls proc~~updatese~~CallsGraph proc~updatese updateSE proc~eptsol eptsol proc~updatese->proc~eptsol proc~aqsol aqsol proc~updatese->proc~aqsol proc~eptsol0 eptsol0 proc~eptsol->proc~eptsol0 proc~qprod Qprod proc~eptsol->proc~qprod proc~xlen xlen proc~eptsol->proc~xlen proc~aiscpri aiscpri proc~eptsol->proc~aiscpri proc~rtsol rtsol proc~eptsol->proc~rtsol proc~qtprod Qtprod proc~aqsol->proc~qtprod proc~aqsol0 aqsol0 proc~aqsol->proc~aqsol0 proc~rsol rsol proc~aqsol->proc~rsol proc~scpr scpr proc~aqsol->proc~scpr proc~iscatter iscatter proc~aqsol->proc~iscatter proc~qtprod->proc~scpr proc~eptsol0->proc~aiscpri proc~aqsol0->proc~scpr proc~aqsol0->proc~iscatter proc~rsol->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc refactorc epsc pqc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /pqc/ Type Attributes Name Initial integer :: pc integer :: qr integer :: lmp","tags":"","loc":"proc/updatese.html"},{"title":"updateQR – filterSD","text":"subroutine updateQR(p, q, n, a, la, Q_, R, EB, x, y, z, lr, lc, li, lv, le, lm, ifail) Arguments Type Intent Optional Attributes Name integer :: p integer :: q integer :: n real :: a integer :: la real :: Q_ real :: R real :: EB real :: x real :: y real :: z integer :: lr integer :: lc integer :: li integer :: lv integer :: le integer :: lm integer :: ifail Calls proc~~updateqr~~CallsGraph proc~updateqr updateQR proc~scpr scpr proc~updateqr->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc refactorc epsc pqc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /pqc/ Type Attributes Name Initial integer :: pc integer :: qr integer :: lmp","tags":"","loc":"proc/updateqr.html"},{"title":"newslot – filterSD","text":"subroutine newslot(row, len, lastr, irow, p, q, r, s, ws, mxws, qr_, ifail) Arguments Type Intent Optional Attributes Name real :: row integer :: len integer :: lastr integer :: irow real :: p real :: q real :: r real :: s real :: ws integer :: mxws real :: qr_ integer :: ifail Calls proc~~newslot~~CallsGraph proc~newslot newslot proc~erase erase proc~newslot->proc~erase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~newslot~~CalledByGraph proc~newslot newslot proc~factor factor proc~factor->proc~newslot proc~re_factor re_factor proc~re_factor->proc~newslot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/newslot.html"},{"title":"erase – filterSD","text":"subroutine erase(row, lastr, irow, r, s) Arguments Type Intent Optional Attributes Name real :: row integer :: lastr integer :: irow real :: r real :: s Called by proc~~erase~~CalledByGraph proc~erase erase proc~newslot newslot proc~newslot->proc~erase proc~factor factor proc~factor->proc~newslot proc~re_factor re_factor proc~re_factor->proc~newslot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/erase.html"},{"title":"trim_ – filterSD","text":"subroutine trim_(rowi, pri, qri, q, ws) Arguments Type Intent Optional Attributes Name real :: rowi real :: pri real :: qri real :: q real :: ws Contents Common Blocks epsc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/trim_.html"},{"title":"EBspace – filterSD","text":"subroutine EBspace(n, p, q, s, lr, ws, neb, nprof, ifail) Arguments Type Intent Optional Attributes Name integer :: n real :: p real :: q real :: s integer :: lr real :: ws integer :: neb integer :: nprof integer :: ifail Contents Common Blocks factorc refactorc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/ebspace.html"},{"title":"checkperms – filterSD","text":"subroutine checkperms(n, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n integer :: lr integer :: lc integer :: li Contents Common Blocks factorc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/checkperms.html"},{"title":"checkout – filterSD","text":"subroutine checkout(n, a, la, lr, lc, li, p, q, r, s, ws, mxws, d) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: lr integer :: lc integer :: li real :: p real :: q integer :: r integer :: s real :: ws integer :: mxws real :: d Calls proc~~checkout~~CallsGraph proc~checkout checkout proc~aiscpri2 aiscpri2 proc~checkout->proc~aiscpri2 proc~aij aij proc~checkout->proc~aij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc noutc epsc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /noutc/ Type Attributes Name Initial integer :: nout common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/checkout.html"},{"title":"start_up – filterSD","text":"subroutine start_up(n, nm, nmi, a, la, nk, e, ls, aa, ll, mode, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nmi real :: a integer :: la integer :: nk real :: e integer :: ls real :: aa integer :: ll integer :: mode integer :: ifail Calls proc~~start_up~2~~CallsGraph proc~start_up~2 start_up proc~check_l~2 check_L proc~start_up~2->proc~check_l~2 proc~ailen ailen proc~start_up~2->proc~ailen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc wsc epsc densec factorc refactorc mxm1c Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll_ integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /densec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: mx1 integer :: lc integer :: lc1 integer :: li integer :: li1 common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /mxm1c/ Type Attributes Name Initial integer :: mxm1","tags":"","loc":"proc/start_up~2.html"},{"title":"refactor – filterSD","text":"subroutine refactor(n, nm, a, la, aa, ll, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: aa integer :: ll integer :: ifail Calls proc~~refactor~2~~CallsGraph proc~refactor~2 refactor proc~check_l~2 check_L proc~refactor~2->proc~check_l~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks densec factorc Common Blocks common /densec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: mx1 integer :: lc integer :: lc1 integer :: li integer :: li1 common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/refactor~2.html"},{"title":"pivot – filterSD","text":"subroutine pivot(p, q, n, nm, a, la, e, aa, ll, ifail, info) Arguments Type Intent Optional Attributes Name real :: p real :: q integer :: n integer :: nm real :: a integer :: la real :: e real :: aa integer :: ll integer :: ifail integer :: info Calls proc~~pivot~2~~CallsGraph proc~pivot~2 pivot proc~check_l~2 check_L proc~pivot~2->proc~check_l~2 proc~scpr scpr proc~pivot~2->proc~scpr proc~aiscpri1 aiscpri1 proc~pivot~2->proc~aiscpri1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc iprintc densec factorc mxm1c refactorc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint common /densec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: mx1 integer :: lc integer :: lc1 integer :: li integer :: li1 common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq common /mxm1c/ Type Attributes Name Initial integer :: mxm1 common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/pivot~2.html"},{"title":"fbsub – filterSD","text":"subroutine fbsub(n, jmin, jmax, a, la, q, b, x, ls, aa, ll, save) Arguments Type Intent Optional Attributes Name integer :: n integer :: jmin integer :: jmax real :: a integer :: la real :: q real :: b real :: x integer :: ls real :: aa integer :: ll logical :: save Contents Common Blocks noutc densec factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /densec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: mx1 integer :: lc integer :: lc1 integer :: li integer :: li1 common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/fbsub~2.html"},{"title":"tfbsub – filterSD","text":"subroutine tfbsub(n, a, la, p, b, x, aa, ll, ep, save) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b real :: x real :: aa integer :: ll real :: ep logical :: save Calls proc~~tfbsub~2~~CallsGraph proc~tfbsub~2 tfbsub proc~scpr scpr proc~tfbsub~2->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc densec factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /densec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: mx1 integer :: lc integer :: lc1 integer :: li integer :: li1 common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/tfbsub~2.html"},{"title":"newg – filterSD","text":"subroutine newg() Arguments None Contents Common Blocks factorc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/newg~2.html"},{"title":"re_factor – filterSD","text":"subroutine re_factor(n, nm, a, la, T, sn, tn, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: T real :: sn real :: tn integer :: lr integer :: lc integer :: li Calls proc~~re_factor~2~~CallsGraph proc~re_factor~2 re_factor proc~scpr scpr proc~re_factor~2->proc~scpr proc~iunscatter iunscatter proc~re_factor~2->proc~iunscatter proc~iscatter iscatter proc~re_factor~2->proc~iscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc iprintc refactorc factorc mxm1c epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq common /mxm1c/ Type Attributes Name Initial integer :: mxm1 common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/re_factor~2.html"},{"title":"check_L – filterSD","text":"subroutine check_L(n, T, ifail) Arguments Type Intent Optional Attributes Name integer :: n real :: T integer :: ifail Called by proc~~check_l~2~~CalledByGraph proc~check_l~2 check_L proc~refactor~2 refactor proc~refactor~2->proc~check_l~2 proc~start_up~2 start_up proc~start_up~2->proc~check_l~2 proc~pivot~2 pivot proc~pivot~2->proc~check_l~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc factorc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/check_l~2.html"},{"title":"aqsol – filterSD","text":"subroutine aqsol(n, a, la, q, b, tn, xm, T, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: q real :: b real :: tn real :: xm real :: T integer :: lr integer :: lc integer :: li Calls proc~~aqsol~2~~CallsGraph proc~aqsol~2 aqsol proc~scpr scpr proc~aqsol~2->proc~scpr proc~iscatter iscatter proc~aqsol~2->proc~iscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/aqsol~2.html"},{"title":"eptsol – filterSD","text":"subroutine eptsol(n, a, la, p, b, T, sn, tn, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b real :: T real :: sn real :: tn integer :: lr integer :: lc integer :: li Calls proc~~eptsol~2~~CallsGraph proc~eptsol~2 eptsol proc~c_flma c_flma proc~eptsol~2->proc~c_flma proc~aiscpri aiscpri proc~eptsol~2->proc~aiscpri proc~aiscpri1 aiscpri1 proc~eptsol~2->proc~aiscpri1 proc~c_flma->proc~aiscpri1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc iprintc epsc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/eptsol~2.html"},{"title":"c_flma – filterSD","text":"subroutine c_flma(n, a, la, q, T, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: q real :: T integer :: lr integer :: lc integer :: li Calls proc~~c_flma~~CallsGraph proc~c_flma c_flma proc~aiscpri1 aiscpri1 proc~c_flma->proc~aiscpri1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~c_flma~~CalledByGraph proc~c_flma c_flma proc~eptsol~2 eptsol proc~eptsol~2->proc~c_flma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc mxm1c epsc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /mxm1c/ Type Attributes Name Initial integer :: mxm1 common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/c_flma.html"},{"title":"r_flma – filterSD","text":"subroutine r_flma(n, a, la, p, T, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: T integer :: lr integer :: lc integer :: li Calls proc~~r_flma~~CallsGraph proc~r_flma r_flma proc~aiscpri1 aiscpri1 proc~r_flma->proc~aiscpri1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc epsc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/r_flma.html"},{"title":"permop – filterSD","text":"subroutine permop(v1, v2, r, s, n) Arguments Type Intent Optional Attributes Name real :: v1 real :: v2 real :: r real :: s integer :: n Calls proc~~permop~~CallsGraph proc~permop permop proc~vexch vexch proc~permop->proc~vexch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/permop.html"},{"title":"checkout – filterSD","text":"subroutine checkout(n, a, la, T, lr, lc, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: T integer :: lr integer :: lc integer :: li Calls proc~~checkout~2~~CallsGraph proc~checkout~2 checkout proc~aiscpri1 aiscpri1 proc~checkout~2->proc~aiscpri1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc mxm1c epsc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /mxm1c/ Type Attributes Name Initial integer :: mxm1 common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m0 integer :: m1 integer :: mm0 integer :: mm integer :: mp integer :: mq","tags":"","loc":"proc/checkout~2.html"},{"title":"qlcpd – filterSD","text":"subroutine qlcpd(n, m, k, kmax, maxg, a, la, x, bl, bu, f, fmin, g, r, w, e, ls, alp, lp, mlp, peq, ws, lws, v, nv, linear, rgtol, m0de, ifail, mxgr, iprint, nout) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: k integer :: kmax integer :: maxg real :: a integer :: la real :: x real :: bl real :: bu real :: f real :: fmin real :: g real :: r real :: w real :: e integer :: ls real :: alp integer :: lp integer :: mlp real :: peq real :: ws integer :: lws real :: v integer :: nv logical :: linear real :: rgtol integer :: m0de integer :: ifail integer :: mxgr integer :: iprint integer :: nout Calls proc~~qlcpd~~CallsGraph proc~qlcpd qlcpd proc~scpr scpr proc~qlcpd->proc~scpr proc~newg newg proc~qlcpd->proc~newg proc~stmapq stmapq proc~qlcpd->proc~stmapq 4 4 proc~qlcpd->4 proc~optest optest proc~qlcpd->proc~optest proc~iexch iexch proc~qlcpd->proc~iexch proc~signst signst proc~qlcpd->proc~signst proc~setfg2 setfg2 proc~qlcpd->proc~setfg2 proc~insort insort proc~qlcpd->proc~insort proc~setfg2->proc~scpr proc~aiscpr aiscpr proc~setfg2->proc~aiscpr proc~saipy saipy proc~setfg2->proc~saipy gdotx gdotx proc~setfg2->gdotx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks lcpdc epsc infoc repc wsc refactorc alphac Common Blocks common /lcpdc/ Type Attributes Name Initial integer :: na integer :: na1 integer :: nb integer :: nb1 integer :: krg integer :: krg1 integer :: kr integer :: kr1 integer :: ka integer :: ka1 integer :: kb integer :: kb1 integer :: kc integer :: kc1 integer :: kd integer :: kd1 integer :: ke integer :: ke1 integer :: lu1 integer :: ll1 common /epsc/ Type Attributes Name Initial real :: eps real :: t0l real :: emin common /infoc/ Type Attributes Name Initial real :: rgnorm real :: vstep integer :: iter integer :: npv integer :: ngr common /repc/ Type Attributes Name Initial real :: sgnf integer :: nrep integer :: npiv integer :: nres common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /alphac/ Type Attributes Name Initial real :: alpha real :: rp real :: pj real :: qqj real :: qqj1","tags":"","loc":"proc/qlcpd.html"},{"title":"stmapq – filterSD","text":"subroutine stmapq(n, nm, kmax, maxg) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: kmax integer :: maxg Called by proc~~stmapq~~CalledByGraph proc~stmapq stmapq proc~qlcpd qlcpd proc~qlcpd->proc~stmapq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks wsc lcpdc Common Blocks common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /lcpdc/ Type Attributes Name Initial integer :: na integer :: na1 integer :: nb integer :: nb1 integer :: krg integer :: krg1 integer :: kr integer :: kr1 integer :: ka integer :: ka1 integer :: kb integer :: kb1 integer :: kc integer :: kc1 integer :: kd integer :: kd1 integer :: ke integer :: ke1 integer :: lu1 integer :: ll1","tags":"","loc":"proc/stmapq.html"},{"title":"setfg2 – filterSD","text":"subroutine setfg2(n, linear, a, la, x, f, g, ws, lws) Arguments Type Intent Optional Attributes Name integer :: n logical :: linear real :: a integer :: la real :: x real :: f real :: g real :: ws integer :: lws Calls proc~~setfg2~~CallsGraph proc~setfg2 setfg2 proc~aiscpr aiscpr proc~setfg2->proc~aiscpr proc~saipy saipy proc~setfg2->proc~saipy proc~scpr scpr proc~setfg2->proc~scpr gdotx gdotx proc~setfg2->gdotx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setfg2~~CalledByGraph proc~setfg2 setfg2 proc~checkq checkq proc~checkq->proc~setfg2 proc~qlcpd qlcpd proc~qlcpd->proc~setfg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/setfg2.html"},{"title":"checkq – filterSD","text":"subroutine checkq(n, nm, nmi, kmax, g, a, la, x, bl, bu, r, ls, an, f, ws, lws, ninf, peq, k, lev, p, alp2, linear) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nmi integer :: kmax real :: g real :: a integer :: la real :: x real :: bl real :: bu real :: r integer :: ls real :: an real :: f real :: ws integer :: lws integer :: ninf real :: peq integer :: k integer :: lev real :: p real :: alp2 logical :: linear Calls proc~~checkq~~CallsGraph proc~checkq checkq proc~aiscpr aiscpr proc~checkq->proc~aiscpr proc~setfg2 setfg2 proc~checkq->proc~setfg2 proc~scpr scpr proc~checkq->proc~scpr proc~setfg2->proc~aiscpr proc~setfg2->proc~scpr proc~saipy saipy proc~setfg2->proc~saipy gdotx gdotx proc~setfg2->gdotx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/checkq.html"},{"title":"aiscpr – filterSD","text":"function aiscpr(n, a, la, i, x, b) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b Return Value real Calls proc~~aiscpr~2~~CallsGraph proc~aiscpr~2 aiscpr proc~scpr scpr proc~aiscpr~2->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpr~2.html"},{"title":"daiscpr – filterSD","text":"function daiscpr(n, a, la, i, x, b) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b Return Value double precision Contents None","tags":"","loc":"proc/daiscpr~2.html"},{"title":"aiscpri – filterSD","text":"function aiscpri(n, a, la, i, x, b, lr, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li Return Value real Calls proc~~aiscpri~2~~CallsGraph proc~aiscpri~2 aiscpri proc~scpri scpri proc~aiscpri~2->proc~scpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri~2.html"},{"title":"daiscpri – filterSD","text":"function daiscpri(n, a, la, i, x, b, lr, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li Return Value double precision Contents None","tags":"","loc":"proc/daiscpri~2.html"},{"title":"aiscpri1 – filterSD","text":"function aiscpri1(n, a, la, i, x, b, lr, li, m1) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li integer :: m1 Return Value real Calls proc~~aiscpri1~2~~CallsGraph proc~aiscpri1~2 aiscpri1 proc~scpri scpri proc~aiscpri1~2->proc~scpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri1~2.html"},{"title":"aiscpri2 – filterSD","text":"function aiscpri2(n, a, la, i, x, b, lr, li, m1) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i real :: x real :: b integer :: lr integer :: li integer :: m1 Return Value real Calls proc~~aiscpri2~2~~CallsGraph proc~aiscpri2~2 aiscpri2 proc~scpri scpri proc~aiscpri2~2->proc~scpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri2~2.html"},{"title":"ailen – filterSD","text":"function ailen(n, a, la, i) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: i Return Value real Calls proc~~ailen~2~~CallsGraph proc~ailen~2 ailen proc~scpr scpr proc~ailen~2->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ailen~2.html"},{"title":"aij – filterSD","text":"function aij(i, j, a, la) Arguments Type Intent Optional Attributes Name integer :: i integer :: j real :: a integer :: la Return Value real Contents None","tags":"","loc":"proc/aij~2.html"},{"title":"dscpr – filterSD","text":"function dscpr(a, x, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x real :: y integer :: n Return Value double precision Contents None","tags":"","loc":"proc/dscpr.html"},{"title":"scpri – filterSD","text":"function scpri(a, x, lr, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x integer :: lr real :: y integer :: n Return Value real Called by proc~~scpri~~CalledByGraph proc~scpri scpri proc~aiscpri2~2 aiscpri2 proc~aiscpri2~2->proc~scpri proc~aiscpri~2 aiscpri proc~aiscpri~2->proc~scpri proc~aiscpri1~2 aiscpri1 proc~aiscpri1~2->proc~scpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/scpri.html"},{"title":"dscpri – filterSD","text":"function dscpri(a, x, lr, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x integer :: lr real :: y integer :: n Return Value double precision Contents None","tags":"","loc":"proc/dscpri.html"},{"title":"saipy – filterSD","text":"subroutine saipy(s, a, la, i, y, n) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n Contents None","tags":"","loc":"proc/saipy~2.html"},{"title":"isaipy – filterSD","text":"subroutine isaipy(s, a, la, i, y, n, lr, li) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n integer :: lr integer :: li Contents None","tags":"","loc":"proc/isaipy~2.html"},{"title":"isaipy1 – filterSD","text":"subroutine isaipy1(s, a, la, i, y, n, lr, li, m1) Arguments Type Intent Optional Attributes Name real :: s real :: a integer :: la integer :: i real :: y integer :: n integer :: lr integer :: li integer :: m1 Contents None","tags":"","loc":"proc/isaipy1~2.html"},{"title":"iscatter – filterSD","text":"subroutine iscatter(a, la, i, li, an, n) Arguments Type Intent Optional Attributes Name real :: a integer :: la integer :: i integer :: li real :: an integer :: n Contents None","tags":"","loc":"proc/iscatter~2.html"},{"title":"iunscatter – filterSD","text":"subroutine iunscatter(a, la, i, li, an, n) Arguments Type Intent Optional Attributes Name real :: a integer :: la integer :: i integer :: li real :: an integer :: n Contents None","tags":"","loc":"proc/iunscatter~2.html"},{"title":"setaij – filterSD","text":"subroutine setaij(aij, i, j, a, la) Arguments Type Intent Optional Attributes Name real :: aij integer :: i integer :: j real :: a integer :: la Contents None","tags":"","loc":"proc/setaij~2.html"},{"title":"isaxpy – filterSD","text":"subroutine isaxpy(a, x, lr, y, n) Arguments Type Intent Optional Attributes Name real :: a real :: x integer :: lr real :: y integer :: n Contents None","tags":"","loc":"proc/isaxpy.html"},{"title":"cscale – filterSD","text":"subroutine cscale(n, m, a, la, x, bl, bu, s, menu, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: a integer :: la real :: x real :: bl real :: bu real :: s integer :: menu integer :: ifail Contents None","tags":"","loc":"proc/cscale~2.html"},{"title":"aiscpri2 – filterSD","text":"function aiscpri2(n, a, la, rowi, coli, ws, di, im, pri, li) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: rowi integer :: coli real :: ws real :: di integer :: im integer :: pri integer :: li Return Value real Called by proc~~aiscpri2~3~~CalledByGraph proc~aiscpri2~3 aiscpri2 proc~re_factor~3 re_factor proc~re_factor~3->proc~aiscpri2~3 proc~update_l update_L proc~update_l->proc~aiscpri2~3 proc~checkout~3 checkout proc~checkout~3->proc~aiscpri2~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aiscpri2~3.html"},{"title":"start_up – filterSD","text":"subroutine start_up(n, nm, nmi, a, la, nk, e, ls, aa, ll, mode, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nmi real :: a integer :: la integer :: nk real :: e integer :: ls real :: aa integer :: ll integer :: mode integer :: ifail Calls proc~~start_up~3~~CallsGraph proc~start_up~3 start_up proc~ailen ailen proc~start_up~3->proc~ailen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc wsc epsc sparsec factorc refactorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll_ integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /sparsec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq","tags":"","loc":"proc/start_up~3.html"},{"title":"refactor – filterSD","text":"subroutine refactor(n, nm, a, la, aa, ll, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: aa integer :: ll integer :: ifail Contents Common Blocks sparsec factorc noutc Common Blocks common /sparsec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls integer :: ls1 integer :: lt integer :: lt1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/refactor~3.html"},{"title":"pivot – filterSD","text":"subroutine pivot(p, q, n, nm, a, la, e, aa, ll, ifail, info) Arguments Type Intent Optional Attributes Name real :: p real :: q integer :: n integer :: nm real :: a integer :: la real :: e real :: aa integer :: ll integer :: ifail integer :: info Calls proc~~pivot~3~~CallsGraph proc~pivot~3 pivot proc~xlen xlen proc~pivot~3->proc~xlen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc iprintc sparsec factorc mxm1c refactorc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint common /sparsec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls integer :: ls1 integer :: lt integer :: lt1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /mxm1c/ Type Attributes Name Initial integer :: mxm1 common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/pivot~3.html"},{"title":"fbsub – filterSD","text":"subroutine fbsub(n, jmin, jmax, a, la, q, b, x, ls, aa, ll, save) Arguments Type Intent Optional Attributes Name integer :: n integer :: jmin integer :: jmax real :: a integer :: la real :: q real :: b real :: x integer :: ls real :: aa integer :: ll logical :: save Contents Common Blocks noutc sparsec factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /sparsec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/fbsub~3.html"},{"title":"ztg – filterSD","text":"subroutine ztg(n, k, rg, lv, aa, ll) Arguments Type Intent Optional Attributes Name integer :: n integer :: k real :: rg integer :: lv real :: aa integer :: ll Contents Common Blocks sparsec Common Blocks common /sparsec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls_ integer :: ls1 integer :: lt integer :: lt1","tags":"","loc":"proc/ztg~2.html"},{"title":"tfbsub – filterSD","text":"subroutine tfbsub(n, a, la, p, b, x, aa, ll, ep, save) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b real :: x real :: aa integer :: ll real :: ep logical :: save Calls proc~~tfbsub~3~~CallsGraph proc~tfbsub~3 tfbsub proc~xlen xlen proc~tfbsub~3->proc~xlen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc sparsec factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /sparsec/ Type Attributes Name Initial integer :: ns integer :: ns1 integer :: nt integer :: nt1 integer :: nu integer :: nu1 integer :: nx integer :: nx1 integer :: np integer :: np1 integer :: nprof integer :: lc integer :: lc1 integer :: li integer :: li1 integer :: lm integer :: lm1 integer :: lp integer :: lp1 integer :: lq integer :: lq1 integer :: lr integer :: lr1 integer :: ls integer :: ls1 integer :: lt integer :: lt1 common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/tfbsub~3.html"},{"title":"newg – filterSD","text":"subroutine newg() Arguments None Contents Common Blocks factorc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/newg~3.html"},{"title":"check_L – filterSD","text":"subroutine check_L(n, d, p, ifail) Arguments Type Intent Optional Attributes Name integer :: n real :: d real :: p integer :: ifail Contents Common Blocks noutc factorc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/check_l~3.html"},{"title":"aqsol – filterSD","text":"subroutine aqsol(n, a, la, q, b, tn, xn, d, ws, lr, lc, li, pp, qq) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: q real :: b real :: tn real :: xn real :: d real :: ws integer :: lr integer :: lc integer :: li real :: pp real :: qq Calls proc~~aqsol~3~~CallsGraph proc~aqsol~3 aqsol proc~scpr scpr proc~aqsol~3->proc~scpr proc~iscatter iscatter proc~aqsol~3->proc~iscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/aqsol~3.html"},{"title":"eptsol – filterSD","text":"subroutine eptsol(n, a, la, p, b, sn, tn, d, ws, lr, lc, li, pp, qq) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la real :: p real :: b real :: sn real :: tn real :: d real :: ws integer :: lr integer :: lc integer :: li real :: pp real :: qq Calls proc~~eptsol~3~~CallsGraph proc~eptsol~3 eptsol proc~aiscpri aiscpri proc~eptsol~3->proc~aiscpri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc iprintc epsc factorc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /iprintc/ Type Attributes Name Initial integer :: iprint common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow","tags":"","loc":"proc/eptsol~3.html"},{"title":"order – filterSD","text":"subroutine order(n, nu, nc, la, lr, ls, li, p, q, r, ws, mxws, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nu integer :: nc integer :: la integer :: lr integer :: ls integer :: li real :: p real :: q real :: r double precision :: ws integer :: mxws integer :: ifail Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/order~2.html"},{"title":"factor – filterSD","text":"subroutine factor(n, nm, nu, nc, a, la, e, ls, sn, tn, un, xn, lr, lc, li, mao, p, q, r, s, ws, mxws, d, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nu integer :: nc real :: a integer :: la real :: e integer :: ls real :: sn real :: tn real :: un real :: xn integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q integer :: r integer :: s real :: ws integer :: mxws real :: d integer :: ifail Calls proc~~factor~2~~CallsGraph proc~factor~2 factor proc~newslot~2 newslot proc~factor~2->proc~newslot~2 proc~aiscpri aiscpri proc~factor~2->proc~aiscpri proc~scpr scpr proc~factor~2->proc~scpr proc~iscatter iscatter proc~factor~2->proc~iscatter proc~erase~2 erase proc~newslot~2->proc~erase~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc iprintc refactorc epsc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: m2 integer :: mp integer :: mq integer :: lastr integer :: irow common /iprintc/ Type Attributes Name Initial integer :: iprint common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/factor~2.html"},{"title":"re_order – filterSD","text":"subroutine re_order(n, nm, a, la, point, lr, lc, li, mao, p, q, r, s, t, ws, mxws, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la real :: point integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q real :: r real :: s real :: t real :: ws integer :: mxws integer :: ifail Contents Common Blocks factorc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/re_order~2.html"},{"title":"re_factor – filterSD","text":"subroutine re_factor(n, nm, a, la, lr, lc, li, mao, p, q, r, s, t, ws, mxws, d, ifail) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm real :: a integer :: la integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q real :: r real :: s real :: t real :: ws integer :: mxws real :: d integer :: ifail Calls proc~~re_factor~3~~CallsGraph proc~re_factor~3 re_factor proc~aij aij proc~re_factor~3->proc~aij proc~newslot~2 newslot proc~re_factor~3->proc~newslot~2 proc~aiscpri2~3 aiscpri2 proc~re_factor~3->proc~aiscpri2~3 proc~erase~2 erase proc~newslot~2->proc~erase~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc iprintc refactorc epsc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /iprintc/ Type Attributes Name Initial integer :: iprint common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /epsc/ Type Attributes Name Initial real :: eps double precision :: tol real :: emin common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/re_factor~3.html"},{"title":"update_L – filterSD","text":"subroutine update_L(pp, qq, n, nm, a, la, lr, lc, li, mao, p, q, r, s, ws, mxws, d, sn, ifail) Arguments Type Intent Optional Attributes Name real :: pp real :: qq integer :: n integer :: nm real :: a integer :: la integer :: lr integer :: lc integer :: li integer :: mao real :: p real :: q integer :: r integer :: s real :: ws integer :: mxws real :: d real :: sn integer :: ifail Calls proc~~update_l~~CallsGraph proc~update_l update_L proc~newslot~2 newslot proc~update_l->proc~newslot~2 proc~aij aij proc~update_l->proc~aij proc~iexch iexch proc~update_l->proc~iexch proc~erase~2 erase proc~update_l->proc~erase~2 proc~trim_~2 trim_ proc~update_l->proc~trim_~2 proc~aiscpri2~3 aiscpri2 proc~update_l->proc~aiscpri2~3 proc~newslot~2->proc~erase~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc refactorc iprintc epsc noutc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /refactorc/ Type Attributes Name Initial integer :: nup integer :: nfreq common /iprintc/ Type Attributes Name Initial integer :: iprint common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/update_l.html"},{"title":"newslot – filterSD","text":"subroutine newslot(row, len, lastr, irow, p, q, r, s, ws, mxws, qr_, ifail) Arguments Type Intent Optional Attributes Name real :: row integer :: len integer :: lastr integer :: irow real :: p real :: q real :: r real :: s real :: ws integer :: mxws real :: qr_ integer :: ifail Calls proc~~newslot~2~~CallsGraph proc~newslot~2 newslot proc~erase~2 erase proc~newslot~2->proc~erase~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~newslot~2~~CalledByGraph proc~newslot~2 newslot proc~re_factor~3 re_factor proc~re_factor~3->proc~newslot~2 proc~update_l update_L proc~update_l->proc~newslot~2 proc~factor~2 factor proc~factor~2->proc~newslot~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/newslot~2.html"},{"title":"erase – filterSD","text":"subroutine erase(row, lastr, irow, r, s) Arguments Type Intent Optional Attributes Name real :: row integer :: lastr integer :: irow real :: r real :: s Called by proc~~erase~2~~CalledByGraph proc~erase~2 erase proc~newslot~2 newslot proc~newslot~2->proc~erase~2 proc~update_l update_L proc~update_l->proc~erase~2 proc~update_l->proc~newslot~2 proc~re_factor~3 re_factor proc~re_factor~3->proc~newslot~2 proc~factor~2 factor proc~factor~2->proc~newslot~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout","tags":"","loc":"proc/erase~2.html"},{"title":"trim_ – filterSD","text":"subroutine trim_(rowi, pri, qri, q, ws) Arguments Type Intent Optional Attributes Name real :: rowi real :: pri real :: qri real :: q real :: ws Called by proc~~trim_~2~~CalledByGraph proc~trim_~2 trim_ proc~update_l update_L proc~update_l->proc~trim_~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks epsc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/trim_~2.html"},{"title":"checkout – filterSD","text":"subroutine checkout(n, a, la, lr, lc, li, p, q, r, s, ws, mxws, d) Arguments Type Intent Optional Attributes Name integer :: n real :: a integer :: la integer :: lr integer :: lc integer :: li real :: p real :: q integer :: r integer :: s real :: ws integer :: mxws real :: d Calls proc~~checkout~3~~CallsGraph proc~checkout~3 checkout proc~aij aij proc~checkout~3->proc~aij proc~aiscpri2~3 aiscpri2 proc~checkout~3->proc~aiscpri2~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks factorc noutc epsc Common Blocks common /factorc/ Type Attributes Name Initial integer :: m1 integer :: nu integer :: mp integer :: mq integer :: lastr integer :: irow common /noutc/ Type Attributes Name Initial integer :: nout common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/checkout~3.html"},{"title":"glcpd – filterSD","text":"subroutine glcpd(n, m, k, kmax, maxg, a, la, x, bl, bu, f, fmin, g, r, w, e, ls, alp, lp, mlp, peq, ws, lws, cws, v, nv, rgtol, m0de, ifail, mxgr, iprint, nout) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: k integer :: kmax integer :: maxg real :: a integer :: la real :: x real :: bl real :: bu real :: f real :: fmin real :: g real :: r real :: w real :: e integer :: ls real :: alp integer :: lp integer :: mlp real :: peq real :: ws integer :: lws character :: cws (*) real :: v integer :: nv real :: rgtol integer :: m0de integer :: ifail integer :: mxgr integer :: iprint integer :: nout Calls proc~~glcpd~~CallsGraph proc~glcpd glcpd proc~scpr scpr proc~glcpd->proc~scpr proc~newg newg proc~glcpd->proc~newg proc~funct funct proc~glcpd->proc~funct 4 4 proc~glcpd->4 proc~grad grad proc~glcpd->proc~grad proc~stmap stmap proc~glcpd->proc~stmap proc~optest optest proc~glcpd->proc~optest proc~iexch iexch proc~glcpd->proc~iexch proc~signst signst proc~glcpd->proc~signst proc~insort insort proc~glcpd->proc~insort proc~funct->proc~scpr proc~aiscpr aiscpr proc~funct->proc~aiscpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks lcpdc epsc infoc repc wsc refactorc alphac Common Blocks common /lcpdc/ Type Attributes Name Initial integer :: na integer :: na1 integer :: nb integer :: nb1 integer :: krg integer :: krg1 integer :: kr integer :: kr1 integer :: ka integer :: ka1 integer :: kb integer :: kb1 integer :: kc integer :: kc1 integer :: kd integer :: kd1 integer :: ke integer :: ke1 integer :: lu1 integer :: ll1 common /epsc/ Type Attributes Name Initial real :: eps real :: t0l real :: emin common /infoc/ Type Attributes Name Initial real :: rgnorm real :: vstep integer :: iter integer :: npv integer :: nfn integer :: ngr common /repc/ Type Attributes Name Initial real :: sgnf integer :: nrep integer :: npiv integer :: nres common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /alphac/ Type Attributes Name Initial real :: alpha real :: rp real :: pj real :: qqj real :: qqj1","tags":"","loc":"proc/glcpd.html"},{"title":"stmap – filterSD","text":"subroutine stmap(n, nm, kmax, maxg) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: kmax integer :: maxg Called by proc~~stmap~~CalledByGraph proc~stmap stmap proc~glcpd glcpd proc~glcpd->proc~stmap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks wsc lcpdc Common Blocks common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws common /lcpdc/ Type Attributes Name Initial integer :: na integer :: na1 integer :: nb integer :: nb1 integer :: krg integer :: krg1 integer :: kr integer :: kr1 integer :: ka integer :: ka1 integer :: kb integer :: kb1 integer :: kc integer :: kc1 integer :: kd integer :: kd1 integer :: ke integer :: ke1 integer :: lu1 integer :: ll1","tags":"","loc":"proc/stmap.html"},{"title":"check – filterSD","text":"subroutine check(n, nm, nmi, kmax, g, a, la, x, bl, bu, r, ls, an, f, ws, lws, cws, ninf, peq, k, lev, p, alp2) Arguments Type Intent Optional Attributes Name integer :: n integer :: nm integer :: nmi integer :: kmax real :: g real :: a integer :: la real :: x real :: bl real :: bu real :: r integer :: ls real :: an real :: f real :: ws integer :: lws character :: cws (*) integer :: ninf real :: peq integer :: k integer :: lev real :: p real :: alp2 Calls proc~~check~~CallsGraph proc~check check proc~funct funct proc~check->proc~funct proc~aiscpr aiscpr proc~check->proc~aiscpr proc~scpr scpr proc~check->proc~scpr proc~grad grad proc~check->proc~grad proc~funct->proc~aiscpr proc~funct->proc~scpr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks noutc epsc Common Blocks common /noutc/ Type Attributes Name Initial integer :: nout common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin","tags":"","loc":"proc/check.html"},{"title":"defaults – filterSD","text":"Contents Common Blocks epsc repc refactorc wsc Common Blocks common /epsc/ Type Attributes Name Initial real :: eps real :: tol real :: emin common /repc/ Type Attributes Name Initial real :: sgnf integer :: nrep integer :: npiv integer :: nres common /refactorc/ Type Attributes Name Initial integer :: mc integer :: mxmc common /wsc/ Type Attributes Name Initial integer :: kk integer :: ll integer :: kkk integer :: lll integer :: mxws integer :: mxlws","tags":"","loc":"blockdata/defaults.html"},{"title":"nlp_defaults – filterSD","text":"Contents Common Blocks defaultc ngrc Common Blocks common /defaultc/ Type Attributes Name Initial real :: ainfty real :: ubd integer :: mlp integer :: mxf common /ngrc/ Type Attributes Name Initial integer :: mxgr","tags":"","loc":"blockdata/nlp_defaults.html"}]}